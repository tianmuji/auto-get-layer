<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åˆ†ç»„ç®—æ³•æµ‹è¯•</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin-bottom: 40px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
        }
        .test-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
        }
        .canvas {
            position: relative;
            background: #f9f9f9;
            border: 2px solid #ddd;
            border-radius: 5px;
            margin: 15px 0;
            height: 400px;
            overflow: hidden;
        }
        .element {
            position: absolute;
            border: 2px solid;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        .element-container { background-color: #4299e1; border-color: #3182ce; }
        .element-image { background-color: #48bb78; border-color: #38a169; }
        .element-text { background-color: #ed8936; border-color: #dd6b20; }
        .element-button { background-color: #9f7aea; border-color: #805ad5; }
        .element-normal { background-color: #38b2ac; border-color: #319795; }
        .element-conflict { background-color: #f56565; border-color: #e53e3e; }
        
        .group-boundary {
            position: absolute;
            border: 3px dashed #4299e1;
            background: rgba(66, 153, 225, 0.1);
            border-radius: 8px;
            pointer-events: none;
            z-index: 5;
        }
        
        .group-label {
            position: absolute;
            top: -12px;
            left: 8px;
            background: #4299e1;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8em;
            font-weight: 600;
        }
        
        .results {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }
        
        .group-item {
            background: white;
            padding: 10px;
            margin: 8px 0;
            border-radius: 5px;
            border-left: 4px solid #4299e1;
        }
        
        .conflict-item {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 4px;
            padding: 8px;
            margin: 4px 0;
            color: #dc2626;
        }
        
        .debug-info {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ§® çº¯æ•°å­¦å‡ ä½•åˆ†ç»„ç®—æ³•æµ‹è¯•</h1>
        
        <!-- æµ‹è¯•ç”¨ä¾‹1: ç®€å•å¡ç‰‡å¸ƒå±€ -->
        <div class="test-section">
            <div class="test-title">ğŸ“± æµ‹è¯•ç”¨ä¾‹1: ç®€å•å¡ç‰‡å¸ƒå±€</div>
            <div class="canvas" id="test1-canvas"></div>
            <div class="results" id="test1-results"></div>
            <div class="debug-info" id="test1-debug"></div>
        </div>
        
        <!-- æµ‹è¯•ç”¨ä¾‹2: é‡å å†²çª -->
        <div class="test-section">
            <div class="test-title">âš ï¸ æµ‹è¯•ç”¨ä¾‹2: é‡å å†²çª</div>
            <div class="canvas" id="test2-canvas"></div>
            <div class="results" id="test2-results"></div>
            <div class="debug-info" id="test2-debug"></div>
        </div>
        
        <!-- æµ‹è¯•ç”¨ä¾‹3: åµŒå¥—å®¹å™¨ -->
        <div class="test-section">
            <div class="test-title">ğŸ“¦ æµ‹è¯•ç”¨ä¾‹3: åµŒå¥—å®¹å™¨</div>
            <div class="canvas" id="test3-canvas"></div>
            <div class="results" id="test3-results"></div>
            <div class="debug-info" id="test3-debug"></div>
        </div>
    </div>

    <script>
        // æµ‹è¯•æ•°æ®
        const testCases = {
            test1: [
                { id: 'container', name: 'Card Container', x: 20, y: 20, width: 360, height: 300, type: 'container' },
                { id: 'image', name: 'Product Image', x: 40, y: 40, width: 320, height: 120, type: 'image' },
                { id: 'title', name: 'Product Title', x: 40, y: 180, width: 320, height: 30, type: 'text' },
                { id: 'desc', name: 'Description', x: 40, y: 220, width: 200, height: 40, type: 'text' },
                { id: 'price', name: 'Price', x: 40, y: 270, width: 80, height: 30, type: 'text' },
                { id: 'button', name: 'Buy Button', x: 260, y: 270, width: 100, height: 30, type: 'button' },
            ],
            
            test2: [
                { id: 'base', name: 'Base Container', x: 20, y: 20, width: 200, height: 200, type: 'container' },
                { id: 'normal', name: 'Normal Element', x: 40, y: 40, width: 80, height: 60, type: 'normal' },
                { id: 'independent', name: 'Independent', x: 40, y: 140, width: 80, height: 60, type: 'normal' },
                { id: 'overlap1', name: 'Overlap 1', x: 180, y: 100, width: 80, height: 80, type: 'conflict' },
                { id: 'overlap2', name: 'Overlap 2', x: 220, y: 140, width: 80, height: 80, type: 'conflict' },
            ],
            
            test3: [
                { id: 'outer', name: 'Outer Container', x: 10, y: 10, width: 300, height: 250, type: 'container' },
                { id: 'middle', name: 'Middle Container', x: 30, y: 30, width: 260, height: 210, type: 'container' },
                { id: 'inner', name: 'Inner Container', x: 50, y: 50, width: 220, height: 170, type: 'container' },
                { id: 'content1', name: 'Content 1', x: 70, y: 70, width: 80, height: 60, type: 'normal' },
                { id: 'content2', name: 'Content 2', x: 170, y: 70, width: 80, height: 60, type: 'normal' },
                { id: 'content3', name: 'Content 3', x: 70, y: 150, width: 180, height: 50, type: 'normal' },
            ]
        };

        // å‡ ä½•åˆ†ç»„ç®—æ³•
        function isElementContained(containerBounds, elementBounds) {
            return containerBounds.minX <= elementBounds.minX &&
                   containerBounds.minY <= elementBounds.minY &&
                   containerBounds.maxX >= elementBounds.maxX &&
                   containerBounds.maxY >= elementBounds.maxY;
        }

        function hasPartialOverlap(bounds1, bounds2) {
            const hasOverlap = !(bounds1.maxX <= bounds2.minX ||
                                bounds2.maxX <= bounds1.minX ||
                                bounds1.maxY <= bounds2.minY ||
                                bounds2.maxY <= bounds1.minY);
            const isContained1 = isElementContained(bounds1, bounds2);
            const isContained2 = isElementContained(bounds2, bounds1);

            return hasOverlap && !isContained1 && !isContained2;
        }

        function detectLayoutDirection(elements) {
            if (elements.length < 2) return 'VERTICAL';

            let horizontalGaps = 0;
            let verticalGaps = 0;

            for (let i = 0; i < elements.length - 1; i++) {
                for (let j = i + 1; j < elements.length; j++) {
                    const elem1 = elements[i];
                    const elem2 = elements[j];

                    const horizontalGap = Math.max(0, Math.max(elem1.bounds.minX - elem2.bounds.maxX, elem2.bounds.minX - elem1.bounds.maxX));
                    const verticalOverlap = Math.min(elem1.bounds.maxY, elem2.bounds.maxY) - Math.max(elem1.bounds.minY, elem2.bounds.minY);

                    if (horizontalGap < 50 && verticalOverlap > 0) {
                        horizontalGaps++;
                    }

                    const verticalGap = Math.max(0, Math.max(elem1.bounds.minY - elem2.bounds.maxY, elem2.bounds.minY - elem1.bounds.maxY));
                    const horizontalOverlap = Math.min(elem1.bounds.maxX, elem2.bounds.maxX) - Math.max(elem1.bounds.minX, elem2.bounds.minX);

                    if (verticalGap < 50 && horizontalOverlap > 0) {
                        verticalGaps++;
                    }
                }
            }

            return horizontalGaps > verticalGaps ? 'HORIZONTAL' : 'VERTICAL';
        }

        function performGeometricGrouping(elements) {
            console.log('å¼€å§‹åˆ†ç»„åˆ†æï¼Œå…ƒç´ æ•°é‡:', elements.length);
            
            const elementsWithBounds = elements.map(elem => ({
                ...elem,
                bounds: {
                    minX: elem.x,
                    minY: elem.y,
                    maxX: elem.x + elem.width,
                    maxY: elem.y + elem.height
                }
            }));

            console.log('å…ƒç´ è¾¹ç•Œä¿¡æ¯:', elementsWithBounds.map(e => ({
                name: e.name,
                bounds: e.bounds
            })));

            // è¯†åˆ«åŒ…å«å…³ç³»
            const parentChildRelations = [];
            for (let i = 0; i < elementsWithBounds.length; i++) {
                for (let j = 0; j < elementsWithBounds.length; j++) {
                    if (i === j) continue;

                    const elem1 = elementsWithBounds[i];
                    const elem2 = elementsWithBounds[j];

                    if (isElementContained(elem1.bounds, elem2.bounds)) {
                        parentChildRelations.push({ parent: elem1, child: elem2 });
                        console.log(`åŒ…å«å…³ç³»: ${elem1.name} åŒ…å« ${elem2.name}`);
                    }
                }
            }

            // è¯†åˆ«å†²çªå…ƒç´ 
            const conflictElements = new Set();
            for (let i = 0; i < elementsWithBounds.length; i++) {
                for (let j = i + 1; j < elementsWithBounds.length; j++) {
                    const elem1 = elementsWithBounds[i];
                    const elem2 = elementsWithBounds[j];

                    if (hasPartialOverlap(elem1.bounds, elem2.bounds)) {
                        conflictElements.add(elem1.id);
                        conflictElements.add(elem2.id);
                        console.log(`å†²çªæ£€æµ‹: ${elem1.name} ä¸ ${elem2.name} éƒ¨åˆ†é‡å `);
                    }
                }
            }

            // æ„å»ºåˆ†ç»„
            const validRelations = parentChildRelations.filter(relation =>
                !conflictElements.has(relation.parent.id) && !conflictElements.has(relation.child.id)
            );

            console.log('æœ‰æ•ˆå…³ç³»æ•°é‡:', validRelations.length);

            const childrenMap = new Map();
            for (const relation of validRelations) {
                if (!childrenMap.has(relation.parent.id)) {
                    childrenMap.set(relation.parent.id, []);
                }
                childrenMap.get(relation.parent.id).push(relation.child);
            }

            const groups = [];
            const rootElements = elementsWithBounds.filter(elem =>
                !validRelations.some(r => r.child.id === elem.id) && !conflictElements.has(elem.id)
            );

            console.log('æ ¹å…ƒç´ :', rootElements.map(e => e.name));

            for (const rootElement of rootElements) {
                const children = childrenMap.get(rootElement.id) || [];
                if (children.length > 0) {
                    const group = {
                        element: rootElement,
                        directChildren: children,
                        layoutDirection: detectLayoutDirection(children)
                    };
                    groups.push(group);
                    console.log(`åˆ›å»ºåˆ†ç»„: ${rootElement.name}, å­å…ƒç´ : ${children.map(c => c.name).join(', ')}`);
                }
            }

            return {
                groups,
                conflicts: elementsWithBounds.filter(e => conflictElements.has(e.id)),
                relations: validRelations
            };
        }

        // æ¸²æŸ“å‡½æ•°
        function renderTest(testId, elements) {
            const canvas = document.getElementById(`${testId}-canvas`);
            const results = document.getElementById(`${testId}-results`);
            const debug = document.getElementById(`${testId}-debug`);
            
            canvas.innerHTML = '';
            
            // æ‰§è¡Œåˆ†ç»„
            const result = performGeometricGrouping(elements);
            
            // æ¸²æŸ“å…ƒç´ 
            elements.forEach(element => {
                const div = document.createElement('div');
                div.className = `element element-${element.type}`;
                div.style.left = element.x + 'px';
                div.style.top = element.y + 'px';
                div.style.width = element.width + 'px';
                div.style.height = element.height + 'px';
                div.textContent = element.name.length > 10 ? element.name.substring(0, 10) + '...' : element.name;
                div.title = `${element.name} (${element.x}, ${element.y}, ${element.width}Ã—${element.height})`;
                canvas.appendChild(div);
            });
            
            // æ¸²æŸ“åˆ†ç»„è¾¹ç•Œ
            result.groups.forEach((group, index) => {
                const allGroupElements = [group.element, ...group.directChildren];
                const minX = Math.min(...allGroupElements.map(e => e.x));
                const minY = Math.min(...allGroupElements.map(e => e.y));
                const maxX = Math.max(...allGroupElements.map(e => e.x + e.width));
                const maxY = Math.max(...allGroupElements.map(e => e.y + e.height));

                const boundary = document.createElement('div');
                boundary.className = 'group-boundary';
                boundary.style.left = (minX - 5) + 'px';
                boundary.style.top = (minY - 5) + 'px';
                boundary.style.width = (maxX - minX + 10) + 'px';
                boundary.style.height = (maxY - minY + 10) + 'px';

                const label = document.createElement('div');
                label.className = 'group-label';
                label.textContent = `Group ${index + 1}`;
                boundary.appendChild(label);

                canvas.appendChild(boundary);
            });
            
            // æ¸²æŸ“ç»“æœ
            let resultsHtml = `<h4>åˆ†ç»„ç»“æœ (${result.groups.length} ä¸ªåˆ†ç»„)</h4>`;
            
            if (result.groups.length > 0) {
                result.groups.forEach((group, index) => {
                    const icon = group.layoutDirection === 'HORIZONTAL' ? 'â†”ï¸' : 'â†•ï¸';
                    resultsHtml += `
                        <div class="group-item">
                            <strong>${icon} Group ${index + 1}: ${group.element.name}</strong> (${group.layoutDirection})<br>
                            å­å…ƒç´ : ${group.directChildren.map(c => c.name).join(', ')}
                        </div>
                    `;
                });
            } else {
                resultsHtml += '<p>æ²¡æœ‰å‘ç°åˆ†ç»„</p>';
            }
            
            if (result.conflicts.length > 0) {
                resultsHtml += `<h4>å†²çªå…ƒç´  (${result.conflicts.length} ä¸ª)</h4>`;
                result.conflicts.forEach(conflict => {
                    resultsHtml += `<div class="conflict-item">${conflict.name} (éƒ¨åˆ†é‡å )</div>`;
                });
            }
            
            results.innerHTML = resultsHtml;
            
            // è°ƒè¯•ä¿¡æ¯
            debug.innerHTML = `
                <strong>è°ƒè¯•ä¿¡æ¯:</strong><br>
                æ€»å…ƒç´ : ${elements.length}<br>
                åŒ…å«å…³ç³»: ${result.relations.length}<br>
                åˆ†ç»„æ•°é‡: ${result.groups.length}<br>
                å†²çªå…ƒç´ : ${result.conflicts.length}<br>
                åˆ†ç»„ç‡: ${((result.groups.reduce((sum, g) => sum + g.directChildren.length + 1, 0) / elements.length) * 100).toFixed(1)}%
            `;
        }

        // åˆå§‹åŒ–æ‰€æœ‰æµ‹è¯•
        function initTests() {
            Object.keys(testCases).forEach(testId => {
                renderTest(testId, testCases[testId]);
            });
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', initTests);
    </script>
</body>
</html>
