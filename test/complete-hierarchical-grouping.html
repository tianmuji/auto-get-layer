<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåê ÂÆåÊï¥Â±ÇÊ¨°ÂåñÂàÜÁªÑÁÆóÊ≥ï</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .content {
            padding: 30px;
        }

        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .demo-panel {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #e2e8f0;
        }

        .panel-title {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .canvas {
            position: relative;
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            height: 500px;
            margin: 15px 0;
            overflow: hidden;
        }

        .element {
            position: absolute;
            border: 2px solid;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
        }

        .element:hover {
            transform: scale(1.05);
            z-index: 20;
        }

        .element-container { background-color: #4299e1; border-color: #3182ce; }
        .element-text { background-color: #ed8936; border-color: #dd6b20; }
        .element-button { background-color: #9f7aea; border-color: #805ad5; }
        .element-image { background-color: #48bb78; border-color: #38a169; }
        .element-normal { background-color: #38b2ac; border-color: #319795; }

        .group-boundary {
            position: absolute;
            border: 1px solid;
            background: transparent;
            border-radius: 4px;
            pointer-events: none;
            z-index: 5;
            opacity: 0.7;
        }

        /* ÁÆÄÂåñÁöÑÂ±ÇÊ¨°È¢úËâ≤ - Âè™ÊòæÁ§∫ÂÖ≥ÈîÆÂ±ÇÁ∫ß */
        .group-boundary.page {
            border-color: #1f2937;
            border-width: 3px;
            border-style: solid;
            background: rgba(31, 41, 55, 0.08);
            z-index: 1;
        }
        .group-boundary.section {
            border-color: #dc2626;
            border-width: 2px;
            border-style: dashed;
            background: rgba(220, 38, 38, 0.05);
            z-index: 2;
        }
        .group-boundary.article {
            border-color: #ea580c;
            border-width: 2px;
            border-style: dashed;
            background: rgba(234, 88, 12, 0.05);
            z-index: 3;
        }
        .group-boundary.header {
            border-color: #d97706;
            border-width: 1px;
            border-style: dotted;
            background: transparent;
            z-index: 4;
        }
        .group-boundary.nav {
            border-color: #ca8a04;
            border-width: 1px;
            border-style: dotted;
            background: transparent;
            z-index: 5;
        }
        .group-boundary.main {
            border-color: #65a30d;
            border-width: 2px;
            border-style: dashed;
            background: rgba(101, 163, 13, 0.05);
            z-index: 6;
        }
        .group-boundary.aside {
            border-color: #059669;
            border-width: 1px;
            border-style: dotted;
            background: transparent;
            z-index: 7;
        }
        .group-boundary.div {
            border-color: #0891b2;
            border-width: 1px;
            border-style: dotted;
            background: transparent;
            z-index: 8;
        }
        .group-boundary.component {
            border-color: #0284c7;
            border-width: 1px;
            border-style: dotted;
            background: transparent;
            z-index: 9;
        }

        .group-label {
            position: absolute;
            top: -10px;
            left: 4px;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.65em;
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            opacity: 0.9;
        }

        /* Âè™‰∏∫ÈáçË¶ÅÂ±ÇÁ∫ßÊòæÁ§∫Ê†áÁ≠æ */
        .group-label.page { background: #1f2937; }
        .group-label.section { background: #dc2626; }
        .group-label.article { background: #ea580c; }
        .group-label.main { background: #65a30d; }

        /* ÂÖ∂‰ªñÂ±ÇÁ∫ßÁöÑÊ†áÁ≠æÊõ¥Â∞èÊõ¥ÈÄèÊòé */
        .group-label.header { background: #d97706; opacity: 0.7; font-size: 0.6em; }
        .group-label.nav { background: #ca8a04; opacity: 0.7; font-size: 0.6em; }
        .group-label.aside { background: #059669; opacity: 0.7; font-size: 0.6em; }
        .group-label.div { background: #0891b2; opacity: 0.6; font-size: 0.55em; }
        .group-label.component { background: #0284c7; opacity: 0.6; font-size: 0.55em; }

        .controls {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e2e8f0;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 10px 0;
        }

        .control-label {
            font-weight: 600;
            min-width: 120px;
        }

        .slider {
            flex: 1;
            max-width: 200px;
        }

        .value-display {
            min-width: 60px;
            font-weight: 600;
            color: #3b82f6;
        }

        .test-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .test-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: #3b82f6;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .test-btn:hover {
            background: #2563eb;
        }

        .test-btn.active {
            background: #1d4ed8;
        }

        .results-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #e2e8f0;
            margin-top: 20px;
        }

        .group-tree {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            line-height: 1.6;
            background: #f8fafc;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            max-height: 500px;
            overflow-y: auto;
        }

        /* ‰∫§‰∫íÂºèÊ†ëËäÇÁÇπÊ†∑Âºè */
        .tree-node {
            margin: 2px 0;
            user-select: none;
        }

        .node-content {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .node-content:hover {
            background: #f3f4f6;
            transform: translateX(2px);
        }

        .node-toggle {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            color: #6b7280;
            font-size: 10px;
            font-weight: 600;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .node-toggle:hover {
            background: #d1d5db;
        }

        .node-toggle.expanded {
            background: #3b82f6;
            color: white;
        }

        .node-toggle.leaf {
            background: transparent;
            cursor: default;
            color: #9ca3af;
        }

        .node-icon {
            margin-right: 6px;
            font-size: 14px;
        }

        .node-label {
            font-weight: 500;
            color: #1f2937;
            flex: 1;
            font-size: 13px;
        }

        .node-count {
            background: #e5e7eb;
            color: #6b7280;
            padding: 1px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 6px;
        }

        .node-children {
            margin-left: 24px;
            border-left: 1px solid #e5e7eb;
            padding-left: 8px;
            display: none;
            animation: slideDown 0.2s ease;
        }

        .node-children.expanded {
            display: block;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ‰∏çÂêåÂ±ÇÁ∫ßÁöÑÊ†∑Âºè */
        .node-content.page { background: #f9fafb; border-left: 3px solid #1f2937; font-weight: 700; }
        .node-content.section { background: #fef2f2; border-left: 3px solid #dc2626; font-weight: 600; }
        .node-content.article { background: #fff7ed; border-left: 3px solid #ea580c; font-weight: 600; }
        .node-content.header { background: #fffbeb; border-left: 3px solid #d97706; font-weight: 600; }
        .node-content.nav { background: #fefce8; border-left: 3px solid #ca8a04; }
        .node-content.main { background: #f7fee7; border-left: 3px solid #65a30d; }
        .node-content.aside { background: #ecfdf5; border-left: 3px solid #059669; }
        .node-content.div { background: #f0f9ff; border-left: 3px solid #0891b2; }
        .node-content.component { background: #eff6ff; border-left: 3px solid #0284c7; }

        /* ÂéüÂßãÁªìÊûÑÊ†∑Âºè */
        .node-content.flat { background: #fafafa; border-left: 3px solid #9ca3af; color: #6b7280; }
        .node-content.element { background: #f8fafc; border-left: 2px solid #64748b; font-size: 0.85em; }

        /* Ê†ëÂΩ¢ÂØπÊØîÁΩëÊ†º */
        .tree-comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .tree-panel {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e2e8f0;
        }

        .tree-panel-title {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 8px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }

        /* ÊéßÂà∂ÊåâÈíÆÊ†∑Âºè */
        .control-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #3b82f6;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .control-btn.secondary {
            background: #6b7280;
        }

        .control-btn.secondary:hover {
            background: #4b5563;
        }



        .stats-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #f8fafc;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #3b82f6;
        }

        .stat-label {
            color: #6b7280;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .legend {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid #e2e8f0;
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #1f2937;
        }

        .legend-items {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 2px solid;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üåê ÂÆåÊï¥Â±ÇÊ¨°ÂåñÂàÜÁªÑÁÆóÊ≥ï</h1>
            <p>ÂèÇËÄÉWebÊ†áÂáÜÔºåÁ°Æ‰øùÊâÄÊúâÂÖÉÁ¥†ÈÉΩË¢´ÂàÜÁªÑÔºå‰ªéÈ°µÈù¢Á∫ßÂà∞ÁªÑ‰ª∂Á∫ßÁöÑÂÆåÊï¥Â±ÇÊ¨°</p>
        </div>

        <div class="content">
            <!-- ÊéßÂà∂Èù¢Êùø -->
            <div class="controls">
                <h3 style="margin-bottom: 15px;">üß™ ÊµãËØïÁî®‰æãÈÄâÊã©</h3>

                <div class="test-buttons">
                    <button class="test-btn active" data-case="simple_card">üÉè ÁÆÄÂçïÂç°Áâá</button>
                    <button class="test-btn" data-case="basic_layout">üìÑ Âü∫Á°ÄÂ∏ÉÂ±Ä</button>
                    <button class="test-btn" data-case="form_example">üìù Ë°®ÂçïÁ§∫‰æã</button>
                    <button class="test-btn" data-case="navigation_bar">üß≠ ÂØºËà™Ê†è</button>
                    <button class="test-btn" data-case="dashboard_simple">üìä ÁÆÄÂçï‰ª™Ë°®Êùø</button>
                </div>

                <!-- Ê†°È™åÊåâÈíÆ -->
                <div style="margin-top: 15px;">
                    <button onclick="validateAllCases()" style="background: #10b981; color: white; padding: 8px 16px; border: none; border-radius: 4px; margin-right: 10px;">‚úÖ Ê†°È™åÊâÄÊúâÁî®‰æã</button>
                    <button onclick="testFunction()" style="background: #ef4444; color: white; padding: 8px 16px; border: none; border-radius: 4px; margin-right: 10px;">üîß Ê†°È™åÂΩìÂâçÁî®‰æã</button>
                        <button onclick="copyErrorsToClipboard()" style="background: #8b5cf6; color: white; padding: 8px 16px; border: none; border-radius: 4px;">üìã Â§çÂà∂ÈîôËØØ‰ø°ÊÅØ</button>
                </div>
            </div>

                    <!-- ÈîôËØØ‰ø°ÊÅØÊòæÁ§∫Âå∫Âüü -->
                    <div id="error-output" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto; display: none;">
                    </div>





            <!-- ÁªüËÆ°‰ø°ÊÅØ -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="total-elements">0</div>
                    <div class="stat-label">ÊÄªÂÖÉÁ¥†Êï∞</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="total-groups">0</div>
                    <div class="stat-label">ÂàÜÁªÑÊÄªÊï∞</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="coverage-rate">0%</div>
                    <div class="stat-label">Ë¶ÜÁõñÁéá</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="max-depth">0</div>
                    <div class="stat-label">ÊúÄÂ§ßÊ∑±Â∫¶</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avg-group-size">0</div>
                    <div class="stat-label">Âπ≥ÂùáÁªÑÂ§ßÂ∞è</div>
                </div>
            </div>

            <!-- ÊºîÁ§∫Âå∫Âüü -->
            <div class="demo-grid">
                <div class="demo-panel">
                    <div class="panel-title">üì• ÂéüÂßãÂÖÉÁ¥†Â∏ÉÂ±Ä</div>
                    <div class="canvas" id="original-canvas"></div>
                </div>
                
                <div class="demo-panel">
                    <div class="panel-title">üåê ÂÆåÊï¥Â±ÇÊ¨°ÂåñÂàÜÁªÑ</div>
                    <div class="canvas" id="grouped-canvas"></div>
                </div>
            </div>

            <!-- Ê†ëÂΩ¢ÁªìÊûÑÊéßÂà∂ -->
            <div class="results-panel">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3>üå≥ ‰∫§‰∫íÂºèÊ†ëÂΩ¢ÁªìÊûÑÂØπÊØî</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="control-btn" id="expand-all-btn">üìÇ ÂÖ®ÈÉ®Â±ïÂºÄ</button>
                        <button class="control-btn" id="collapse-all-btn">üìÅ ÂÖ®ÈÉ®Êî∂Ëµ∑</button>
                        <button class="control-btn secondary" id="refresh-btn">üîÑ ÈáçÊñ∞ÂàÜÊûê</button>
                    </div>
                </div>

                <!-- Ê†ëÂΩ¢ÁªìÊûÑÂØπÊØî -->
                <div class="tree-comparison-grid">
                    <div class="tree-panel">
                        <div class="tree-panel-title">üî¥ ÂàÜÁªÑÂâçÁªìÊûÑ (ÊâÅÂπ≥)</div>
                        <div class="group-tree" id="original-tree"></div>
                    </div>

                    <div class="tree-panel">
                        <div class="tree-panel-title">üå≥ ÂàÜÁªÑÂêéÁªìÊûÑ (Â±ÇÊ¨°Âåñ)</div>
                        <div class="group-tree" id="grouped-tree"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ÊµãËØïÊï∞ÊçÆÈõÜ - ‰ªéÁÆÄÂçïÂà∞Â§çÊùÇÁöÑÊ∏êËøõÂºè‰æãÂ≠ê
        const testCases = {
            // 1. üÉè ÁÆÄÂçïÂç°Áâá - ÊúÄÂü∫Á°ÄÁöÑÂàÜÁªÑÁ§∫‰æã
            simple_card: [
                { id: 'card_title', name: 'Áî®Êà∑‰ø°ÊÅØ', x: 20, y: 20, width: 200, height: 30, type: 'text' },
                { id: 'avatar', name: 'Â§¥ÂÉè', x: 30, y: 60, width: 60, height: 60, type: 'image' },
                { id: 'username', name: 'Âº†‰∏â', x: 100, y: 70, width: 100, height: 20, type: 'text' },
                { id: 'email', name: 'zhang@email.com', x: 100, y: 95, width: 120, height: 15, type: 'text' },
                { id: 'edit_btn', name: 'ÁºñËæë', x: 160, y: 130, width: 60, height: 25, type: 'button' }
            ],

            // 2. üìÑ Âü∫Á°ÄÂ∏ÉÂ±Ä - ÁÆÄÂçïÁöÑÈ°µÈù¢ÁªìÊûÑ
            basic_layout: [
                // Â§¥ÈÉ®Âå∫Âüü
                { id: 'logo', name: 'Logo', x: 20, y: 10, width: 80, height: 30, type: 'image' },
                { id: 'nav_home', name: 'È¶ñÈ°µ', x: 120, y: 15, width: 50, height: 20, type: 'button' },
                { id: 'nav_about', name: 'ÂÖ≥‰∫é', x: 180, y: 15, width: 50, height: 20, type: 'button' },

                // ‰∏ªË¶ÅÂÜÖÂÆπ
                { id: 'main_title', name: 'Ê¨¢Ëøé‰ΩøÁî®', x: 20, y: 60, width: 300, height: 40, type: 'text' },
                { id: 'content_text', name: 'ËøôÊòØ‰∏ªË¶ÅÂÜÖÂÆπÂå∫Âüü...', x: 20, y: 110, width: 280, height: 60, type: 'text' },
                { id: 'cta_button', name: 'ÂºÄÂßã‰ΩøÁî®', x: 20, y: 180, width: 100, height: 35, type: 'button' },

                // ‰æßËæπÊ†è
                { id: 'sidebar_title', name: 'Áõ∏ÂÖ≥ÈìæÊé•', x: 340, y: 60, width: 120, height: 25, type: 'text' },
                { id: 'link1', name: 'Â∏ÆÂä©ÊñáÊ°£', x: 350, y: 95, width: 80, height: 20, type: 'button' },
                { id: 'link2', name: 'ËÅîÁ≥ªÊàë‰ª¨', x: 350, y: 125, width: 80, height: 20, type: 'button' }
            ],

            // 3. üìù Ë°®ÂçïÁ§∫‰æã - Â±ïÁ§∫Ë°®ÂçïÂÖÉÁ¥†ÁöÑÂàÜÁªÑ
            form_example: [
                { id: 'form_title', name: 'Áî®Êà∑Ê≥®ÂÜå', x: 50, y: 20, width: 200, height: 30, type: 'text' },

                // Âü∫Êú¨‰ø°ÊÅØÁªÑ
                { id: 'basic_label', name: 'Âü∫Êú¨‰ø°ÊÅØ', x: 50, y: 70, width: 100, height: 20, type: 'text' },
                { id: 'name_label', name: 'ÂßìÂêç:', x: 60, y: 100, width: 50, height: 15, type: 'text' },
                { id: 'name_input', name: 'ÂßìÂêçËæìÂÖ•Ê°Ü', x: 120, y: 95, width: 150, height: 25, type: 'text' },
                { id: 'email_label', name: 'ÈÇÆÁÆ±:', x: 60, y: 130, width: 50, height: 15, type: 'text' },
                { id: 'email_input', name: 'ÈÇÆÁÆ±ËæìÂÖ•Ê°Ü', x: 120, y: 125, width: 150, height: 25, type: 'text' },

                // ÂØÜÁ†Å‰ø°ÊÅØÁªÑ
                { id: 'pwd_label', name: 'ÂØÜÁ†ÅËÆæÁΩÆ', x: 50, y: 170, width: 100, height: 20, type: 'text' },
                { id: 'password_label', name: 'ÂØÜÁ†Å:', x: 60, y: 200, width: 50, height: 15, type: 'text' },
                { id: 'password_input', name: 'ÂØÜÁ†ÅËæìÂÖ•Ê°Ü', x: 120, y: 195, width: 150, height: 25, type: 'text' },
                { id: 'confirm_label', name: 'Á°ÆËÆ§:', x: 60, y: 230, width: 50, height: 15, type: 'text' },
                { id: 'confirm_input', name: 'Á°ÆËÆ§ÂØÜÁ†ÅÊ°Ü', x: 120, y: 225, width: 150, height: 25, type: 'text' },

                // Êìç‰ΩúÊåâÈíÆÁªÑ
                { id: 'submit_btn', name: 'Ê≥®ÂÜå', x: 120, y: 270, width: 70, height: 30, type: 'button' },
                { id: 'cancel_btn', name: 'ÂèñÊ∂à', x: 200, y: 270, width: 70, height: 30, type: 'button' }
            ],

            // 4. üß≠ ÂØºËà™Ê†è - Ê∞¥Âπ≥Â∏ÉÂ±ÄÁöÑÂàÜÁªÑÁ§∫‰æã
            navigation_bar: [
                // Â∑¶‰æßÂìÅÁâåÂå∫
                { id: 'brand_logo', name: 'Logo', x: 20, y: 15, width: 40, height: 30, type: 'image' },
                { id: 'brand_name', name: 'ÊàëÁöÑÁΩëÁ´ô', x: 70, y: 20, width: 80, height: 20, type: 'text' },

                // ‰∏≠Èó¥ÂØºËà™ËèúÂçï
                { id: 'nav_home', name: 'È¶ñÈ°µ', x: 200, y: 20, width: 50, height: 20, type: 'button' },
                { id: 'nav_products', name: '‰∫ßÂìÅ', x: 260, y: 20, width: 50, height: 20, type: 'button' },
                { id: 'nav_services', name: 'ÊúçÂä°', x: 320, y: 20, width: 50, height: 20, type: 'button' },
                { id: 'nav_about', name: 'ÂÖ≥‰∫é', x: 380, y: 20, width: 50, height: 20, type: 'button' },

                // Âè≥‰æßÁî®Êà∑Âå∫
                { id: 'search_box', name: 'ÊêúÁ¥¢', x: 480, y: 18, width: 100, height: 24, type: 'text' },
                { id: 'login_btn', name: 'ÁôªÂΩï', x: 590, y: 18, width: 50, height: 24, type: 'button' },
                { id: 'signup_btn', name: 'Ê≥®ÂÜå', x: 650, y: 18, width: 50, height: 24, type: 'button' }
            ],

            // 5. üìä ÁÆÄÂçï‰ª™Ë°®Êùø - Â§öÂå∫ÂüüÂ∏ÉÂ±ÄÁ§∫‰æã
            dashboard_simple: [
                // È°∂ÈÉ®Ê†áÈ¢òÊ†è
                { id: 'dash_title', name: 'Êï∞ÊçÆ‰ª™Ë°®Êùø', x: 20, y: 20, width: 200, height: 30, type: 'text' },
                { id: 'refresh_btn', name: 'Âà∑Êñ∞', x: 500, y: 25, width: 60, height: 20, type: 'button' },

                // ÁªüËÆ°Âç°ÁâáÂå∫Âüü
                { id: 'card1_title', name: 'ÊÄªÁî®Êà∑', x: 20, y: 70, width: 120, height: 20, type: 'text' },
                { id: 'card1_value', name: '1,234', x: 20, y: 95, width: 120, height: 35, type: 'text' },
                { id: 'card1_trend', name: '+12%', x: 20, y: 135, width: 120, height: 15, type: 'text' },

                { id: 'card2_title', name: 'ÈîÄÂîÆÈ¢ù', x: 160, y: 70, width: 120, height: 20, type: 'text' },
                { id: 'card2_value', name: '¬•56,789', x: 160, y: 95, width: 120, height: 35, type: 'text' },
                { id: 'card2_trend', name: '+8%', x: 160, y: 135, width: 120, height: 15, type: 'text' },

                { id: 'card3_title', name: 'ËÆ¢ÂçïÊï∞', x: 300, y: 70, width: 120, height: 20, type: 'text' },
                { id: 'card3_value', name: '456', x: 300, y: 95, width: 120, height: 35, type: 'text' },
                { id: 'card3_trend', name: '+15%', x: 300, y: 135, width: 120, height: 15, type: 'text' },

                // ÂõæË°®Âå∫Âüü
                { id: 'chart_title', name: 'ÈîÄÂîÆË∂ãÂäø', x: 20, y: 180, width: 400, height: 25, type: 'text' },
                { id: 'chart_area', name: 'ÂõæË°®ÂÜÖÂÆπ', x: 20, y: 210, width: 400, height: 150, type: 'container' },

                // ÊúÄËøëÊ¥ªÂä®
                { id: 'activity_title', name: 'ÊúÄËøëÊ¥ªÂä®', x: 450, y: 70, width: 150, height: 25, type: 'text' },
                { id: 'activity1', name: 'Êñ∞Áî®Êà∑Ê≥®ÂÜå', x: 450, y: 105, width: 150, height: 20, type: 'text' },
                { id: 'activity2', name: 'ËÆ¢ÂçïÂÆåÊàê', x: 450, y: 130, width: 150, height: 20, type: 'text' },
                { id: 'activity3', name: 'ÊîØ‰ªòÊàêÂäü', x: 450, y: 155, width: 150, height: 20, type: 'text' }
            ]
        };

        // ÂÖ®Â±ÄÂèòÈáè
        let currentCase = 'simple_card';
        let currentGroups = [];

        // WebÊ†áÂáÜÂ±ÇÊ¨°ÂÆö‰πâ
        const WEB_HIERARCHY = [
            { name: 'page', label: 'Page', minSize: 0, priority: 1 },
            { name: 'section', label: 'Section', minSize: 100, priority: 2 },
            { name: 'article', label: 'Article', minSize: 80, priority: 3 },
            { name: 'header', label: 'Header', minSize: 60, priority: 4 },
            { name: 'nav', label: 'Nav', minSize: 40, priority: 5 },
            { name: 'main', label: 'Main', minSize: 60, priority: 6 },
            { name: 'aside', label: 'Aside', minSize: 40, priority: 7 },
            { name: 'div', label: 'Div', minSize: 30, priority: 8 },
            { name: 'component', label: 'Component', minSize: 20, priority: 9 }
        ];

        // ÂÆåÊï¥Â±ÇÊ¨°ÂåñÂàÜÁªÑÁÆóÊ≥ï
        function performCompleteHierarchicalGrouping(elements) {
            console.log('üåê ÂºÄÂßãÂÆåÊï¥Â±ÇÊ¨°ÂåñÂàÜÁªÑÂàÜÊûê...');

            // 1. ÂàõÂª∫È°µÈù¢Á∫ßÂàÜÁªÑÔºàÂåÖÂê´ÊâÄÊúâÂÖÉÁ¥†Ôºâ
            const pageGroup = createPageGroup(elements);

            // 2. ÈÄíÂΩíÂàõÂª∫Â≠êÂàÜÁªÑ
            const completeHierarchy = buildCompleteHierarchy(pageGroup);

            console.log('üéØ ÂÆåÊï¥ÂàÜÁªÑÂÆåÊàê');
            return completeHierarchy;
        }

        // ÂàõÂª∫È°µÈù¢Á∫ßÂàÜÁªÑ
        function createPageGroup(elements) {
            const bounds = calculateBounds(elements);
            return {
                id: 'page_root',
                name: generateMeaningfulGroupName(elements, 'Page'),
                type: 'page',
                level: 1,
                elements: elements,
                bounds: bounds,
                children: []
            };
        }

        // ÊûÑÂª∫ÂÆåÊï¥Â±ÇÊ¨°ÁªìÊûÑ
        function buildCompleteHierarchy(parentGroup) {
            const { elements, level } = parentGroup;

            if (elements.length <= 1 || level >= WEB_HIERARCHY.length) {
                return parentGroup;
            }

            // Ê†πÊçÆÂΩìÂâçÂ±ÇÁ∫ßÈÄâÊã©ÂàÜÁªÑÁ≠ñÁï•
            const currentHierarchy = WEB_HIERARCHY[level - 1];
            const nextHierarchy = WEB_HIERARCHY[level];

            // ÊâßË°åÊó†ÈòàÂÄºÂàÜÁªÑ
            const subGroups = createSubGroups(elements, nextHierarchy, level + 1);

            // ÈÄíÂΩíÂ§ÑÁêÜÊØè‰∏™Â≠êÂàÜÁªÑ
            parentGroup.children = subGroups.map(group => buildCompleteHierarchy(group));

            // üîß ‰ºòÂåñÔºöÂêàÂπ∂Âè™Êúâ‰∏Ä‰∏™Â≠êËäÇÁÇπÁöÑÂàÜÁªÑÔºåÂáèÂ∞ëÊ†ëÁöÑÊ∑±Â∫¶
            parentGroup = optimizeSingleChildGroups(parentGroup);

            return parentGroup;
        }

        // üîß ‰ºòÂåñÂçïÂ≠êËäÇÁÇπÂàÜÁªÑÔºöÂêàÂπ∂Âè™Êúâ‰∏Ä‰∏™Â≠êËäÇÁÇπÁöÑÂàÜÁªÑÔºåÂáèÂ∞ë‰∏çÂøÖË¶ÅÁöÑÊ†ëÊ∑±Â∫¶
        function optimizeSingleChildGroups(group) {
            if (!group.children || group.children.length === 0) {
                return group;
            }

            // ÈÄíÂΩí‰ºòÂåñÊâÄÊúâÂ≠êÂàÜÁªÑ
            group.children = group.children.map(child => optimizeSingleChildGroups(child));

            // Â¶ÇÊûúÂΩìÂâçÂàÜÁªÑÂè™Êúâ‰∏Ä‰∏™Â≠êÂàÜÁªÑÔºå‰∏îÂ≠êÂàÜÁªÑ‰∏çÊòØÂè∂Â≠êËäÇÁÇπÔºåÂàôËÄÉËôëÂêàÂπ∂
            if (group.children.length === 1) {
                const onlyChild = group.children[0];

                // ÂêàÂπ∂Êù°‰ª∂Ôºö
                // 1. Â≠êÂàÜÁªÑ‰πüÊúâÂ≠êËäÇÁÇπÔºà‰∏çÊòØÂè∂Â≠êËäÇÁÇπÔºâ
                // 2. ÊàñËÄÖÂ≠êÂàÜÁªÑÂè™ÂåÖÂê´‰∏Ä‰∏™ÂÖÉÁ¥†ÔºàËøáÂ∫¶ÂàÜÁªÑÔºâ
                if (onlyChild.children.length > 0 || onlyChild.elements.length === 1) {
                    console.log(`üîß ÂêàÂπ∂ÂçïÂ≠êËäÇÁÇπÂàÜÁªÑ: ${group.name} -> ${onlyChild.name}`);

                    // ‰øùÁïôÁà∂ÂàÜÁªÑÁöÑÂü∫Êú¨‰ø°ÊÅØÔºå‰ΩÜ‰ΩøÁî®Â≠êÂàÜÁªÑÁöÑÂÜÖÂÆπ
                    return {
                        id: group.id,
                        name: group.name, // ‰øùÁïôÁà∂ÂàÜÁªÑÁöÑÂêçÁß∞
                        type: group.type, // ‰øùÁïôÁà∂ÂàÜÁªÑÁöÑÁ±ªÂûã
                        level: group.level,
                        elements: onlyChild.elements,
                        bounds: onlyChild.bounds,
                        children: onlyChild.children,
                        direction: onlyChild.direction
                    };
                }
            }

            return group;
        }



        // üéØ ÁîüÊàêÂü∫‰∫éÂéüÂßãËäÇÁÇπÂêçÁß∞ÁöÑÂàÜÁªÑÂêçÁß∞
        function generateMeaningfulGroupName(elements, fallbackName) {
            if (!elements || elements.length === 0) {
                return fallbackName;
            }

            // Â¶ÇÊûúÂè™Êúâ‰∏Ä‰∏™ÂÖÉÁ¥†ÔºåÁõ¥Êé•‰ΩøÁî®ÂÖÉÁ¥†ÂêçÁß∞
            if (elements.length === 1) {
                return elements[0].name;
            }

            // Â¶ÇÊûúÊúâÂ§ö‰∏™ÂÖÉÁ¥†ÔºåÂàóÂá∫ÊâÄÊúâÂÖÉÁ¥†ÂêçÁß∞
            const elementNames = elements.map(e => e.name);

            // Â¶ÇÊûúÂÖÉÁ¥†‰∏çÂ§öÔºåÁõ¥Êé•ÂàóÂá∫ÊâÄÊúâÂêçÁß∞
            if (elements.length <= 3) {
                return elementNames.join(' + ');
            }

            // Â¶ÇÊûúÂÖÉÁ¥†ËæÉÂ§öÔºåÊòæÁ§∫ÂâçÂá†‰∏™Âä†ÁúÅÁï•Âè∑
            return `${elementNames.slice(0, 2).join(' + ')} + ${elements.length - 2} È°π`;
        }

        // ÂàõÂª∫Â≠êÂàÜÁªÑ
        function createSubGroups(elements, hierarchy, level) {
            console.log(`\nüîß createSubGroups Ë¢´Ë∞ÉÁî®ÔºåÂ±ÇÁ∫ß: ${level}, ÂÖÉÁ¥†Êï∞Èáè: ${elements.length}`);
            console.log(`ËæìÂÖ•ÂÖÉÁ¥†: ${elements.map(e => e.name).join(', ')}`);

            if (elements.length <= 1) {
                console.log(`ÂÖÉÁ¥†Êï∞Èáè <= 1ÔºåËøîÂõûÁ©∫Êï∞ÁªÑ`);
                return [];
            }

            // 1. ‰ΩøÁî®Êó†ÈòàÂÄºÁöÑÁ©∫Èó¥ËÅöÁ±ª
            const clusters = performSpatialClustering(elements);
            console.log(`ËÅöÁ±ªÁªìÊûú: ${clusters.length} ‰∏™ËÅöÁ±ª`);
            clusters.forEach((cluster, i) => {
                console.log(`  ËÅöÁ±ª ${i + 1}: [${cluster.map(e => e.name).join(', ')}]`);
            });

            // 2. ‰∏∫ÊØè‰∏™ËÅöÁ±ªÂàõÂª∫ÂàÜÁªÑ
            const groups = [];
            clusters.forEach((cluster, index) => {
                if (cluster.length >= 1) { // Á°Æ‰øùÊâÄÊúâÂÖÉÁ¥†ÈÉΩË¢´ÂàÜÁªÑ
                    const bounds = calculateBounds(cluster);
                    const groupInfo = determineGroupType(cluster, hierarchy);

                    const group = {
                        id: `${hierarchy.name}_${level}_${index}`,
                        name: generateMeaningfulGroupName(cluster, `${hierarchy.label} ${index + 1}`),
                        type: groupInfo.type || hierarchy.name,
                        level: level,
                        elements: cluster,
                        bounds: bounds,
                        children: [],
                        direction: groupInfo.direction || 'HORIZONTAL' // ÈªòËÆ§Ê®™Âêë
                    };

                    groups.push(group);
                }
            });

            // 3. Â¶ÇÊûúÊ≤°ÊúâÂΩ¢ÊàêÊúâÊïàÂàÜÁªÑÔºåÂàõÂª∫Âçï‰∏™ÂåÖÂê´ÊâÄÊúâÂÖÉÁ¥†ÁöÑÂàÜÁªÑ
            if (groups.length === 0 && elements.length > 0) {
                const bounds = calculateBounds(elements);
                const groupInfo = determineGroupType(elements, hierarchy);
                groups.push({
                    id: `${hierarchy.name}_${level}_0`,
                    name: generateMeaningfulGroupName(elements, `${hierarchy.label} 1`),
                    type: groupInfo.type || hierarchy.name,
                    level: level,
                    elements: elements,
                    bounds: bounds,
                    children: [],
                    direction: groupInfo.direction || 'HORIZONTAL' // ÈªòËÆ§Ê®™Âêë
                });
            }

            return groups;
        }

        // üéØ FlexÂ∏ÉÂ±ÄÂØºÂêëÁöÑÁ©∫Èó¥ËÅöÁ±ªÁÆóÊ≥ï - ‰ºòÂÖàÊ®™ÂêëÂàÜÁªÑ
        function performSpatialClustering(elements) {
            if (elements.length <= 1) return [elements];

            console.log(`üîÑ ÂºÄÂßãÊó†ÈòàÂÄºÁ©∫Èó¥ÂàÜÁªÑ`);

            // ‰ΩøÁî®Êó†ÈòàÂÄºÁöÑÁõ∏ÂØπÂÖ≥Á≥ªÂàÜÁªÑ
            return performFlexLayoutGrouping(elements);
        }

        // üéØ Âü∫‰∫éÁõ∏ÂØπÂÖ≥Á≥ªÁöÑÊó†ÈòàÂÄºÂàÜÁªÑÁÆóÊ≥ï
        function performFlexLayoutGrouping(elements) {
            console.log(`üöÄ ÂºÄÂßãÊó†ÈòàÂÄºÂàÜÁªÑÔºåÂÖÉÁ¥†Êï∞Èáè: ${elements.length}`);
            console.log(`üí° ‰∏çÂÜç‰æùËµñÂõ∫ÂÆöÈòàÂÄºÔºå‰ΩøÁî®Áõ∏ÂØπÁ©∫Èó¥ÂÖ≥Á≥ªËøõË°åÂàÜÁªÑ`);

            if (elements.length <= 1) {
                return [elements];
            }

            // üéØ ‰ΩøÁî®Áõ∏ÂØπÂÖ≥Á≥ªËøõË°åÂàÜÁªÑ
            return performRelativeGrouping(elements);
        }

        // üéØ ÈáçÊñ∞ËÆæËÆ°ÁöÑ‰∏•Ê†ºÂàÜÁªÑÁÆóÊ≥ï
        function performRelativeGrouping(elements) {
            console.log(`\nüìù === ‰∏•Ê†ºÈó¥ÈöôÂàÜÁªÑÁÆóÊ≥ï ===`);

            // ‰ΩøÁî®Âü∫‰∫éÈó¥ÈöôÁöÑ‰∏•Ê†ºÂàÜÁªÑ
            const groups = performColumnTruncationGrouping(elements);

            console.log(`\n‚úÖ ÂàÜÁªÑÂÆåÊàêÔºåÁîüÊàê ${groups.length} ‰∏™ÂàÜÁªÑ`);
            return groups;
        }

        function performColumnTruncationGrouping(elements) {
            console.log(`\nüîç ÂºÄÂßãÂ∞ÑÁ∫øÂàÜÁªÑÁÆóÊ≥ï`);
            console.log(`ËæìÂÖ•ÂÖÉÁ¥†: ${elements.map(e => e.name).join(', ')}`);

            const rayGraph = buildRayRelationGraph(elements);
            const groups = dynamicProgrammingGrouping(elements, rayGraph);

            console.log(`\nüìä ÊúÄÁªàÂàÜÁªÑÁªìÊûú:`);
            groups.forEach((group, index) => {
                console.log(`  ÁªÑ ${index + 1}: [${group.map(e => e.name).join(', ')}]`);
            });

            return groups;
        }

        function buildRayRelationGraph(elements) {
            const graph = {
                horizontal: new Map(),
                vertical: new Map(),
                elements: new Map()
            };

            elements.forEach(element => {
                graph.horizontal.set(element.id, new Set());
                graph.vertical.set(element.id, new Set());
                graph.elements.set(element.id, element);
            });

            for (let i = 0; i < elements.length; i++) {
                for (let j = i + 1; j < elements.length; j++) {
                    const elem1 = elements[i];
                    const elem2 = elements[j];

                    if (canConnectHorizontally(elem1, elem2, elements)) {
                        graph.horizontal.get(elem1.id).add(elem2.id);
                        graph.horizontal.get(elem2.id).add(elem1.id);
                    }

                    if (canConnectVertically(elem1, elem2, elements)) {
                        graph.vertical.get(elem1.id).add(elem2.id);
                        graph.vertical.get(elem2.id).add(elem1.id);
                    }
                }
            }

            return graph;
        }

        function canConnectHorizontally(elem1, elem2, allElements) {
            const yOverlap = !(elem1.y + elem1.height <= elem2.y || elem2.y + elem2.height <= elem1.y);
            return yOverlap && !isHorizontalRayBlocked(elem1, elem2, allElements);
        }

        function canConnectVertically(elem1, elem2, allElements) {
            const xOverlap = !(elem1.x + elem1.width <= elem2.x || elem2.x + elem2.width <= elem1.x);
            return xOverlap && !isVerticalRayBlocked(elem1, elem2, allElements);
        }

        function dynamicProgrammingGrouping(elements, rayGraph) {
            const validGroupings = findAllValidGroupings(elements, rayGraph);

            if (validGroupings.length === 0) {
                console.log(`‚ö†Ô∏è Ê≤°ÊúâÊâæÂà∞ÊúâÊïàÂàÜÁªÑÊñπÊ°àÔºå‰ΩøÁî®ÂçïÂÖÉÁ¥†ÂàÜÁªÑ`);
                return elements.map(e => [e]);
            }

            console.log(`\nüéØ ËØÑ‰º∞ ${validGroupings.length} ÁßçÂàÜÁªÑÊñπÊ°à:`);

            let bestSolution = null;
            let bestScore = Infinity;

            validGroupings.forEach((grouping, index) => {
                const score = calculateGroupingScore(grouping);
                console.log(`  ÊñπÊ°à ${index + 1}: ${grouping.length} ÁªÑ, ÂæóÂàÜ: ${score.total}`);
                grouping.forEach((group, groupIndex) => {
                    console.log(`    ÁªÑ ${groupIndex + 1}: [${group.map(e => e.name).join(', ')}]`);
                });

                if (score.total < bestScore) {
                    bestScore = score.total;
                    bestSolution = grouping;
                    console.log(`    ‚úÖ ÂΩìÂâçÊúÄ‰Ω≥ÊñπÊ°à!`);
                }
            });

            console.log(`\nüèÜ ÈÄâÊã©ÊñπÊ°àÔºåÂæóÂàÜ: ${bestScore}`);
            return bestSolution;
        }

        function findAllValidGroupings(elements, rayGraph) {
            const connectedComponents = findAllConnectedComponents(elements, rayGraph);
            const allGroupings = [];

            if (connectedComponents.length === 1 && connectedComponents[0].length > 1) {
                const component = connectedComponents[0];
                const subGroupings = findValidSubGroupings(component, rayGraph);
                allGroupings.push(...subGroupings);
            } else {
                const componentGroupings = connectedComponents.map(component => {
                    if (component.length === 1) {
                        return [[component]];
                    } else {
                        return findValidSubGroupings(component, rayGraph);
                    }
                });

                allGroupings.push(...combineComponentGroupings(componentGroupings));
            }

            return allGroupings;
        }

        function findAllConnectedComponents(elements, rayGraph) {
            const basicComponents = findBasicConnectedComponents(elements, rayGraph);
            console.log(`\nüì¶ Âü∫Á°ÄËøûÈÄöÂàÜÈáè:`);
            basicComponents.forEach((component, index) => {
                console.log(`  ÂàÜÈáè ${index + 1}: [${component.map(e => e.name).join(', ')}]`);
            });

            const continuousComponents = mergeContinuousComponents(basicComponents, rayGraph);
            if (continuousComponents.length !== basicComponents.length) {
                console.log(`\nüîó ËøûÁª≠ÊÄßÂêàÂπ∂Âêé:`);
                continuousComponents.forEach((component, index) => {
                    console.log(`  ÂàÜÈáè ${index + 1}: [${component.map(e => e.name).join(', ')}]`);
                });
            }

            return continuousComponents;
        }

        function findBasicConnectedComponents(elements, rayGraph) {
            const components = [];
            const visited = new Set();

            for (const element of elements) {
                if (visited.has(element.id)) continue;

                const component = [];
                const queue = [element];
                const componentVisited = new Set([element.id]);

                while (queue.length > 0) {
                    const current = queue.shift();
                    component.push(current);
                    visited.add(current.id);

                    const allConnections = new Set([
                        ...(rayGraph.horizontal.get(current.id) || []),
                        ...(rayGraph.vertical.get(current.id) || [])
                    ]);

                    for (const connectedId of allConnections) {
                        if (!componentVisited.has(connectedId)) {
                            const connectedElement = rayGraph.elements.get(connectedId);
                            if (connectedElement) {
                                queue.push(connectedElement);
                                componentVisited.add(connectedId);
                            }
                        }
                    }
                }

                components.push(component);
            }

            return components;
        }

        function mergeContinuousComponents(components, rayGraph) {
            if (components.length <= 1) return components;

            const continuousGroups = [];
            const processed = new Set();

            for (let i = 0; i < components.length; i++) {
                if (processed.has(i)) continue;

                const continuousGroup = [components[i]];
                processed.add(i);

                for (let j = i + 1; j < components.length; j++) {
                    if (processed.has(j)) continue;

                    if (areComponentsContinuous(components[i], components[j])) {
                        continuousGroup.push(components[j]);
                        processed.add(j);
                    }
                }

                if (continuousGroup.length > 1) {
                    const mergedComponent = continuousGroup.flat();
                    continuousGroups.push(mergedComponent);
                } else {
                    continuousGroups.push(components[i]);
                }
            }

            return continuousGroups;
        }

        function areComponentsContinuous(component1, component2) {
            const bounds1 = calculateGroupBounds(component1);
            const bounds2 = calculateGroupBounds(component2);

            const sameRow = Math.abs(bounds1.y - bounds2.y) <= Math.max(bounds1.height, bounds2.height) * 0.5;
            const sameColumn = Math.abs(bounds1.x - bounds2.x) <= Math.max(bounds1.width, bounds2.width) * 0.5;

            if (sameRow) {
                const horizontalGap = Math.min(
                    Math.abs(bounds1.x + bounds1.width - bounds2.x),
                    Math.abs(bounds2.x + bounds2.width - bounds1.x)
                );
                const avgWidth = (bounds1.width + bounds2.width) / 2;
                return horizontalGap <= avgWidth * 0.8;
            }

            if (sameColumn) {
                const verticalGap = Math.min(
                    Math.abs(bounds1.y + bounds1.height - bounds2.y),
                    Math.abs(bounds2.y + bounds2.height - bounds1.y)
                );
                const avgHeight = (bounds1.height + bounds2.height) / 2;
                return verticalGap <= avgHeight * 0.8;
            }

            return false;
        }

        // üéØ ÊâæÂà∞ËøûÈÄöÂàÜÈáèÁöÑÊúâÊïàÂ≠êÂàÜÁªÑ
        function findValidSubGroupings(component, rayGraph) {
            console.log(`\nüîç ‰∏∫ËøûÈÄöÂàÜÈáèÂØªÊâæÂ≠êÂàÜÁªÑ: [${component.map(e => e.name).join(', ')}]`);

            const subGroupings = [];

            // ÊñπÊ°à1Ôºö‰øùÊåÅÊï¥‰Ωì
            if (isHighlyConnected(component, rayGraph) && isSemanticallyCoherent(component)) {
                subGroupings.push([component]);
                console.log(`  ÊñπÊ°à1 - ‰øùÊåÅÊï¥‰Ωì: [${component.map(e => e.name).join(', ')}]`);
            }

            // ÊñπÊ°à2ÔºöÊåâË°åÂàÜÁªÑ
            const rowGroups = groupByRayDirection(component, rayGraph, 'horizontal');
            if (rowGroups.length > 1) {
                subGroupings.push(rowGroups);
                console.log(`  ÊñπÊ°à2 - ÊåâË°åÂàÜÁªÑ:`);
                rowGroups.forEach((group, i) => {
                    console.log(`    Ë°å ${i + 1}: [${group.map(e => e.name).join(', ')}]`);
                });
            }

            // ÊñπÊ°à3ÔºöÊåâÂàóÂàÜÁªÑ
            const columnGroups = groupByRayDirection(component, rayGraph, 'vertical');
            if (columnGroups.length > 1) {
                subGroupings.push(columnGroups);
                console.log(`  ÊñπÊ°à3 - ÊåâÂàóÂàÜÁªÑ:`);
                columnGroups.forEach((group, i) => {
                    console.log(`    Âàó ${i + 1}: [${group.map(e => e.name).join(', ')}]`);
                });
            }

            // ÊñπÊ°à4ÔºöËØ≠‰πâÂàÜÂâ≤
            const semanticGroups = findSemanticGrouping(component, rayGraph);
            if (semanticGroups.length > 1) {
                subGroupings.push(semanticGroups);
                console.log(`  ÊñπÊ°à4 - ËØ≠‰πâÂàÜÁªÑ:`);
                semanticGroups.forEach((group, i) => {
                    console.log(`    ËØ≠‰πâÁªÑ ${i + 1}: [${group.map(e => e.name).join(', ')}]`);
                });
            }

            // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞‰ªª‰ΩïÊúâÊïàÂàÜÁªÑÔºåËøîÂõûÂçïÂÖÉÁ¥†ÂàÜÁªÑ
            if (subGroupings.length === 0) {
                subGroupings.push(component.map(e => [e]));
                console.log(`  ÂõûÈÄÄ - ÂçïÂÖÉÁ¥†ÂàÜÁªÑ: ${component.map(e => `[${e.name}]`).join(', ')}`);
            }

            return subGroupings;
        }

        // üéØ Ê£ÄÊü•ËØ≠‰πâ‰∏ÄËá¥ÊÄß
        function isSemanticallyCoherent(component) {
            // ÁÆÄÂçïÂêØÂèëÂºèÔºöÂ¶ÇÊûúÂÖÉÁ¥†Êï∞ÈáèËæÉÂ∞ë‰∏îÁ©∫Èó¥Á¥ßÂØÜÔºåËÆ§‰∏∫ËØ≠‰πâÁõ∏ÂÖ≥
            if (component.length <= 2) return true;
            if (component.length > 4) return false; // Ë∂ÖËøá4‰∏™ÂÖÉÁ¥†ÂæàÂèØËÉΩ‰∏çÊòØ‰∏Ä‰∏™ËØ≠‰πâÂçïÂÖÉ

            // Ê£ÄÊü•Á©∫Èó¥Á¥ßÂØÜÊÄß
            const bounds = calculateGroupBounds(component);
            const density = component.length / (bounds.width * bounds.height);

            return density > 0.001; // ÂØÜÂ∫¶ÈòàÂÄº
        }

        // üéØ ËØ≠‰πâÂàÜÁªÑÔºàÂü∫‰∫éÈó¥ÈöôÂàÜÊûêÔºâ
        function findSemanticGrouping(component, rayGraph) {
            console.log(`      üîç ËøõË°åËØ≠‰πâÂàÜÁªÑÂàÜÊûê`);

            // ÊåâYÂùêÊ†áÊéíÂ∫èÔºåÂàÜÊûêÂûÇÁõ¥Èó¥Èöô
            const sortedByY = [...component].sort((a, b) => a.y - b.y);
            const groups = [];
            let currentGroup = [];

            for (let i = 0; i < sortedByY.length; i++) {
                const element = sortedByY[i];

                if (currentGroup.length === 0) {
                    currentGroup.push(element);
                } else {
                    const lastElement = currentGroup[currentGroup.length - 1];
                    const gap = element.y - (lastElement.y + lastElement.height);

                    // ËÆ°ÁÆóËØ≠‰πâÂàÜÂâ≤ÈòàÂÄº
                    const semanticThreshold = calculateSemanticThreshold(lastElement, element);

                    console.log(`        üìè "${lastElement.name}" Âà∞ "${element.name}" Èó¥Èöô: ${gap}, ËØ≠‰πâÈòàÂÄº: ${semanticThreshold}`);

                    if (gap > semanticThreshold) {
                        // Èó¥ÈöôËøáÂ§ßÔºåÂºÄÂßãÊñ∞ÁªÑ
                        groups.push([...currentGroup]);
                        console.log(`        üì¶ ËØ≠‰πâÂàÜÂâ≤: [${currentGroup.map(e => e.name).join(', ')}]`);
                        currentGroup = [element];
                    } else {
                        // ÁªßÁª≠ÂΩìÂâçÁªÑ
                        currentGroup.push(element);
                    }
                }
            }

            if (currentGroup.length > 0) {
                groups.push(currentGroup);
                console.log(`        üì¶ ÊúÄÂêéËØ≠‰πâÁªÑ: [${currentGroup.map(e => e.name).join(', ')}]`);
            }

            return groups;
        }

        // üéØ ËÆ°ÁÆóËØ≠‰πâÂàÜÂâ≤ÈòàÂÄº
        function calculateSemanticThreshold(elem1, elem2) {
            // Âü∫‰∫éÂÖÉÁ¥†È´òÂ∫¶ÁöÑÂä®ÊÄÅÈòàÂÄº
            const avgHeight = (elem1.height + elem2.height) / 2;

            // Â¶ÇÊûúÂÖÉÁ¥†È´òÂ∫¶Â∑ÆÂºÇÂæàÂ§ßÔºåÂèØËÉΩÊòØ‰∏çÂêåÁ±ªÂûãÁöÑ‰ø°ÊÅØ
            const heightDiff = Math.abs(elem1.height - elem2.height);
            const heightRatio = heightDiff / avgHeight;

            // Âü∫Á°ÄÈòàÂÄºÔºöÂπ≥ÂùáÈ´òÂ∫¶ÁöÑ30%
            let threshold = avgHeight * 0.3;

            // Â¶ÇÊûúÈ´òÂ∫¶Â∑ÆÂºÇÂ§ßÔºåÈôç‰ΩéÈòàÂÄºÔºàÊõ¥ÂÆπÊòìÂàÜÂâ≤Ôºâ
            if (heightRatio > 0.5) {
                threshold *= 0.7;
            }

            // Â¶ÇÊûúÂÖÉÁ¥†ÂæàÂ∞èÔºå‰ΩøÁî®Âõ∫ÂÆöÊúÄÂ∞èÈòàÂÄº
            threshold = Math.max(threshold, 5);

            return threshold;
        }

        // üéØ Ê£ÄÊü•ÂàÜÁªÑÊòØÂê¶Á≠â‰ª∑
        function isEquivalentGrouping(groups1, groups2) {
            if (groups1.length !== groups2.length) return false;

            // ÁÆÄÂåñÊ£ÄÊü•ÔºöÊØîËæÉÊØèÁªÑÁöÑÂÖÉÁ¥†Êï∞Èáè
            const sizes1 = groups1.map(g => g.length).sort();
            const sizes2 = groups2.map(g => g.length).sort();

            return sizes1.every((size, index) => size === sizes2[index]);
        }

        // üéØ ËÆ°ÁÆóÂàÜÁªÑËæπÁïå
        function calculateGroupBounds(group) {
            const minX = Math.min(...group.map(e => e.x));
            const maxX = Math.max(...group.map(e => e.x + e.width));
            const minY = Math.min(...group.map(e => e.y));
            const maxY = Math.max(...group.map(e => e.y + e.height));

            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        // üéØ Ê£ÄÊü•ÊòØÂê¶È´òÂ∫¶ËøûÊé•
        function isHighlyConnected(component, rayGraph) {
            if (component.length <= 2) return true;

            const totalPossibleConnections = component.length * (component.length - 1) / 2;
            const actualConnections = calculateGroupConnections(component, rayGraph);
            const connectionRatio = actualConnections / totalPossibleConnections;

            return connectionRatio > 0.6; // 60%‰ª•‰∏äÁöÑËøûÊé•ÁéáËÆ§‰∏∫ÊòØÈ´òÂ∫¶ËøûÊé•
        }

        // üéØ ÊåâÂ∞ÑÁ∫øÊñπÂêëÂàÜÁªÑ
        function groupByRayDirection(component, rayGraph, direction) {
            const groups = [];
            const processed = new Set();

            for (const element of component) {
                if (processed.has(element.id)) continue;

                const group = [];
                const queue = [element];
                const visited = new Set([element.id]);

                while (queue.length > 0) {
                    const current = queue.shift();
                    group.push(current);
                    processed.add(current.id);

                    // Âè™ËÄÉËôëÊåáÂÆöÊñπÂêëÁöÑËøûÊé•
                    const connections = rayGraph[direction].get(current.id) || new Set();
                    for (const connectedId of connections) {
                        if (!visited.has(connectedId) && !processed.has(connectedId)) {
                            const connectedElement = rayGraph.elements.get(connectedId);
                            if (connectedElement && component.some(e => e.id === connectedId)) {
                                queue.push(connectedElement);
                                visited.add(connectedId);
                            }
                        }
                    }
                }

                if (group.length > 0) {
                    groups.push(group);
                }
            }

            return groups;
        }

        // üéØ ÊâæÂà∞Ê∑∑ÂêàÂàÜÁªÑ
        function findMixedGrouping(component, rayGraph) {
            // ‰ΩøÁî®Ë¥™ÂøÉÁÆóÊ≥ïÔºå‰ºòÂÖàÈÄâÊã©ËøûÊé•ÊúÄÂØÜÈõÜÁöÑÂ≠êÁªÑ
            const groups = [];
            const processed = new Set();

            // ÊåâËøûÊé•Â∫¶ÊéíÂ∫èÂÖÉÁ¥†
            const sortedElements = component.sort((a, b) => {
                const aConnections = (rayGraph.horizontal.get(a.id)?.size || 0) + (rayGraph.vertical.get(a.id)?.size || 0);
                const bConnections = (rayGraph.horizontal.get(b.id)?.size || 0) + (rayGraph.vertical.get(b.id)?.size || 0);
                return bConnections - aConnections;
            });

            for (const element of sortedElements) {
                if (processed.has(element.id)) continue;

                const group = findOptimalSubGroup(element, component, rayGraph, processed);
                if (group.length > 0) {
                    groups.push(group);
                    group.forEach(e => processed.add(e.id));
                }
            }

            return groups;
        }

        // üéØ ÊâæÂà∞ÊúÄ‰ºòÂ≠êÁªÑ
        function findOptimalSubGroup(startElement, component, rayGraph, processed) {
            const group = [startElement];
            const candidates = component.filter(e => !processed.has(e.id) && e.id !== startElement.id);

            // Ë¥™ÂøÉÊ∑ªÂä†ÊúÄÁõ∏ÂÖ≥ÁöÑÂÖÉÁ¥†
            while (candidates.length > 0) {
                let bestCandidate = null;
                let bestScore = -1;

                for (const candidate of candidates) {
                    const score = calculateGroupRelevance(candidate, group, rayGraph);
                    if (score > bestScore) {
                        bestScore = score;
                        bestCandidate = candidate;
                    }
                }

                if (bestCandidate && bestScore > 0) {
                    group.push(bestCandidate);
                    candidates.splice(candidates.indexOf(bestCandidate), 1);
                } else {
                    break;
                }
            }

            return group;
        }

        // üéØ ËÆ°ÁÆóÁªÑÁõ∏ÂÖ≥ÊÄß
        function calculateGroupRelevance(candidate, group, rayGraph) {
            let score = 0;

            for (const groupMember of group) {
                if (rayGraph.horizontal.get(candidate.id)?.has(groupMember.id)) score += 2;
                if (rayGraph.vertical.get(candidate.id)?.has(groupMember.id)) score += 2;
            }

            return score;
        }

        // üéØ ÁªÑÂêàÂàÜÈáèÂàÜÁªÑ
        function combineComponentGroupings(componentGroupings) {
            // ÁÆÄÂåñÁâàÊú¨ÔºöÂèñÊØè‰∏™ÂàÜÈáèÁöÑÁ¨¨‰∏Ä‰∏™ÂàÜÁªÑÊñπÊ°à
            const combined = [];
            for (const groupings of componentGroupings) {
                if (groupings.length > 0) {
                    combined.push(...groupings[0]);
                }
            }
            return [combined];
        }

        // üéØ ËÆ°ÁÆóÂàÜÁªÑÂæóÂàÜÔºàÊ∑±Â∫¶√óÂπøÂ∫¶ + ÂùáË°°ÊÄßÊÉ©ÁΩöÔºâ
        function calculateGroupingScore(groups) {
            // Âü∫Á°ÄÊåáÊ†á
            const maxGroupSize = Math.max(...groups.map(g => g.length));
            const groupCount = groups.length;
            const totalElements = groups.reduce((sum, g) => sum + g.length, 0);

            // Ê∑±Â∫¶ = ÊúÄÂ§ßÁªÑÂÜÖÂÖÉÁ¥†Êï∞
            // ÂπøÂ∫¶ = ÊÄªÂàÜÁªÑÊï∞
            const depth = maxGroupSize;
            const breadth = groupCount;
            const baseScore = depth * breadth;

            // ÂùáË°°ÊÄßÂàÜÊûê
            const avgGroupSize = totalElements / groupCount;
            const sizeVariance = groups.reduce((sum, g) => sum + Math.pow(g.length - avgGroupSize, 2), 0) / groupCount;
            const balancePenalty = sizeVariance * 0.5; // ÊñπÂ∑ÆÊÉ©ÁΩö

            // ÊûÅÁ´ØÂÄºÊÉ©ÁΩö
            const extremePenalty = calculateExtremePenalty(depth, breadth, totalElements);

            const total = baseScore + balancePenalty + extremePenalty;

            return {
                depth,
                breadth,
                baseScore,
                balancePenalty: Math.round(balancePenalty * 100) / 100,
                extremePenalty: Math.round(extremePenalty * 100) / 100,
                total: Math.round(total * 100) / 100
            };
        }

        // üéØ ËÆ°ÁÆóÊûÅÁ´ØÂÄºÊÉ©ÁΩö
        function calculateExtremePenalty(depth, breadth, totalElements) {
            let penalty = 0;

            // ÁêÜÊÉ≥ÁöÑÂπ≥Ë°°ÁÇπÔºöÊ∑±Â∫¶ÂíåÂπøÂ∫¶Êé•Ëøë sqrt(totalElements)
            const idealBalance = Math.sqrt(totalElements);

            // Ê∑±Â∫¶ËøáÂ§ßÊÉ©ÁΩöÔºàÈÅøÂÖçÂçï‰∏™ÁªÑËøáÂ§ßÔºâ
            if (depth > idealBalance * 1.5) {
                penalty += (depth - idealBalance * 1.5) * 2;
            }

            // ÂπøÂ∫¶ËøáÂ§ßÊÉ©ÁΩöÔºàÈÅøÂÖçÂàÜÁªÑËøáÂ§öÔºâ
            if (breadth > idealBalance * 1.5) {
                penalty += (breadth - idealBalance * 1.5) * 2;
            }

            // Ê∑±Â∫¶ËøáÂ∞èÊÉ©ÁΩöÔºàÈÅøÂÖçÂàÜÁªÑËøáÁªÜÔºâ
            if (depth < 2 && totalElements > 4) {
                penalty += (2 - depth) * 3;
            }

            // ÂπøÂ∫¶ËøáÂ∞èÊÉ©ÁΩöÔºàÈÅøÂÖçÂçï‰∏ÄÂ§ßÁªÑÔºâ
            if (breadth < 2 && totalElements > 4) {
                penalty += (2 - breadth) * 5;
            }

            return penalty;
        }



        // üéØ ÊûÑÂª∫ÁõÆÊ†áÂ§ßÂ∞èÁöÑÂàÜÁªÑ
        function buildTargetSizeGroup(startElement, allElements, rayGraph, processed, targetSize) {
            const group = [startElement];
            const candidates = allElements.filter(e => !processed.has(e.id) && e.id !== startElement.id);

            // ÊåâËøûÊé•Âº∫Â∫¶ÊéíÂ∫èÂÄôÈÄâÂÖÉÁ¥†
            const scoredCandidates = candidates.map(candidate => ({
                element: candidate,
                score: calculateConnectionScore(startElement, candidate, rayGraph, group)
            })).sort((a, b) => b.score - a.score);

            // Ë¥™ÂøÉÊ∑ªÂä†ÂÖÉÁ¥†Áõ¥Âà∞ËææÂà∞ÁõÆÊ†áÂ§ßÂ∞è
            for (const { element } of scoredCandidates) {
                if (group.length >= targetSize) break;

                // Ê£ÄÊü•ÊòØÂê¶‰∏éÁªÑÂÜÖ‰ªª‰ΩïÂÖÉÁ¥†ÊúâËøûÊé•
                if (hasConnectionToGroup(element, group, rayGraph)) {
                    group.push(element);
                }
            }

            return group;
        }

        // üéØ ËÆ°ÁÆóËøûÊé•ÂæóÂàÜ
        function calculateConnectionScore(anchor, candidate, rayGraph, currentGroup) {
            let score = 0;

            // ‰∏éÈîöÁÇπÁöÑÁõ¥Êé•ËøûÊé•
            if (rayGraph.horizontal.get(anchor.id)?.has(candidate.id)) score += 3;
            if (rayGraph.vertical.get(anchor.id)?.has(candidate.id)) score += 3;

            // ‰∏éÁªÑÂÜÖÂÖ∂‰ªñÂÖÉÁ¥†ÁöÑËøûÊé•
            for (const groupMember of currentGroup) {
                if (rayGraph.horizontal.get(groupMember.id)?.has(candidate.id)) score += 2;
                if (rayGraph.vertical.get(groupMember.id)?.has(candidate.id)) score += 2;
            }

            // Ë∑ùÁ¶ªÊÉ©ÁΩö
            const distance = calculateMinDistance(anchor, candidate);
            score -= distance * 0.01;

            return score;
        }

        // üéØ Ê£ÄÊü•ÊòØÂê¶‰∏éÂàÜÁªÑÊúâËøûÊé•
        function hasConnectionToGroup(element, group, rayGraph) {
            return group.some(groupMember => {
                return rayGraph.horizontal.get(element.id)?.has(groupMember.id) ||
                       rayGraph.vertical.get(element.id)?.has(groupMember.id);
            });
        }

        // üéØ ËØÑ‰º∞ÂàÜÁªÑÂùáË°°ÊÄß
        function evaluateGroupBalance(group, idealSize, rayGraph) {
            if (group.length === 0) return -Infinity;

            // Â§ßÂ∞èÊé•ËøëÁêÜÊÉ≥ÂÄºÁöÑÂæóÂàÜÊõ¥È´ò
            const sizeScore = idealSize - Math.abs(group.length - idealSize);

            // ËøûÊé•ÂØÜÂ∫¶ÂæóÂàÜ
            const connectionDensity = rayGraph ?
                calculateGroupConnections(group, rayGraph) / Math.max(1, group.length - 1) : 0;

            return sizeScore + connectionDensity;
        }

        // üéØ ÊâæÂà∞ÊúÄ‰ºòË°åÂàÜÁªÑ
        function findOptimalRows(elements, rayGraph) {
            console.log(`      üîç ÂØªÊâæÊúÄ‰ºòË°åÂàÜÁªÑ`);

            const rows = [];
            const processed = new Set();

            const sortedByY = [...elements].sort((a, b) => a.y - b.y);

            for (const element of sortedByY) {
                if (processed.has(element.id)) continue;

                const row = findMaxHorizontalComponent(element, elements, rayGraph, processed);

                if (row.length > 0) {
                    rows.push(row);
                    row.forEach(e => processed.add(e.id));
                }
            }

            return rows;
        }

        // üéØ Âú®Ë°åÂÜÖÊâæÂà∞ÊúÄ‰ºòÂàóÂàÜÁªÑ
        function findOptimalColumnsInRow(rowElements, rayGraph) {
            console.log(`      üîç Âú®Ë°åÂÜÖÂØªÊâæÊúÄ‰ºòÂàóÂàÜÁªÑ`);

            const columns = [];
            const processed = new Set();

            const sortedByX = [...rowElements].sort((a, b) => a.x - b.x);

            for (const element of sortedByX) {
                if (processed.has(element.id)) continue;

                const column = findMaxVerticalComponent(element, rowElements, rayGraph, processed);

                if (column.length > 0) {
                    columns.push(column);
                    column.forEach(e => processed.add(e.id));
                }
            }

            return columns;
        }

        // üéØ ÊâæÂà∞ÊúÄÂ§ßËøûÈÄöÂàÜÈáè
        function findMaxConnectedComponent(startElement, allElements, rayGraph, processed) {
            const component = [];
            const queue = [startElement];
            const visited = new Set([startElement.id]);

            while (queue.length > 0) {
                const current = queue.shift();
                if (processed.has(current.id)) continue;

                component.push(current);

                // ÈÅçÂéÜÊâÄÊúâËøûÊé•ÔºàÊ∞¥Âπ≥+ÂûÇÁõ¥Ôºâ
                const allConnections = new Set([
                    ...(rayGraph.horizontal.get(current.id) || []),
                    ...(rayGraph.vertical.get(current.id) || [])
                ]);

                for (const connectedId of allConnections) {
                    if (!visited.has(connectedId) && !processed.has(connectedId)) {
                        const connectedElement = rayGraph.elements.get(connectedId);
                        if (connectedElement) {
                            queue.push(connectedElement);
                            visited.add(connectedId);
                        }
                    }
                }
            }

            return component;
        }

        // üéØ ËÆ°ÁÆóÂàÜÁªÑÂÜÖËøûÊé•Êï∞
        function calculateGroupConnections(group, rayGraph) {
            let connections = 0;

            for (let i = 0; i < group.length; i++) {
                for (let j = i + 1; j < group.length; j++) {
                    const elem1 = group[i];
                    const elem2 = group[j];

                    const horizontalConnected = rayGraph.horizontal.get(elem1.id)?.has(elem2.id);
                    const verticalConnected = rayGraph.vertical.get(elem1.id)?.has(elem2.id);

                    if (horizontalConnected || verticalConnected) {
                        connections++;
                    }
                }
            }

            return connections;
        }

        // üéØ ÊâæÂà∞ÊúÄ‰ºòÂàóÂàÜÁªÑ
        function findOptimalColumns(elements, rayGraph) {
            console.log(`  üîç ÂØªÊâæÊúÄ‰ºòÂàóÂàÜÁªÑ`);

            const columns = [];
            const processed = new Set();

            // ÊåâXÂùêÊ†áÊéíÂ∫èÔºå‰ºòÂÖàÂ§ÑÁêÜÂ∑¶‰æßÂÖÉÁ¥†
            const sortedByX = [...elements].sort((a, b) => a.x - b.x);

            for (const element of sortedByX) {
                if (processed.has(element.id)) continue;

                // ‰ΩøÁî®Âä®ÊÄÅËßÑÂàíÊâæÂà∞ÂåÖÂê´ÂΩìÂâçÂÖÉÁ¥†ÁöÑÊúÄÂ§ßÂûÇÁõ¥ËøûÈÄöÂàÜÈáè
                const column = findMaxVerticalComponent(element, elements, rayGraph, processed);

                if (column.length > 0) {
                    columns.push(column);
                    column.forEach(e => processed.add(e.id));

                    // ËÆ°ÁÆóÂàóÁöÑËæπÁïå‰ø°ÊÅØ
                    const columnBounds = calculateColumnBounds(column);
                    console.log(`    üì¶ Âàó ${columns.length}: [${column.map(e => e.name).join(', ')}] ÂÆΩÂ∫¶=${columnBounds.width}`);
                }
            }

            return columns;
        }

        // üéØ ÊâæÂà∞ÊúÄÂ§ßÂûÇÁõ¥ËøûÈÄöÂàÜÈáè
        function findMaxVerticalComponent(startElement, allElements, rayGraph, processed) {
            const component = [];
            const queue = [startElement];
            const visited = new Set([startElement.id]);

            while (queue.length > 0) {
                const current = queue.shift();
                if (processed.has(current.id)) continue;

                component.push(current);

                // ÈÅçÂéÜÊâÄÊúâÂûÇÁõ¥ËøûÊé•ÁöÑÂÖÉÁ¥†
                const verticalConnections = rayGraph.vertical.get(current.id) || new Set();
                for (const connectedId of verticalConnections) {
                    if (!visited.has(connectedId) && !processed.has(connectedId)) {
                        const connectedElement = rayGraph.elements.get(connectedId);
                        queue.push(connectedElement);
                        visited.add(connectedId);
                    }
                }
            }

            return component;
        }

        // üéØ Âú®ÂàóÂÜÖÊâæÂà∞ÊúÄ‰ºòË°åÂàÜÁªÑ
        function findOptimalRowsInColumn(columnElements, rayGraph) {
            console.log(`    üîç Âú®ÂàóÂÜÖÂØªÊâæÊúÄ‰ºòË°åÂàÜÁªÑ`);

            const rows = [];
            const processed = new Set();

            // ÊåâYÂùêÊ†áÊéíÂ∫èÔºå‰ºòÂÖàÂ§ÑÁêÜÈ°∂ÈÉ®ÂÖÉÁ¥†
            const sortedByY = [...columnElements].sort((a, b) => a.y - b.y);

            for (const element of sortedByY) {
                if (processed.has(element.id)) continue;

                // ‰ΩøÁî®Âä®ÊÄÅËßÑÂàíÊâæÂà∞ÂåÖÂê´ÂΩìÂâçÂÖÉÁ¥†ÁöÑÊúÄÂ§ßÊ∞¥Âπ≥ËøûÈÄöÂàÜÈáè
                const row = findMaxHorizontalComponent(element, columnElements, rayGraph, processed);

                if (row.length > 0) {
                    rows.push(row);
                    row.forEach(e => processed.add(e.id));

                    // ËÆ°ÁÆóË°åÁöÑËæπÁïå‰ø°ÊÅØ
                    const rowBounds = calculateRowBounds(row);
                    console.log(`      üì¶ Ë°å ${rows.length}: [${row.map(e => e.name).join(', ')}] È´òÂ∫¶=${rowBounds.height}`);
                }
            }

            return rows;
        }

        // üéØ ÊâæÂà∞ÊúÄÂ§ßÊ∞¥Âπ≥ËøûÈÄöÂàÜÈáè
        function findMaxHorizontalComponent(startElement, columnElements, rayGraph, processed) {
            const component = [];
            const queue = [startElement];
            const visited = new Set([startElement.id]);

            while (queue.length > 0) {
                const current = queue.shift();
                if (processed.has(current.id)) continue;

                component.push(current);

                // ÈÅçÂéÜÊâÄÊúâÊ∞¥Âπ≥ËøûÊé•ÁöÑÂÖÉÁ¥†ÔºàÈôêÂà∂Âú®ÂΩìÂâçÂàóÂÜÖÔºâ
                const horizontalConnections = rayGraph.horizontal.get(current.id) || new Set();
                for (const connectedId of horizontalConnections) {
                    if (!visited.has(connectedId) && !processed.has(connectedId)) {
                        const connectedElement = rayGraph.elements.get(connectedId);
                        // Á°Æ‰øùËøûÊé•ÁöÑÂÖÉÁ¥†Âú®ÂΩìÂâçÂàóÂÜÖ
                        if (columnElements.some(e => e.id === connectedId)) {
                            queue.push(connectedElement);
                            visited.add(connectedId);
                        }
                    }
                }
            }

            return component;
        }

        // üéØ ËÆ°ÁÆóÂàóËæπÁïå
        function calculateColumnBounds(column) {
            const minX = Math.min(...column.map(e => e.x));
            const maxX = Math.max(...column.map(e => e.x + e.width));
            const minY = Math.min(...column.map(e => e.y));
            const maxY = Math.max(...column.map(e => e.y + e.height));

            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        // üéØ ËÆ°ÁÆóË°åËæπÁïå
        function calculateRowBounds(row) {
            const minX = Math.min(...row.map(e => e.x));
            const maxX = Math.max(...row.map(e => e.x + e.width));
            const minY = Math.min(...row.map(e => e.y));
            const maxY = Math.max(...row.map(e => e.y + e.height));

            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        // üéØ ÈÄíÂΩíÂ∞ÑÁ∫øÂàÜÁªÑ
        function recursiveRayGrouping(elements, depth) {
            const indent = '  '.repeat(depth);
            console.log(`${indent}üîç ÈÄíÂΩíÂàÜÁªÑ (Ê∑±Â∫¶${depth}): [${elements.map(e => e.name).join(', ')}]`);

            if (elements.length <= 1) {
                console.log(`${indent}üì¶ ÂçïÂÖÉÁ¥†ÊàñÁ©∫ÁªÑÔºåÁõ¥Êé•ËøîÂõû`);
                return elements.length > 0 ? [elements] : [];
            }

            // 1. Â∞ùËØïÊ∞¥Âπ≥Â∞ÑÁ∫øÂàÜÁªÑ
            const horizontalGroups = groupByHorizontalRays(elements, depth);

            if (horizontalGroups.length > 1) {
                // Ê∞¥Âπ≥ÂàÜÁªÑÊàêÂäüÔºåÈÄíÂΩíÂ§ÑÁêÜÊØè‰∏™Ê∞¥Âπ≥ÁªÑ
                console.log(`${indent}‚úÖ Ê∞¥Âπ≥ÂàÜÁªÑÊàêÂäüÔºåÂàÜÊàê ${horizontalGroups.length} ÁªÑ`);
                const finalGroups = [];

                horizontalGroups.forEach((hGroup, index) => {
                    console.log(`${indent}üîÑ ÈÄíÂΩíÂ§ÑÁêÜÊ∞¥Âπ≥ÁªÑ ${index + 1}: [${hGroup.map(e => e.name).join(', ')}]`);
                    const subGroups = recursiveRayGrouping(hGroup, depth + 1);
                    finalGroups.push(...subGroups);
                });

                return finalGroups;
            } else {
                // Ê∞¥Âπ≥ÂàÜÁªÑÂ§±Ë¥•ÔºåÂ∞ùËØïÂûÇÁõ¥Â∞ÑÁ∫øÂàÜÁªÑ
                console.log(`${indent}üîÑ Ê∞¥Âπ≥ÂàÜÁªÑÂ§±Ë¥•ÔºåÂ∞ùËØïÂûÇÁõ¥ÂàÜÁªÑ`);
                const verticalGroups = groupByVerticalRays(elements, depth);

                if (verticalGroups.length > 1) {
                    console.log(`${indent}‚úÖ ÂûÇÁõ¥ÂàÜÁªÑÊàêÂäüÔºåÂàÜÊàê ${verticalGroups.length} ÁªÑ`);
                    const finalGroups = [];

                    verticalGroups.forEach((vGroup, index) => {
                        console.log(`${indent}üîÑ ÈÄíÂΩíÂ§ÑÁêÜÂûÇÁõ¥ÁªÑ ${index + 1}: [${vGroup.map(e => e.name).join(', ')}]`);
                        const subGroups = recursiveRayGrouping(vGroup, depth + 1);
                        finalGroups.push(...subGroups);
                    });

                    return finalGroups;
                } else {
                    // Êó†Ê≥ïËøõ‰∏ÄÊ≠•ÂàÜÁªÑÔºåËøîÂõûÊï¥‰Ωì
                    console.log(`${indent}üì¶ Êó†Ê≥ïËøõ‰∏ÄÊ≠•ÂàÜÁªÑÔºå‰Ωú‰∏∫Êï¥‰Ωì: [${elements.map(e => e.name).join(', ')}]`);
                    return [elements];
                }
            }
        }

        // üéØ Âü∫‰∫éÊ∞¥Âπ≥Â∞ÑÁ∫øÂàÜÁªÑ
        function groupByHorizontalRays(elements, depth) {
            const indent = '  '.repeat(depth);
            console.log(`${indent}üîç Â∞ùËØïÊ∞¥Âπ≥Â∞ÑÁ∫øÂàÜÁªÑ`);

            // ÊåâYÂùêÊ†áÊéíÂ∫è
            const sortedByY = [...elements].sort((a, b) => a.y - b.y);

            const groups = [];
            const processed = new Set();

            for (const element of sortedByY) {
                if (processed.has(element.id)) continue;

                // ÊâæÂà∞ÊâÄÊúâËÉΩÈÄöËøáÊ∞¥Âπ≥Â∞ÑÁ∫øËøûÊé•ÁöÑÂÖÉÁ¥†
                const horizontalGroup = findHorizontalRayGroup(element, elements, processed);

                if (horizontalGroup.length > 0) {
                    groups.push(horizontalGroup);
                    horizontalGroup.forEach(e => processed.add(e.id));
                    console.log(`${indent}  üì¶ Ê∞¥Âπ≥ÁªÑ: [${horizontalGroup.map(e => e.name).join(', ')}]`);
                }
            }

            console.log(`${indent}üìä Ê∞¥Âπ≥ÂàÜÁªÑÁªìÊûú: ${groups.length} ÁªÑ`);
            return groups;
        }

        // üéØ Âü∫‰∫éÂûÇÁõ¥Â∞ÑÁ∫øÂàÜÁªÑ
        function groupByVerticalRays(elements, depth) {
            const indent = '  '.repeat(depth);
            console.log(`${indent}üîç Â∞ùËØïÂûÇÁõ¥Â∞ÑÁ∫øÂàÜÁªÑ`);

            // ÊåâXÂùêÊ†áÊéíÂ∫è
            const sortedByX = [...elements].sort((a, b) => a.x - b.x);

            const groups = [];
            const processed = new Set();

            for (const element of sortedByX) {
                if (processed.has(element.id)) continue;

                // ÊâæÂà∞ÊâÄÊúâËÉΩÈÄöËøáÂûÇÁõ¥Â∞ÑÁ∫øËøûÊé•ÁöÑÂÖÉÁ¥†
                const verticalGroup = findVerticalRayGroup(element, elements, processed);

                if (verticalGroup.length > 0) {
                    groups.push(verticalGroup);
                    verticalGroup.forEach(e => processed.add(e.id));
                    console.log(`${indent}  üì¶ ÂûÇÁõ¥ÁªÑ: [${verticalGroup.map(e => e.name).join(', ')}]`);
                }
            }

            console.log(`${indent}üìä ÂûÇÁõ¥ÂàÜÁªÑÁªìÊûú: ${groups.length} ÁªÑ`);
            return groups;
        }

        // üéØ ÊâæÂà∞Ê∞¥Âπ≥Â∞ÑÁ∫øËøûÊé•ÁöÑÁªÑ
        function findHorizontalRayGroup(startElement, allElements, processed) {
            const group = [startElement];
            const queue = [startElement];
            const inGroup = new Set([startElement.id]);

            while (queue.length > 0) {
                const current = queue.shift();

                // ÂèëÂ∞ÑÂ∑¶Âè≥Â∞ÑÁ∫ø
                for (const candidate of allElements) {
                    if (processed.has(candidate.id) || inGroup.has(candidate.id)) continue;

                    // Ê£ÄÊü•ÊòØÂê¶Âú®Âêå‰∏ÄÊ∞¥Âπ≥Á∫ø‰∏äÔºàYËΩ¥ÈáçÂè†Ôºâ
                    const yOverlap = !(
                        current.y + current.height <= candidate.y ||
                        candidate.y + candidate.height <= current.y
                    );

                    if (yOverlap) {
                        // Ê£ÄÊü•Ê∞¥Âπ≥Â∞ÑÁ∫øÊòØÂê¶Ë¢´ÈòªÊå°
                        if (!isHorizontalRayBlocked(current, candidate, allElements)) {
                            group.push(candidate);
                            queue.push(candidate);
                            inGroup.add(candidate.id);
                        }
                    }
                }
            }

            return group;
        }

        // üéØ ÊâæÂà∞ÂûÇÁõ¥Â∞ÑÁ∫øËøûÊé•ÁöÑÁªÑ
        function findVerticalRayGroup(startElement, allElements, processed) {
            const group = [startElement];
            const queue = [startElement];
            const inGroup = new Set([startElement.id]);

            while (queue.length > 0) {
                const current = queue.shift();

                // ÂèëÂ∞Ñ‰∏ä‰∏ãÂ∞ÑÁ∫ø
                for (const candidate of allElements) {
                    if (processed.has(candidate.id) || inGroup.has(candidate.id)) continue;

                    // Ê£ÄÊü•ÊòØÂê¶Âú®Âêå‰∏ÄÂûÇÁõ¥Á∫ø‰∏äÔºàXËΩ¥ÈáçÂè†Ôºâ
                    const xOverlap = !(
                        current.x + current.width <= candidate.x ||
                        candidate.x + candidate.width <= current.x
                    );

                    if (xOverlap) {
                        // Ê£ÄÊü•ÂûÇÁõ¥Â∞ÑÁ∫øÊòØÂê¶Ë¢´ÈòªÊå°
                        if (!isVerticalRayBlocked(current, candidate, allElements)) {
                            group.push(candidate);
                            queue.push(candidate);
                            inGroup.add(candidate.id);
                        }
                    }
                }
            }

            return group;
        }

        // üéØ Ê£ÄÊü•Ê∞¥Âπ≥Â∞ÑÁ∫øÊòØÂê¶Ë¢´ÈòªÊå°
        function isHorizontalRayBlocked(elem1, elem2, allElements) {
            // ÂàõÂª∫Ê∞¥Âπ≥Â∞ÑÁ∫øË∑ØÂæÑ
            const rayPath = {
                left: Math.min(elem1.x + elem1.width, elem2.x),
                right: Math.max(elem1.x, elem2.x + elem2.width),
                top: Math.max(elem1.y, elem2.y),
                bottom: Math.min(elem1.y + elem1.height, elem2.y + elem2.height)
            };

            // Â¶ÇÊûúÊ≤°ÊúâYËΩ¥ÈáçÂè†Âå∫ÂüüÔºåÊó†Ê≥ïËøûÊé•
            if (rayPath.top >= rayPath.bottom) return true;

            // Ê£ÄÊü•ÊòØÂê¶ÊúâÂÖ∂‰ªñÂÖÉÁ¥†ÈòªÊå°Â∞ÑÁ∫øË∑ØÂæÑ
            for (const other of allElements) {
                if (other.id === elem1.id || other.id === elem2.id) continue;

                // Ê£ÄÊü•ÂÖ∂‰ªñÂÖÉÁ¥†ÊòØÂê¶‰∏éÂ∞ÑÁ∫øË∑ØÂæÑÁõ∏‰∫§
                const intersects = !(
                    other.x + other.width <= rayPath.left ||
                    other.x >= rayPath.right ||
                    other.y + other.height <= rayPath.top ||
                    other.y >= rayPath.bottom
                );

                if (intersects) {
                    return true; // Ë¢´ÈòªÊå°
                }
            }

            return false; // Êú™Ë¢´ÈòªÊå°
        }

        // üéØ Ê£ÄÊü•ÂûÇÁõ¥Â∞ÑÁ∫øÊòØÂê¶Ë¢´ÈòªÊå°
        function isVerticalRayBlocked(elem1, elem2, allElements) {
            // ÂàõÂª∫ÂûÇÁõ¥Â∞ÑÁ∫øË∑ØÂæÑ
            const rayPath = {
                left: Math.max(elem1.x, elem2.x),
                right: Math.min(elem1.x + elem1.width, elem2.x + elem2.width),
                top: Math.min(elem1.y + elem1.height, elem2.y),
                bottom: Math.max(elem1.y, elem2.y + elem2.height)
            };

            // Â¶ÇÊûúÊ≤°ÊúâXËΩ¥ÈáçÂè†Âå∫ÂüüÔºåÊó†Ê≥ïËøûÊé•
            if (rayPath.left >= rayPath.right) return true;

            // Ê£ÄÊü•ÊòØÂê¶ÊúâÂÖ∂‰ªñÂÖÉÁ¥†ÈòªÊå°Â∞ÑÁ∫øË∑ØÂæÑ
            for (const other of allElements) {
                if (other.id === elem1.id || other.id === elem2.id) continue;

                // Ê£ÄÊü•ÂÖ∂‰ªñÂÖÉÁ¥†ÊòØÂê¶‰∏éÂ∞ÑÁ∫øË∑ØÂæÑÁõ∏‰∫§
                const intersects = !(
                    other.x + other.width <= rayPath.left ||
                    other.x >= rayPath.right ||
                    other.y + other.height <= rayPath.top ||
                    other.y >= rayPath.bottom
                );

                if (intersects) {
                    return true; // Ë¢´ÈòªÊå°
                }
            }

            return false; // Êú™Ë¢´ÈòªÊå°
        }

        // üéØ ËØÜÂà´ÂàóÁªìÊûÑ
        function identifyColumns(elements) {
            console.log(`\nüîç ËØÜÂà´ÂàóÁªìÊûÑ`);

            // ÊåâXÂùêÊ†áÊéíÂ∫è
            const sortedByX = [...elements].sort((a, b) => a.x - b.x);

            const columns = [];
            let currentColumn = [];

            for (const element of sortedByX) {
                if (currentColumn.length === 0) {
                    currentColumn.push(element);
                } else {
                    // Ê£ÄÊü•ÊòØÂê¶‰∏éÂΩìÂâçÂàóÊúâXËΩ¥ÈáçÂè†ÊàñÊé•Ëøë
                    const canJoinColumn = currentColumn.some(colElement => {
                        // XËΩ¥ÈáçÂè†Ê£ÄÊü•
                        const xOverlap = !(element.x >= colElement.x + colElement.width ||
                                         element.x + element.width <= colElement.x);

                        // XËΩ¥Êé•ËøëÊ£ÄÊü•ÔºàË∑ùÁ¶ªÂ∞è‰∫éÂπ≥ÂùáÂÆΩÂ∫¶ÁöÑ50%Ôºâ
                        const avgWidth = (element.width + colElement.width) / 2;
                        const xDistance = Math.min(
                            Math.abs(element.x - (colElement.x + colElement.width)),
                            Math.abs(colElement.x - (element.x + element.width))
                        );
                        const xClose = xDistance <= avgWidth * 0.5;

                        return xOverlap || xClose;
                    });

                    if (canJoinColumn) {
                        currentColumn.push(element);
                    } else {
                        columns.push([...currentColumn]);
                        console.log(`  üì¶ ÂÆåÊàêÂàó: [${currentColumn.map(e => e.name).join(', ')}]`);
                        currentColumn = [element];
                    }
                }
            }

            if (currentColumn.length > 0) {
                columns.push(currentColumn);
                console.log(`  üì¶ ÊúÄÂêéÂàó: [${currentColumn.map(e => e.name).join(', ')}]`);
            }

            return columns;
        }

        // üéØ Âú®ÂàóÂÜÖÊô∫ËÉΩÂàÜÁªÑÔºàËÄÉËôë‰∏ä‰∏ãÂ∏ÉÂ±ÄÔºâ
        function groupColumnByRows(columnElements) {
            console.log(`  üîç Âú®ÂàóÂÜÖÊô∫ËÉΩÂàÜÁªÑ: [${columnElements.map(e => e.name).join(', ')}]`);

            // ÊåâYÂùêÊ†áÊéíÂ∫è
            const sortedByY = [...columnElements].sort((a, b) => a.y - b.y);

            // 1. ÂÖàËØÜÂà´Ê∞¥Âπ≥Ë°åÔºàÂêå‰∏ÄYËΩ¥‰ΩçÁΩÆÁöÑÂÖÉÁ¥†Ôºâ
            const horizontalRows = identifyHorizontalRows(sortedByY);

            // 2. ÁÑ∂ÂêéËØÜÂà´ÂûÇÁõ¥ÁªÑÔºà‰∏ä‰∏ãÁõ∏ÈÇªÁöÑÂÖÉÁ¥†Ôºâ
            const finalGroups = [];

            horizontalRows.forEach(row => {
                if (row.length === 1) {
                    // Âçï‰∏™ÂÖÉÁ¥†ÔºåÊ£ÄÊü•ÊòØÂê¶‰∏éÂÖ∂‰ªñÂçï‰∏™ÂÖÉÁ¥†ÂΩ¢ÊàêÂûÇÁõ¥ÁªÑ
                    finalGroups.push(row);
                } else {
                    // Â§ö‰∏™ÂÖÉÁ¥†Âú®Âêå‰∏ÄË°åÔºå‰øùÊåÅ‰∏∫‰∏ÄÁªÑ
                    finalGroups.push(row);
                    console.log(`    üì¶ Ê∞¥Âπ≥Ë°åÁªÑ: [${row.map(e => e.name).join(', ')}]`);
                }
            });

            // 3. ÂêàÂπ∂Áõ∏ÈÇªÁöÑÂçïÂÖÉÁ¥†ÁªÑ‰∏∫ÂûÇÁõ¥ÁªÑ
            const mergedGroups = mergeVerticalGroups(finalGroups);

            return mergedGroups;
        }

        // üéØ ËØÜÂà´Ê∞¥Âπ≥Ë°å
        function identifyHorizontalRows(sortedElements) {
            console.log(`    üîç ËØÜÂà´Ê∞¥Âπ≥Ë°å`);

            const rows = [];
            let currentRow = [];

            for (const element of sortedElements) {
                if (currentRow.length === 0) {
                    currentRow.push(element);
                } else {
                    // Ê£ÄÊü•ÊòØÂê¶‰∏éÂΩìÂâçË°åÊúâYËΩ¥ÈáçÂè†ÔºàÂêå‰∏ÄÊ∞¥Âπ≥Ë°åÔºâ
                    const canJoinRow = currentRow.some(rowElement => {
                        const yOverlap = !(element.y >= rowElement.y + rowElement.height ||
                                         element.y + element.height <= rowElement.y);
                        return yOverlap;
                    });

                    if (canJoinRow) {
                        currentRow.push(element);
                        console.log(`      ‚û°Ô∏è Ê∑ªÂä†Âà∞Ê∞¥Âπ≥Ë°å: ${element.name}`);
                    } else {
                        rows.push([...currentRow]);
                        console.log(`      üì¶ ÂÆåÊàêÊ∞¥Âπ≥Ë°å: [${currentRow.map(e => e.name).join(', ')}]`);
                        currentRow = [element];
                    }
                }
            }

            if (currentRow.length > 0) {
                rows.push(currentRow);
                console.log(`      üì¶ ÊúÄÂêéÊ∞¥Âπ≥Ë°å: [${currentRow.map(e => e.name).join(', ')}]`);
            }

            return rows;
        }

        // üéØ ÂêàÂπ∂ÂûÇÁõ¥Áõ∏ÈÇªÁöÑÂçïÂÖÉÁ¥†ÁªÑ
        function mergeVerticalGroups(groups) {
            console.log(`    üîç ÂêàÂπ∂ÂûÇÁõ¥ÁªÑ`);

            const result = [];
            let i = 0;

            while (i < groups.length) {
                const currentGroup = groups[i];

                if (currentGroup.length === 1) {
                    // ÂçïÂÖÉÁ¥†ÁªÑÔºåÊ£ÄÊü•ÊòØÂê¶ÂèØ‰ª•‰∏é‰∏ã‰∏Ä‰∏™ÂçïÂÖÉÁ¥†ÁªÑÂêàÂπ∂
                    const verticalGroup = [currentGroup[0]];
                    let j = i + 1;

                    while (j < groups.length && groups[j].length === 1) {
                        const nextElement = groups[j][0];
                        const lastElement = verticalGroup[verticalGroup.length - 1];

                        // Ê£ÄÊü•ÊòØÂê¶ÂûÇÁõ¥Áõ∏ÈÇª
                        const yGap = nextElement.y - (lastElement.y + lastElement.height);
                        const avgHeight = (nextElement.height + lastElement.height) / 2;

                        if (yGap <= avgHeight * 0.5) { // ÂûÇÁõ¥Èó¥Ë∑ùÂ∞è‰∫éÂπ≥ÂùáÈ´òÂ∫¶ÁöÑ50%
                            verticalGroup.push(nextElement);
                            console.log(`      ‚¨áÔ∏è ÂêàÂπ∂ÂûÇÁõ¥ÂÖÉÁ¥†: ${nextElement.name}`);
                            j++;
                        } else {
                            break;
                        }
                    }

                    result.push(verticalGroup);
                    if (verticalGroup.length > 1) {
                        console.log(`    üì¶ ÂûÇÁõ¥ÁªÑ: [${verticalGroup.map(e => e.name).join(', ')}]`);
                    }
                    i = j;
                } else {
                    // Â§öÂÖÉÁ¥†ÁªÑÔºåÁõ¥Êé•Ê∑ªÂä†
                    result.push(currentGroup);
                    i++;
                }
            }

            return result;
        }

        // üéØ ÊûÑÂª∫Â∞ÑÁ∫øÂÖ≥Á≥ª
        function buildRayRelations(elements) {
            console.log(`\nüîç ÊûÑÂª∫Â∞ÑÁ∫øÂÖ≥Á≥ª`);
            const relations = new Map();

            elements.forEach(element => {
                const rays = {
                    left: [],    // Â∑¶Â∞ÑÁ∫øËÉΩÂà∞ËææÁöÑÂÖÉÁ¥†
                    right: [],   // Âè≥Â∞ÑÁ∫øËÉΩÂà∞ËææÁöÑÂÖÉÁ¥†
                    up: [],      // ‰∏äÂ∞ÑÁ∫øËÉΩÂà∞ËææÁöÑÂÖÉÁ¥†
                    down: []     // ‰∏ãÂ∞ÑÁ∫øËÉΩÂà∞ËææÁöÑÂÖÉÁ¥†
                };

                // Ê£ÄÊü•ÊØè‰∏™ÊñπÂêëÁöÑÂ∞ÑÁ∫ø
                elements.forEach(other => {
                    if (other.id === element.id) return;

                    const rayHit = checkRayHit(element, other);
                    if (rayHit.direction) {
                        rays[rayHit.direction].push(other);
                    }
                });

                relations.set(element.id, rays);
                console.log(`  ${element.name} Â∞ÑÁ∫øÂÖ≥Á≥ª:`, {
                    left: rays.left.map(e => e.name),
                    right: rays.right.map(e => e.name),
                    up: rays.up.map(e => e.name),
                    down: rays.down.map(e => e.name)
                });
            });

            return relations;
        }

        // üéØ Ê£ÄÊü•Â∞ÑÁ∫øÊòØÂê¶Âáª‰∏≠ÁõÆÊ†áÂÖÉÁ¥†
        function checkRayHit(source, target) {
            const sourceCenter = {
                x: source.x + source.width / 2,
                y: source.y + source.height / 2
            };
            const targetCenter = {
                x: target.x + target.width / 2,
                y: target.y + target.height / 2
            };

            // Ê£ÄÊü•ÊòØÂê¶Âú®Âêå‰∏ÄË°åÔºàÊ∞¥Âπ≥Â∞ÑÁ∫øÔºâ
            const verticalOverlap = !(
                source.y + source.height <= target.y ||
                target.y + target.height <= source.y
            );

            // Ê£ÄÊü•ÊòØÂê¶Âú®Âêå‰∏ÄÂàóÔºàÂûÇÁõ¥Â∞ÑÁ∫øÔºâ
            const horizontalOverlap = !(
                source.x + source.width <= target.x ||
                target.x + target.width <= source.x
            );

            if (verticalOverlap) {
                // Ê∞¥Âπ≥Â∞ÑÁ∫ø
                if (targetCenter.x > sourceCenter.x) {
                    return { direction: 'right', distance: targetCenter.x - sourceCenter.x };
                } else if (targetCenter.x < sourceCenter.x) {
                    return { direction: 'left', distance: sourceCenter.x - targetCenter.x };
                }
            }

            if (horizontalOverlap) {
                // ÂûÇÁõ¥Â∞ÑÁ∫ø
                if (targetCenter.y > sourceCenter.y) {
                    return { direction: 'down', distance: targetCenter.y - sourceCenter.y };
                } else if (targetCenter.y < sourceCenter.y) {
                    return { direction: 'up', distance: sourceCenter.y - targetCenter.y };
                }
            }

            return { direction: null };
        }

        // üéØ ÊâæÂà∞Â∞ÑÁ∫øËøûÊé•ÁöÑÂàÜÁªÑ
        function findRayConnectedGroup(startElement, allElements, rayRelations, processed) {
            const group = [startElement];
            console.log(`\nüîç ‰ªé "${startElement.name}" ÂºÄÂßãÂØªÊâæÂ∞ÑÁ∫øËøûÊé•ÂàÜÁªÑ`);

            // ‰ΩøÁî®ÂπøÂ∫¶‰ºòÂÖàÊêúÁ¥¢ÔºåÈÄöËøáÂ∞ÑÁ∫øÂÖ≥Á≥ªËøûÊé•ÂÖÉÁ¥†
            const queue = [startElement];
            const inGroup = new Set([startElement.id]);

            while (queue.length > 0) {
                const current = queue.shift();
                const rays = rayRelations.get(current.id);

                if (!rays) continue;

                // Ê£ÄÊü•ÊâÄÊúâÊñπÂêëÁöÑÂ∞ÑÁ∫øËøûÊé•
                ['left', 'right', 'up', 'down'].forEach(direction => {
                    rays[direction].forEach(neighbor => {
                        if (processed.has(neighbor.id) || inGroup.has(neighbor.id)) return;

                        // Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•Âä†ÂÖ•ÂàÜÁªÑ
                        if (shouldJoinRayGroup(current, neighbor, direction, allElements)) {
                            group.push(neighbor);
                            queue.push(neighbor);
                            inGroup.add(neighbor.id);
                            console.log(`  ‚úÖ ÈÄöËøá${direction}Â∞ÑÁ∫øÊ∑ªÂä†: ${neighbor.name}`);
                        }
                    });
                });
            }

            return group;
        }

        // üéØ Âà§Êñ≠ÊòØÂê¶Â∫îËØ•ÈÄöËøáÂ∞ÑÁ∫øÂä†ÂÖ•ÂàÜÁªÑ
        function shouldJoinRayGroup(source, target, direction, allElements) {
            // 1. Ê£ÄÊü•Â∞ÑÁ∫øË∑ØÂæÑÊòØÂê¶Ë¢´ÈòªÊå°
            if (isRayBlocked(source, target, direction, allElements)) {
                console.log(`    üö´ ${direction}Â∞ÑÁ∫øË¢´ÈòªÊå°Ôºå‰∏çËÉΩÂàÜÁªÑ`);
                return false;
            }

            // 2. Ê£ÄÊü•Ë∑ùÁ¶ªÊòØÂê¶ÂêàÁêÜ
            const distance = calculateMinDistance(source, target);
            const avgSize = (source.width + source.height + target.width + target.height) / 4;

            if (distance > avgSize * 2) {
                console.log(`    üìè Â∞ÑÁ∫øË∑ùÁ¶ªËøáËøú: ${distance} > ${avgSize * 2}`);
                return false;
            }

            return true;
        }

        // üéØ Ê£ÄÊü•Â∞ÑÁ∫øÊòØÂê¶Ë¢´ÈòªÊå°
        function isRayBlocked(source, target, direction, allElements) {
            const sourceCenter = {
                x: source.x + source.width / 2,
                y: source.y + source.height / 2
            };
            const targetCenter = {
                x: target.x + target.width / 2,
                y: target.y + target.height / 2
            };

            // Ê†πÊçÆÊñπÂêëÂàõÂª∫Â∞ÑÁ∫øË∑ØÂæÑ
            let rayPath;
            if (direction === 'left' || direction === 'right') {
                // Ê∞¥Âπ≥Â∞ÑÁ∫ø
                rayPath = {
                    x1: Math.min(sourceCenter.x, targetCenter.x),
                    x2: Math.max(sourceCenter.x, targetCenter.x),
                    y1: Math.min(source.y, target.y),
                    y2: Math.max(source.y + source.height, target.y + target.height)
                };
            } else {
                // ÂûÇÁõ¥Â∞ÑÁ∫ø
                rayPath = {
                    x1: Math.min(source.x, target.x),
                    x2: Math.max(source.x + source.width, target.x + target.width),
                    y1: Math.min(sourceCenter.y, targetCenter.y),
                    y2: Math.max(sourceCenter.y, targetCenter.y)
                };
            }

            // Ê£ÄÊü•ÊòØÂê¶ÊúâÂÖ∂‰ªñÂÖÉÁ¥†ÈòªÊå°Â∞ÑÁ∫øË∑ØÂæÑ
            for (const other of allElements) {
                if (other.id === source.id || other.id === target.id) continue;

                // Ê£ÄÊü•ÂÖ∂‰ªñÂÖÉÁ¥†ÊòØÂê¶‰∏éÂ∞ÑÁ∫øË∑ØÂæÑÁõ∏‰∫§
                const intersects = !(
                    other.x + other.width <= rayPath.x1 ||
                    other.x >= rayPath.x2 ||
                    other.y + other.height <= rayPath.y1 ||
                    other.y >= rayPath.y2
                );

                if (intersects) {
                    console.log(`      üö´ "${other.name}" ÈòªÊå°‰∫Ü${direction}Â∞ÑÁ∫ø`);
                    return true;
                }
            }

            return false;
        }

        // üéØ ÊâæÂà∞Á©∫Èó¥Áõ∏ÂÖ≥ÁöÑÂàÜÁªÑÔºà‰øÆÂ§çÁâàÊú¨Ôºâ
        function findSpatialGroup(startElement, allElements, processed) {
            const group = [startElement];
            console.log(`\nüîç ‰ªé "${startElement.name}" ÂºÄÂßãÂØªÊâæÁ©∫Èó¥ÂàÜÁªÑ`);

            // ‰ΩøÁî®Ëø≠‰ª£ÊñπÂºèÔºåÊØèÊ¨°Ê∑ªÂä†Êñ∞ÂÖÉÁ¥†ÂêéÈáçÊñ∞Ê£ÄÊü•
            let changed = true;
            while (changed) {
                changed = false;

                for (const candidate of allElements) {
                    if (processed.has(candidate.id) || group.some(g => g.id === candidate.id)) continue;

                    // Ê£ÄÊü•ÂÄôÈÄâÂÖÉÁ¥†ÊòØÂê¶‰∏éÁªÑÂÜÖ‰ªª‰ΩïÂÖÉÁ¥†Áõ∏ÈÇª
                    const canJoinGroup = group.some(groupMember => {
                        return shouldJoinSpatialGroup(groupMember, candidate, allElements);
                    });

                    if (canJoinGroup) {
                        group.push(candidate);
                        console.log(`  ‚úÖ Ê∑ªÂä†Âà∞ÂàÜÁªÑ: ${candidate.name}`);
                        changed = true; // ÊúâÊñ∞ÂÖÉÁ¥†Âä†ÂÖ•ÔºåÈúÄË¶ÅÈáçÊñ∞Ê£ÄÊü•
                    }
                }
            }

            return group;
        }

        // üéØ Âü∫‰∫éÊà™Êñ≠Ê£ÄÊµãÁöÑÂàÜÁªÑÂà§Êñ≠ÔºàÊó†ÈòàÂÄºÁâàÊú¨Ôºâ
        function shouldJoinSpatialGroup(anchor, candidate, allElements) {
            console.log(`    üîç Ê£ÄÊü• "${candidate.name}" ÊòØÂê¶ÂèØ‰ª•‰∏é "${anchor.name}" ÂàÜÁªÑ`);
            console.log(`      ÈîöÁÇπ: (${anchor.x},${anchor.y},${anchor.width}√ó${anchor.height})`);
            console.log(`      ÂÄôÈÄâ: (${candidate.x},${candidate.y},${candidate.width}√ó${candidate.height})`);

            // 1. Ê£ÄÊü•‰ªéanchorÂà∞candidateÁöÑË∑ØÂæÑÊòØÂê¶Ë¢´Êà™Êñ≠
            const isBlocked = isPathBlocked(anchor, candidate, allElements);

            if (isBlocked) {
                console.log(`    üö´ "${candidate.name}" Ë¢´ÂÖ∂‰ªñÂÖÉÁ¥†Êà™Êñ≠ÔºåÊó†Ê≥ï‰∏é "${anchor.name}" ÂàÜÁªÑ`);
                return false;
            }

            console.log(`    ‚úÖ "${candidate.name}" ÂèØ‰ª•‰∏é "${anchor.name}" ÂàÜÁªÑÔºàÊó†Êà™Êñ≠Ôºâ`);
            return true;
        }

        // üéØ Ê£ÄÊü•Ë∑ØÂæÑÊòØÂê¶Ë¢´ÈòªÊå°Ôºà‰øÆÂ§çÁâàÊú¨Ôºâ
        function isPathBlocked(elem1, elem2, allElements) {
            // 1. È¶ñÂÖàÊ£ÄÊü•Âü∫Êú¨Ë∑ùÁ¶ª - Â¶ÇÊûúË∑ùÁ¶ªÂ§™ËøúÔºåÁõ¥Êé•ËÆ§‰∏∫Ë¢´"ËôöÊãüÈòªÊå°"
            const distance = calculateMinDistance(elem1, elem2);
            const avgSize = (elem1.width + elem1.height + elem2.width + elem2.height) / 4;

            // Â¶ÇÊûúË∑ùÁ¶ªË∂ÖËøáÂπ≥ÂùáÂ∞∫ÂØ∏ÁöÑ1.5ÂÄçÔºåËÆ§‰∏∫Ë¢´ÈòªÊå°
            if (distance > avgSize * 1.5) {
                console.log(`      üìè Ë∑ùÁ¶ªËøáËøúË¢´ËßÜ‰∏∫ÈòªÊå°: ${distance} > ${avgSize * 1.5}`);
                return true;
            }

            // 2. Ê£ÄÊü•YÂùêÊ†áÂ∑ÆË∑ù - Èò≤Ê≠¢Ë∑®Ë°åÂàÜÁªÑ
            const yGap = Math.abs(elem1.y - elem2.y);
            const maxHeight = Math.max(elem1.height, elem2.height);

            if (yGap > maxHeight * 0.8) {
                console.log(`      üìê YÂùêÊ†áÂ∑ÆË∑ùËøáÂ§ßË¢´ËßÜ‰∏∫ÈòªÊå°: ${yGap} > ${maxHeight * 0.8}`);
                return true;
            }

            // 3. Ê£ÄÊü•ÂÆûÈôÖÁöÑÁâ©ÁêÜÈòªÊå°
            const connectionRect = {
                left: Math.min(elem1.x, elem2.x),
                right: Math.max(elem1.x + elem1.width, elem2.x + elem2.width),
                top: Math.min(elem1.y, elem2.y),
                bottom: Math.max(elem1.y + elem1.height, elem2.y + elem2.height)
            };

            console.log(`      ËøûÊé•Âå∫Âüü: (${connectionRect.left},${connectionRect.top}) Âà∞ (${connectionRect.right},${connectionRect.bottom})`);

            // Ê£ÄÊü•ÊòØÂê¶ÊúâÂÖ∂‰ªñÂÖÉÁ¥†Âú®ËøûÊé•Ë∑ØÂæÑ‰∏ä
            for (const other of allElements) {
                if (other.id === elem1.id || other.id === elem2.id) continue;

                // Ê£ÄÊü•ÂÖ∂‰ªñÂÖÉÁ¥†ÊòØÂê¶‰∏éËøûÊé•Âå∫ÂüüÈáçÂè†
                const otherRect = {
                    left: other.x,
                    right: other.x + other.width,
                    top: other.y,
                    bottom: other.y + other.height
                };

                // Ê£ÄÊü•ÈáçÂè†
                const overlaps = !(
                    otherRect.right <= connectionRect.left ||
                    otherRect.left >= connectionRect.right ||
                    otherRect.bottom <= connectionRect.top ||
                    otherRect.top >= connectionRect.bottom
                );

                if (overlaps) {
                    // Ëøõ‰∏ÄÊ≠•Ê£ÄÊü•ÊòØÂê¶ÁúüÁöÑÈòªÊå°‰∫ÜËøûÊé•
                    if (isReallyBlocking(elem1, elem2, other)) {
                        console.log(`      üö´ "${other.name}" Áâ©ÁêÜÈòªÊå°‰∫ÜËøûÊé•`);
                        return true;
                    }
                }
            }

            return false;
        }

        // üéØ Ê£ÄÊü•ÂÖÉÁ¥†ÊòØÂê¶ÁúüÁöÑÈòªÊå°ËøûÊé•
        function isReallyBlocking(elem1, elem2, blocker) {
            // Ê£ÄÊü•ÈòªÊå°ÂÖÉÁ¥†ÊòØÂê¶Âú®‰∏§‰∏™ÂÖÉÁ¥†ÁöÑËøûÊé•Ë∑ØÂæÑÁöÑÂÖ≥ÈîÆÂå∫Âüü
            const elem1Center = { x: elem1.x + elem1.width / 2, y: elem1.y + elem1.height / 2 };
            const elem2Center = { x: elem2.x + elem2.width / 2, y: elem2.y + elem2.height / 2 };
            const blockerCenter = { x: blocker.x + blocker.width / 2, y: blocker.y + blocker.height / 2 };

            // ÁÆÄÂåñÁâàÊú¨ÔºöÂ¶ÇÊûúÈòªÊå°ÂÖÉÁ¥†ÁöÑ‰∏≠ÂøÉÂú®‰∏§‰∏™ÂÖÉÁ¥†ÁöÑËæπÁïåÊ°ÜÂÜÖÔºåÂàôËÆ§‰∏∫ÈòªÊå°
            const minX = Math.min(elem1.x, elem2.x);
            const maxX = Math.max(elem1.x + elem1.width, elem2.x + elem2.width);
            const minY = Math.min(elem1.y, elem2.y);
            const maxY = Math.max(elem1.y + elem1.height, elem2.y + elem2.height);

            const isInPath = (
                blockerCenter.x >= minX && blockerCenter.x <= maxX &&
                blockerCenter.y >= minY && blockerCenter.y <= maxY
            );

            return isInPath;
        }

        // üéØ Ê£ÄÊü•Á©∫Èó¥ÂÖ≥Á≥ªÊòØÂê¶ÂêàÁêÜ
        function checkSpatialRelationship(elem1, elem2) {
            // Ê£ÄÊü•ÊòØÂê¶Âú®ÂêàÁêÜÁöÑÁõ∏ÂØπ‰ΩçÁΩÆ
            const xOverlap = !(elem1.x + elem1.width <= elem2.x || elem2.x + elem2.width <= elem1.x);
            const yOverlap = !(elem1.y + elem1.height <= elem2.y || elem2.y + elem2.height <= elem1.y);

            // Â¶ÇÊûúÊúâÈáçÂè†ÔºåÊàñËÄÖÂú®ÂêàÁêÜÁöÑÈÇªËøë‰ΩçÁΩÆÔºåÂàôËÆ§‰∏∫ÂêàÁêÜ
            if (xOverlap || yOverlap) {
                return true;
            }

            // Ê£ÄÊü•ÊòØÂê¶Âú®ÂêàÁêÜÁöÑÈÇªËøë‰ΩçÁΩÆÔºàÊ®™ÂêëÊàñÁ∫µÂêëÂØπÈΩêÔºâ
            const horizontallyAligned = Math.abs(elem1.y - elem2.y) <= Math.max(elem1.height, elem2.height) * 0.5;
            const verticallyAligned = Math.abs(elem1.x - elem2.x) <= Math.max(elem1.width, elem2.width) * 0.5;

            return horizontallyAligned || verticallyAligned;
        }

        // üéØ ÊâæÂà∞Á¥ßÈÇªÁöÑÂÖÉÁ¥†ÔºàË∂Ö‰∏•Ê†ºÁâàÊú¨Ôºâ
        function findImmediateNeighbors(startElement, allElements, processed) {
            const group = [startElement];

            console.log(`\nüîç ‰ªé "${startElement.name}" ÂºÄÂßãÂØªÊâæÁ¥ßÈÇªÂÖÉÁ¥†`);

            // Âè™Êü•ÊâæÁúüÊ≠£Á¥ßÈÇªÁöÑÂÖÉÁ¥†
            for (const candidate of allElements) {
                if (processed.has(candidate.id) || candidate.id === startElement.id) continue;

                // Ê£ÄÊü•ÊòØÂê¶‰∏éÂΩìÂâçÁªÑ‰∏≠ÁöÑ‰ªª‰ΩïÂÖÉÁ¥†Á¥ßÈÇª
                const isNeighbor = group.some(groupMember => {
                    return areImmediateNeighbors(groupMember, candidate);
                });

                if (isNeighbor) {
                    group.push(candidate);
                    console.log(`  ‚úÖ Ê∑ªÂä†Á¥ßÈÇªÂÖÉÁ¥†: ${candidate.name}`);
                }
            }

            return group;
        }

        // üéØ Ê£ÄÊü•‰∏§‰∏™ÂÖÉÁ¥†ÊòØÂê¶Á¥ßÈÇªÔºàË∂Ö‰∏•Ê†ºÊ†áÂáÜÔºâ
        function areImmediateNeighbors(elem1, elem2) {
            // 1. YÂùêÊ†áÂøÖÈ°ªÈùûÂ∏∏Êé•ËøëÔºàÂêå‰∏ÄË°åÔºâ
            const yDiff = Math.abs(elem1.y - elem2.y);
            const maxHeight = Math.max(elem1.height, elem2.height);

            if (yDiff > maxHeight * 0.1) { // YÂùêÊ†áÂ∑ÆË∑ù‰∏çËÉΩË∂ÖËøáÊúÄÂ§ßÈ´òÂ∫¶ÁöÑ10%
                return false;
            }

            // 2. XÂùêÊ†áÂøÖÈ°ªÁ¥ßÈÇªÔºàÈó¥ÈöôÂæàÂ∞èÔºâ
            const distance = calculateMinDistance(elem1, elem2);
            const minWidth = Math.min(elem1.width, elem2.width);

            // Èó¥Èöô‰∏çËÉΩË∂ÖËøáÊúÄÂ∞èÂÆΩÂ∫¶ÁöÑ20%
            if (distance > minWidth * 0.2) {
                console.log(`    üìè "${elem1.name}" ‰∏é "${elem2.name}" Ë∑ùÁ¶ªËøáËøú: ${distance} > ${minWidth * 0.2}`);
                return false;
            }

            console.log(`    ‚úÖ "${elem1.name}" ‰∏é "${elem2.name}" ÊòØÁ¥ßÈÇªÂÖÉÁ¥†`);
            return true;
        }

        // üéØ ËØÜÂà´Ë°åÔºàÂü∫‰∫éYÂùêÊ†áÂíåÈáçÂè†Ôºâ
        function identifyRowsWithGaps(elements) {
            const sortedByY = [...elements].sort((a, b) => a.y - b.y);
            const rows = [];
            let currentRow = [];

            for (const element of sortedByY) {
                if (currentRow.length === 0) {
                    currentRow.push(element);
                } else {
                    // Ê£ÄÊü•ÊòØÂê¶‰∏éÂΩìÂâçË°åÊúâYËΩ¥ÈáçÂè†ÊàñÊé•ËøëÔºàÊõ¥‰∏•Ê†ºÔºâ
                    const canJoinRow = currentRow.some(rowElement => {
                        const yOverlap = !(element.y >= rowElement.y + rowElement.height ||
                                         element.y + element.height <= rowElement.y);
                        const avgHeight = (element.height + rowElement.height) / 2;
                        const yClose = Math.abs(element.y - rowElement.y) <= avgHeight * 0.2; // Âπ≥ÂùáÈ´òÂ∫¶ÁöÑ20%ÂÆπÂ∑Æ
                        return yOverlap || yClose;
                    });

                    if (canJoinRow) {
                        currentRow.push(element);
                    } else {
                        rows.push([...currentRow]);
                        currentRow = [element];
                    }
                }
            }

            if (currentRow.length > 0) {
                rows.push(currentRow);
            }

            return rows;
        }

        // üéØ Âú®Ë°åÂÜÖÊåâÈó¥ÈöôÂàÜÁªÑ
        function groupRowByGaps(rowElements) {
            const sortedByX = [...rowElements].sort((a, b) => a.x - b.x);
            const groups = [];
            let currentGroup = [];

            console.log(`  üîç ÂàÜÊûêË°åÂÜÖÈó¥Èöô: [${sortedByX.map(e => e.name).join(', ')}]`);

            for (let i = 0; i < sortedByX.length; i++) {
                const element = sortedByX[i];

                if (currentGroup.length === 0) {
                    currentGroup.push(element);
                } else {
                    const lastElement = currentGroup[currentGroup.length - 1];
                    const gap = element.x - (lastElement.x + lastElement.width);

                    // ËÆ°ÁÆó‰∏•Ê†ºÁöÑÈó¥ÈöôÈòàÂÄº
                    const minWidth = Math.min(lastElement.width, element.width);
                    const gapThreshold = minWidth * 0.3; // Èó¥ÈöôË∂ÖËøáÊúÄÂ∞èÂÆΩÂ∫¶ÁöÑ30%Â∞±ÂàÜÁªÑ

                    console.log(`    üìè "${lastElement.name}" Âà∞ "${element.name}" Èó¥Èöô: ${gap}, ÈòàÂÄº: ${gapThreshold}`);

                    if (gap <= gapThreshold) {
                        currentGroup.push(element);
                        console.log(`    ‚û°Ô∏è ÁªßÁª≠ÂΩìÂâçÁªÑ`);
                    } else {
                        groups.push([...currentGroup]);
                        console.log(`    üì¶ ÂÆåÊàêÂàÜÁªÑ: [${currentGroup.map(e => e.name).join(', ')}]`);
                        currentGroup = [element];
                        console.log(`    üÜï ÂºÄÂßãÊñ∞ÁªÑ`);
                    }
                }
            }

            if (currentGroup.length > 0) {
                groups.push(currentGroup);
                console.log(`    üì¶ ÊúÄÂêéÂàÜÁªÑ: [${currentGroup.map(e => e.name).join(', ')}]`);
            }

            return groups;
        }











        // üéØ Ê£ÄÊü•‰∏§‰∏™ÂÖÉÁ¥†ÁöÑËøûÊé•ÊòØÂê¶Ë¢´Êà™Êñ≠
        function isConnectionTruncated(elem1, elem2, allElements, currentGroup) {
            // ËÆ°ÁÆóËøûÊé•Âå∫Âüü
            const connectionBounds = {
                left: Math.min(elem1.x, elem2.x),
                right: Math.max(elem1.x + elem1.width, elem2.x + elem2.width),
                top: Math.min(elem1.y, elem2.y),
                bottom: Math.max(elem1.y + elem1.height, elem2.y + elem2.height)
            };

            // Ê£ÄÊü•ÊòØÂê¶ÊúâÂÖ∂‰ªñÂÖÉÁ¥†Êà™Êñ≠Ëøô‰∏™ËøûÊé•
            for (const other of allElements) {
                if (other.id === elem1.id || other.id === elem2.id || currentGroup.has(other.id)) {
                    continue;
                }

                // Ê£ÄÊü•ÂÖ∂‰ªñÂÖÉÁ¥†ÊòØÂê¶Âú®ËøûÊé•Ë∑ØÂæÑ‰∏ä
                if (isElementBlockingConnection(other, elem1, elem2, connectionBounds)) {
                    return true;
                }
            }

            return false;
        }

        // üéØ Ê£ÄÊü•ÂÖÉÁ¥†ÊòØÂê¶ÈòªÊå°ËøûÊé•
        function isElementBlockingConnection(blockingElement, elem1, elem2, connectionBounds) {
            const blocker = {
                left: blockingElement.x,
                right: blockingElement.x + blockingElement.width,
                top: blockingElement.y,
                bottom: blockingElement.y + blockingElement.height
            };

            // Ê£ÄÊü•ÊòØÂê¶‰∏éËøûÊé•Âå∫ÂüüÈáçÂè†
            const overlaps = !(
                blocker.right <= connectionBounds.left ||
                blocker.left >= connectionBounds.right ||
                blocker.bottom <= connectionBounds.top ||
                blocker.top >= connectionBounds.bottom
            );

            if (!overlaps) return false;

            // Ê£ÄÊü•ÊòØÂê¶ÁúüÁöÑÂú®ËøûÊé•Ë∑ØÂæÑ‰∏äÔºàÁÆÄÂåñÁâàÊú¨Ôºâ
            const isInPath = (
                (blocker.left < connectionBounds.right && blocker.right > connectionBounds.left) &&
                (blocker.top < connectionBounds.bottom && blocker.bottom > connectionBounds.top)
            );

            return isInPath;
        }

        // üéØ ÂàõÂª∫ÂàÜÁªÑÊìç‰ΩúÊèèËø∞
        function createGroupingOperation(candidate, index) {
            const bounds = calculateBounds(candidate.children);
            const direction = determineGroupDirection(candidate.children);
            const parentName = generateGroupName(candidate.children, candidate.type, index);

            return {
                id: `group_${index}`,
                parentName: parentName,
                children: candidate.children,
                reason: candidate.reason,
                direction: direction,
                bounds: bounds,
                type: candidate.type
            };
        }

        // üéØ ÁîüÊàêÂàÜÁªÑÂêçÁß∞
        function generateGroupName(children, type, index) {
            if (children.length === 1) {
                return children[0].name;
            }

            // Ê†πÊçÆÂ≠êÂÖÉÁ¥†ÁîüÊàêÊúâÊÑè‰πâÁöÑÂêçÁß∞
            if (children.length <= 3) {
                return children.map(c => c.name).join(' + ');
            } else {
                return `${children[0].name} + ${children[1].name} + ${children.length - 2} È°π`;
            }
        }

        // üéØ Á°ÆÂÆöÂàÜÁªÑÊñπÂêë
        function determineGroupDirection(elements) {
            if (elements.length <= 1) return 'NONE';

            // ËÆ°ÁÆóÂÖÉÁ¥†ÂàÜÂ∏É
            const xPositions = elements.map(e => e.x);
            const yPositions = elements.map(e => e.y);
            const xRange = Math.max(...xPositions) - Math.min(...xPositions);
            const yRange = Math.max(...yPositions) - Math.min(...yPositions);

            // ËÆ°ÁÆóÂπ≥ÂùáÂ∞∫ÂØ∏
            const avgWidth = elements.reduce((sum, e) => sum + e.width, 0) / elements.length;
            const avgHeight = elements.reduce((sum, e) => sum + e.height, 0) / elements.length;

            if (xRange > avgWidth && xRange > yRange) {
                return 'HORIZONTAL';
            } else if (yRange > avgHeight && yRange > xRange) {
                return 'VERTICAL';
            } else {
                return 'MIXED';
            }
        }

        // üéØ ÊâßË°åÂàÜÁªÑÊìç‰Ωú
        function executeGroupingOperations(operations, originalElements) {
            console.log(`\nüîß ÊâßË°åÂàÜÁªÑÊìç‰Ωú:`);

            const groups = [];

            operations.forEach((operation, index) => {
                console.log(`\nÊâßË°åÊìç‰Ωú ${index + 1}: ÂàõÂª∫ÂàÜÁªÑ "${operation.parentName}"`);
                console.log(`   ÂåÖÂê´ÂÖÉÁ¥†: ${operation.children.map(c => c.name).join(', ')}`);
                console.log(`   Â∏ÉÂ±ÄÊñπÂêë: ${operation.direction}`);

                groups.push(operation.children);
            });

            return groups;
        }



        // üéØ Âú®ËøûÁª≠Âå∫ÂüüÂÜÖËøõË°åÂàÜÁªÑ
        function groupElementsInRegion(regionElements, threshold) {
            if (regionElements.length === 1) {
                return [regionElements];
            }

            console.log(`üîÑ Âú®Âå∫ÂüüÂÜÖÂàÜÁªÑ ${regionElements.length} ‰∏™ÂÖÉÁ¥†`);

            // ÂàÜÊûêÂå∫ÂüüÂÜÖÂÖÉÁ¥†ÁöÑÂ∏ÉÂ±ÄÁâπÂæÅ
            const layoutAnalysis = analyzeRegionLayout(regionElements);
            console.log(`üìä Â∏ÉÂ±ÄÂàÜÊûê:`, layoutAnalysis);

            // Ê†πÊçÆÂ∏ÉÂ±ÄÁâπÂæÅÈÄâÊã©ÂàÜÁªÑÁ≠ñÁï•
            if (layoutAnalysis.isPrimaryHorizontal) {
                console.log(`‚û°Ô∏è ‰∏ªË¶ÅÊòØÊ®™ÂêëÂ∏ÉÂ±ÄÔºå‰ΩøÁî®Ê®™ÂêëÂàÜÁªÑ`);
                return groupRegionHorizontally(regionElements, threshold);
            } else if (layoutAnalysis.isPrimaryVertical) {
                console.log(`‚¨áÔ∏è ‰∏ªË¶ÅÊòØÁ∫µÂêëÂ∏ÉÂ±ÄÔºå‰ΩøÁî®Á∫µÂêëÂàÜÁªÑ`);
                return groupRegionVertically(regionElements, threshold);
            } else {
                console.log(`üîÑ Ê∑∑ÂêàÂ∏ÉÂ±ÄÔºå‰ΩøÁî®Ê∑∑ÂêàÂàÜÁªÑÁ≠ñÁï•`);
                return groupRegionMixed(regionElements, threshold);
            }
        }

        // üéØ ÂàÜÊûêÂå∫ÂüüÂÜÖÁöÑÂ∏ÉÂ±ÄÁâπÂæÅ
        function analyzeRegionLayout(elements) {
            if (elements.length <= 1) {
                return { isPrimaryHorizontal: false, isPrimaryVertical: false, isMixed: false };
            }

            // ËÆ°ÁÆóÂÖÉÁ¥†ÁöÑÂàÜÂ∏ÉËåÉÂõ¥
            const xPositions = elements.map(e => e.x);
            const yPositions = elements.map(e => e.y);
            const widths = elements.map(e => e.width);
            const heights = elements.map(e => e.height);

            const xRange = Math.max(...xPositions) - Math.min(...xPositions);
            const yRange = Math.max(...yPositions) - Math.min(...yPositions);
            const avgWidth = widths.reduce((sum, w) => sum + w, 0) / widths.length;
            const avgHeight = heights.reduce((sum, h) => sum + h, 0) / heights.length;

            // Âà§Êñ≠‰∏ªË¶ÅÂ∏ÉÂ±ÄÊñπÂêë
            const isPrimaryHorizontal = xRange > avgWidth && xRange > yRange;
            const isPrimaryVertical = yRange > avgHeight && yRange > xRange;
            const isMixed = !isPrimaryHorizontal && !isPrimaryVertical;

            return {
                isPrimaryHorizontal,
                isPrimaryVertical,
                isMixed,
                xRange,
                yRange,
                avgWidth,
                avgHeight
            };
        }

        // üéØ Ê®™ÂêëÂàÜÁªÑÁ≠ñÁï•
        function groupRegionHorizontally(elements, threshold) {
            // ÂÖàÊåâË°åÂàÜÁªÑ
            const rows = identifyRowsByAlignment(elements, threshold);
            const groups = [];

            rows.forEach(row => {
                if (row.length === 1) {
                    groups.push(row);
                } else {
                    // Ë°åÂÜÖÊåâXÂùêÊ†áÂíåÈó¥Ë∑ùÂàÜÁªÑ
                    const rowGroups = groupBySpacing(row, threshold, 'horizontal');
                    groups.push(...rowGroups);
                }
            });

            return groups;
        }

        // üéØ Á∫µÂêëÂàÜÁªÑÁ≠ñÁï•
        function groupRegionVertically(elements, threshold) {
            // ÂÖàÊåâÂàóÂàÜÁªÑ
            const columns = identifyColumnsByAlignment(elements, threshold);
            const groups = [];

            columns.forEach(column => {
                if (column.length === 1) {
                    groups.push(column);
                } else {
                    // ÂàóÂÜÖÊåâYÂùêÊ†áÂíåÈó¥Ë∑ùÂàÜÁªÑ
                    const columnGroups = groupBySpacing(column, threshold, 'vertical');
                    groups.push(...columnGroups);
                }
            });

            return groups;
        }

        // üéØ Ê∑∑ÂêàÂàÜÁªÑÁ≠ñÁï•ÔºàÂ§ÑÁêÜÂ§çÊùÇÂ∏ÉÂ±ÄÔºâ
        function groupRegionMixed(elements, threshold) {
            // ÂØπ‰∫éÊ∑∑ÂêàÂ∏ÉÂ±ÄÔºåÂ∞ùËØïÊâæÂà∞ÊúÄ‰Ω≥ÁöÑÂàÜÁªÑÁªÑÂêà
            // ËøôÈáåÂÆûÁé∞ÁÆÄÂåñÁâàÊú¨ÔºåÂèØ‰ª•Ê†πÊçÆÈúÄË¶ÅÊâ©Â±ï

            // Â∞ùËØïÊ®™ÂêëÂàÜÁªÑ
            const horizontalGroups = groupRegionHorizontally(elements, threshold);

            // Â∞ùËØïÁ∫µÂêëÂàÜÁªÑ
            const verticalGroups = groupRegionVertically(elements, threshold);

            // ÈÄâÊã©‰∫ßÁîüÊõ¥ÂêàÁêÜÂàÜÁªÑÁöÑÁ≠ñÁï•
            // ÁÆÄÂçïÁ≠ñÁï•ÔºöÈÄâÊã©‰∫ßÁîüËæÉÂ∞ëÂçïÂÖÉÁ¥†ÁªÑÁöÑÊñπÊ°à
            const horizontalSingleCount = horizontalGroups.filter(g => g.length === 1).length;
            const verticalSingleCount = verticalGroups.filter(g => g.length === 1).length;

            if (horizontalSingleCount <= verticalSingleCount) {
                console.log(`üéØ Ê∑∑ÂêàÂ∏ÉÂ±ÄÈÄâÊã©Ê®™ÂêëÂàÜÁªÑ`);
                return horizontalGroups;
            } else {
                console.log(`üéØ Ê∑∑ÂêàÂ∏ÉÂ±ÄÈÄâÊã©Á∫µÂêëÂàÜÁªÑ`);
                return verticalGroups;
            }
        }



        // üéØ ÊåâÂØπÈΩêËØÜÂà´Ë°å
        function identifyRowsByAlignment(elements, threshold) {
            const sortedByY = [...elements].sort((a, b) => a.y - b.y);
            const rows = [];
            let currentRow = [];

            for (const element of sortedByY) {
                if (currentRow.length === 0) {
                    currentRow.push(element);
                } else {
                    // Ê£ÄÊü•ÊòØÂê¶‰∏éÂΩìÂâçË°åÂØπÈΩê
                    const isAligned = currentRow.some(rowElement => {
                        const yOverlap = !(element.y + element.height <= rowElement.y ||
                                         element.y >= rowElement.y + rowElement.height);
                        const yClose = Math.abs(element.y - rowElement.y) <= threshold;
                        return yOverlap || yClose;
                    });

                    if (isAligned) {
                        currentRow.push(element);
                    } else {
                        rows.push([...currentRow]);
                        currentRow = [element];
                    }
                }
            }

            if (currentRow.length > 0) {
                rows.push(currentRow);
            }

            return rows;
        }

        // üéØ ÊåâÂØπÈΩêËØÜÂà´Âàó
        function identifyColumnsByAlignment(elements, threshold) {
            const sortedByX = [...elements].sort((a, b) => a.x - b.x);
            const columns = [];
            let currentColumn = [];

            for (const element of sortedByX) {
                if (currentColumn.length === 0) {
                    currentColumn.push(element);
                } else {
                    // Ê£ÄÊü•ÊòØÂê¶‰∏éÂΩìÂâçÂàóÂØπÈΩê
                    const isAligned = currentColumn.some(colElement => {
                        const xOverlap = !(element.x + element.width <= colElement.x ||
                                         element.x >= colElement.x + colElement.width);
                        const xClose = Math.abs(element.x - colElement.x) <= threshold;
                        return xOverlap || xClose;
                    });

                    if (isAligned) {
                        currentColumn.push(element);
                    } else {
                        columns.push([...currentColumn]);
                        currentColumn = [element];
                    }
                }
            }

            if (currentColumn.length > 0) {
                columns.push(currentColumn);
            }

            return columns;
        }

        // üéØ ÊåâÈó¥Ë∑ùÂàÜÁªÑ
        function groupBySpacing(elements, threshold, direction) {
            const sortKey = direction === 'horizontal' ? 'x' : 'y';
            const sizeKey = direction === 'horizontal' ? 'width' : 'height';

            const sorted = [...elements].sort((a, b) => a[sortKey] - b[sortKey]);
            const groups = [];
            let currentGroup = [];

            for (const element of sorted) {
                if (currentGroup.length === 0) {
                    currentGroup.push(element);
                } else {
                    const lastElement = currentGroup[currentGroup.length - 1];
                    const gap = element[sortKey] - (lastElement[sortKey] + lastElement[sizeKey]);

                    if (gap <= threshold) {
                        currentGroup.push(element);
                    } else {
                        groups.push([...currentGroup]);
                        currentGroup = [element];
                    }
                }
            }

            if (currentGroup.length > 0) {
                groups.push(currentGroup);
            }

            return groups;
        }

        // üéØ ËÆ°ÁÆó‰∏§‰∏™ÂÖÉÁ¥†‰πãÈó¥ÁöÑÊúÄÂ∞èË∑ùÁ¶ª
        function calculateMinDistance(elem1, elem2) {
            const rect1 = {
                left: elem1.x,
                right: elem1.x + elem1.width,
                top: elem1.y,
                bottom: elem1.y + elem1.height
            };

            const rect2 = {
                left: elem2.x,
                right: elem2.x + elem2.width,
                top: elem2.y,
                bottom: elem2.y + elem2.height
            };

            // ËÆ°ÁÆóÁü©ÂΩ¢Èó¥ÁöÑÊúÄÂ∞èË∑ùÁ¶ª
            const xDistance = Math.max(0, Math.max(rect1.left - rect2.right, rect2.left - rect1.right));
            const yDistance = Math.max(0, Math.max(rect1.top - rect2.bottom, rect2.top - rect1.bottom));

            return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
        }





        // Êåâ‰ΩçÁΩÆÂàÜÁªÑÔºàË°åÂàóÂàÜÁªÑÔºâ
        function groupByPosition(elements, threshold) {
            // ÂÖàÊåâË°åÂàÜÁªÑ
            const rows = groupByRows(elements, threshold);

            // ÂÜçÂú®ÊØèË°åÂÜÖÊåâÂàóÂàÜÁªÑ
            const groups = [];
            rows.forEach(row => {
                const cols = groupByColumns(row, threshold);
                groups.push(...cols);
            });

            return groups.filter(group => group.length > 0);
        }

        // ÊåâË°åÂàÜÁªÑ
        function groupByRows(elements, threshold) {
            const sortedByY = [...elements].sort((a, b) => a.y - b.y);
            const rows = [];
            let currentRow = [sortedByY[0]];

            for (let i = 1; i < sortedByY.length; i++) {
                const current = sortedByY[i];
                const previous = sortedByY[i - 1];

                const yGap = current.y - (previous.y + previous.height);

                if (yGap > threshold) {
                    rows.push(currentRow);
                    currentRow = [current];
                } else {
                    currentRow.push(current);
                }
            }

            if (currentRow.length > 0) {
                rows.push(currentRow);
            }

            return rows;
        }

        // ÊåâÂàóÂàÜÁªÑ
        function groupByColumns(elements, threshold) {
            const sortedByX = [...elements].sort((a, b) => a.x - b.x);
            const columns = [];
            let currentColumn = [sortedByX[0]];

            for (let i = 1; i < sortedByX.length; i++) {
                const current = sortedByX[i];
                const previous = sortedByX[i - 1];

                const xGap = current.x - (previous.x + previous.width);

                if (xGap > threshold) {
                    columns.push(currentColumn);
                    currentColumn = [current];
                } else {
                    currentColumn.push(current);
                }
            }

            if (currentColumn.length > 0) {
                columns.push(currentColumn);
            }

            return columns;
        }

        // ËÆ°ÁÆó‰∏§‰∏™ÂÖÉÁ¥†‰πãÈó¥ÁöÑË∑ùÁ¶ª
        function calculateDistance(elem1, elem2) {
            const center1 = {
                x: elem1.x + elem1.width / 2,
                y: elem1.y + elem1.height / 2
            };
            const center2 = {
                x: elem2.x + elem2.width / 2,
                y: elem2.y + elem2.height / 2
            };

            return Math.sqrt(
                Math.pow(center1.x - center2.x, 2) +
                Math.pow(center1.y - center2.y, 2)
            );
        }

        // ËÆ°ÁÆóËæπÁïå
        function calculateBounds(elements) {
            if (elements.length === 0) return { x: 0, y: 0, width: 0, height: 0 };

            const minX = Math.min(...elements.map(e => e.x));
            const minY = Math.min(...elements.map(e => e.y));
            const maxX = Math.max(...elements.map(e => e.x + e.width));
            const maxY = Math.max(...elements.map(e => e.y + e.height));

            return {
                x: minX - 5,
                y: minY - 5,
                width: maxX - minX + 10,
                height: maxY - minY + 10
            };
        }

        // üéØ Á°ÆÂÆöÂàÜÁªÑÁ±ªÂûãÂíåÂ∏ÉÂ±ÄÊñπÂêëÔºàFlexÂ∏ÉÂ±ÄÂØºÂêëÔºâ
        function determineGroupType(elements, hierarchy) {
            if (elements.length <= 1) {
                return { type: hierarchy.name, direction: 'NONE' };
            }

            // ËÆ°ÁÆóÂ∏ÉÂ±ÄÊñπÂêë
            const direction = determineFlexDirection(elements);

            // Ê†πÊçÆÂÖÉÁ¥†Á±ªÂûãÂíå‰ΩçÁΩÆÁâπÂæÅÁ°ÆÂÆöÊúÄÈÄÇÂêàÁöÑÂàÜÁªÑÁ±ªÂûã
            const hasImages = elements.some(e => e.type === 'image');
            const hasButtons = elements.some(e => e.type === 'button');
            const hasText = elements.some(e => e.type === 'text');

            let groupType = hierarchy.name;

            // ÁÆÄÂåñÁöÑÁ±ªÂûãÂà§Êñ≠ÈÄªËæë
            if (hasButtons && hasText) groupType = 'nav';
            else if (hasImages && hasText) groupType = 'article';
            else if (elements.length > 3) groupType = 'section';

            return { type: groupType, direction };
        }

        // üéØ Á°ÆÂÆöFlexÂ∏ÉÂ±ÄÊñπÂêë
        function determineFlexDirection(elements) {
            if (elements.length <= 1) return 'NONE';

            // ËÆ°ÁÆóÂÖÉÁ¥†ÁöÑ‰ΩçÁΩÆÂàÜÂ∏É
            const positions = elements.map(e => ({ x: e.x, y: e.y, width: e.width, height: e.height }));

            // ËÆ°ÁÆóXÂíåYÊñπÂêëÁöÑÂèòÂåñÁ®ãÂ∫¶
            const xPositions = positions.map(p => p.x);
            const yPositions = positions.map(p => p.y);

            const xRange = Math.max(...xPositions) - Math.min(...xPositions);
            const yRange = Math.max(...yPositions) - Math.min(...yPositions);

            // ËÆ°ÁÆóÂπ≥ÂùáÂÖÉÁ¥†Â∞∫ÂØ∏
            const avgWidth = positions.reduce((sum, p) => sum + p.width, 0) / positions.length;
            const avgHeight = positions.reduce((sum, p) => sum + p.height, 0) / positions.length;

            // Âà§Êñ≠‰∏ªË¶ÅÂ∏ÉÂ±ÄÊñπÂêë
            // Â¶ÇÊûúXÊñπÂêëÁöÑÂàÜÂ∏ÉËøúÂ§ß‰∫éYÊñπÂêëÔºå‰∏îXËåÉÂõ¥Â§ß‰∫éÂπ≥ÂùáÂÆΩÂ∫¶ÔºåÂàô‰∏∫Ê®™Âêë
            if (xRange > yRange && xRange > avgWidth) {
                console.log(`üìê Ê£ÄÊµãÂà∞Ê®™ÂêëÂ∏ÉÂ±Ä: XËåÉÂõ¥=${xRange}, YËåÉÂõ¥=${yRange}`);
                return 'HORIZONTAL';
            }
            // Â¶ÇÊûúYÊñπÂêëÁöÑÂàÜÂ∏ÉËøúÂ§ß‰∫éXÊñπÂêëÔºå‰∏îYËåÉÂõ¥Â§ß‰∫éÂπ≥ÂùáÈ´òÂ∫¶ÔºåÂàô‰∏∫Á∫µÂêë
            else if (yRange > xRange && yRange > avgHeight) {
                console.log(`üìê Ê£ÄÊµãÂà∞Á∫µÂêëÂ∏ÉÂ±Ä: XËåÉÂõ¥=${xRange}, YËåÉÂõ¥=${yRange}`);
                return 'VERTICAL';
            }
            // ÈªòËÆ§Ê®™ÂêëÔºà‰ºòÂÖàÊ®™ÂêëÁöÑÁ≠ñÁï•Ôºâ
            else {
                console.log(`üìê ÈªòËÆ§Ê®™ÂêëÂ∏ÉÂ±Ä: XËåÉÂõ¥=${xRange}, YËåÉÂõ¥=${yRange}`);
                return 'HORIZONTAL';
            }
        }

        // Ê∏≤ÊüìÂáΩÊï∞
        function renderCanvas(elements, canvasId) {
            const canvas = document.getElementById(canvasId);
            canvas.innerHTML = '';

            if (!elements || elements.length === 0) return;

            // ËÆ°ÁÆóÁº©ÊîæÊØî‰æã
            const maxX = Math.max(...elements.map(e => e.x + e.width));
            const maxY = Math.max(...elements.map(e => e.y + e.height));
            const scale = Math.min(canvas.clientWidth / maxX, canvas.clientHeight / maxY, 1) * 0.9;

            elements.forEach(element => {
                const div = document.createElement('div');
                div.className = `element element-${element.type}`;
                div.style.left = (element.x * scale) + 'px';
                div.style.top = (element.y * scale) + 'px';
                div.style.width = (element.width * scale) + 'px';
                div.style.height = (element.height * scale) + 'px';
                div.textContent = element.name.length > 8 ? element.name.substring(0, 8) + '...' : element.name;
                div.title = `${element.name}\n‰ΩçÁΩÆ: (${element.x}, ${element.y})\nÂ∞∫ÂØ∏: ${element.width} √ó ${element.height}`;
                canvas.appendChild(div);
            });
        }

        function renderGroupBoundaries(group, canvasId, scale) {
            const canvas = document.getElementById(canvasId);

            function renderGroup(currentGroup) {
                // Ê∏≤ÊüìÂΩìÂâçÂàÜÁªÑËæπÁïå
                const boundary = document.createElement('div');
                boundary.className = `group-boundary ${currentGroup.type}`;
                boundary.style.left = (currentGroup.bounds.x * scale) + 'px';
                boundary.style.top = (currentGroup.bounds.y * scale) + 'px';
                boundary.style.width = (currentGroup.bounds.width * scale) + 'px';
                boundary.style.height = (currentGroup.bounds.height * scale) + 'px';

                const label = document.createElement('div');
                label.className = `group-label ${currentGroup.type}`;
                label.textContent = currentGroup.name;
                boundary.appendChild(label);

                canvas.appendChild(boundary);

                // ÈÄíÂΩíÊ∏≤ÊüìÂ≠êÂàÜÁªÑ
                currentGroup.children.forEach(child => {
                    renderGroup(child);
                });
            }

            renderGroup(group);
        }

        function renderGroupedCanvas(elements, hierarchy) {
            renderCanvas(elements, 'grouped-canvas');

            // ËÆ°ÁÆóÁº©ÊîæÊØî‰æã
            const canvas = document.getElementById('grouped-canvas');
            const maxX = Math.max(...elements.map(e => e.x + e.width));
            const maxY = Math.max(...elements.map(e => e.y + e.height));
            const scale = Math.min(canvas.clientWidth / maxX, canvas.clientHeight / maxY, 1) * 0.9;

            renderGroupBoundaries(hierarchy, 'grouped-canvas', scale);
        }

        // Ê∏≤ÊüìÂéüÂßãÊâÅÂπ≥ÁªìÊûÑ
        function renderOriginalTree(elements) {
            const container = document.getElementById('original-tree');
            container.innerHTML = '';

            const rootNode = createTreeNode('flat', 'üìÑ ÂéüÂßãÂÖÉÁ¥†ÂàóË°®', elements.length, 'root');
            container.appendChild(rootNode);

            const childrenContainer = rootNode.querySelector('.node-children');
            elements.forEach((element, index) => {
                const elementNode = createTreeNode('element', `${getElementIcon(element.type)} ${element.name}`, 0, `element_${index}`, true);
                childrenContainer.appendChild(elementNode);
            });

            // ÈªòËÆ§Â±ïÂºÄÊ†πËäÇÁÇπ
            toggleNode('root');
        }

        // Ê∏≤ÊüìÂàÜÁªÑÂêéÁöÑÂ±ÇÊ¨°ÁªìÊûÑ
        function renderGroupTree(group) {
            const container = document.getElementById('grouped-tree');
            container.innerHTML = '';

            function buildInteractiveTree(currentGroup, parentContainer) {
                const hasChildren = currentGroup.children.length > 0;
                const nodeId = `group_${currentGroup.id}`;

                // Ê∑ªÂä†Â∏ÉÂ±ÄÊñπÂêëÂõæÊ†á
                const directionIcon = getDirectionIcon(currentGroup.direction);
                const treeNode = createTreeNode(
                    currentGroup.type,
                    `${directionIcon} ${currentGroup.name}`,
                    currentGroup.elements.length,
                    nodeId,
                    !hasChildren
                );

                parentContainer.appendChild(treeNode);

                if (hasChildren) {
                    const childrenContainer = treeNode.querySelector('.node-children');
                    currentGroup.children.forEach(child => {
                        buildInteractiveTree(child, childrenContainer);
                    });
                } else {
                    // Âè∂Â≠êËäÇÁÇπÊòæÁ§∫ÂÖÉÁ¥†ÂàóË°®
                    const childrenContainer = treeNode.querySelector('.node-children');
                    currentGroup.elements.forEach((element, index) => {
                        const elementNode = createTreeNode('element', `${getElementIcon(element.type)} ${element.name}`, 0, `${nodeId}_element_${index}`, true);
                        childrenContainer.appendChild(elementNode);
                    });
                }
            }

            buildInteractiveTree(group, container);

            // ÈªòËÆ§Â±ïÂºÄÊ†πËäÇÁÇπ
            toggleNode(`group_${group.id}`);
        }

        // ÂàõÂª∫‰∫§‰∫íÂºèÊ†ëËäÇÁÇπ
        function createTreeNode(type, label, count, nodeId, isLeaf = false) {
            const treeNode = document.createElement('div');
            treeNode.className = 'tree-node';
            treeNode.innerHTML = `
                <div class="node-content ${type}">
                    <div class="node-toggle ${isLeaf ? 'leaf' : ''}" data-node-id="${nodeId}">
                        ${isLeaf ? '‚Ä¢' : '+'}
                    </div>
                    <span class="node-label">${label}</span>
                    ${count > 0 ? `<span class="node-count">${count}</span>` : ''}
                </div>
                <div class="node-children" id="children_${nodeId}"></div>
            `;

            // Ê∑ªÂä†ÁÇπÂáª‰∫ã‰ª∂
            if (!isLeaf) {
                const toggle = treeNode.querySelector('.node-toggle');
                toggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleNode(nodeId);
                });
            }

            return treeNode;
        }

        // ÂàáÊç¢ËäÇÁÇπÂ±ïÂºÄ/Êî∂Ëµ∑Áä∂ÊÄÅ
        function toggleNode(nodeId) {
            const toggle = document.querySelector(`[data-node-id="${nodeId}"]`);
            const children = document.getElementById(`children_${nodeId}`);

            if (!toggle || !children) return;

            const isExpanded = children.classList.contains('expanded');

            if (isExpanded) {
                children.classList.remove('expanded');
                toggle.textContent = '+';
                toggle.classList.remove('expanded');
            } else {
                children.classList.add('expanded');
                toggle.textContent = '‚àí';
                toggle.classList.add('expanded');
            }
        }

        // Â±ïÂºÄÊâÄÊúâËäÇÁÇπ
        function expandAllNodes() {
            document.querySelectorAll('.node-toggle:not(.leaf)').forEach(toggle => {
                const nodeId = toggle.dataset.nodeId;
                const children = document.getElementById(`children_${nodeId}`);
                if (children && !children.classList.contains('expanded')) {
                    toggleNode(nodeId);
                }
            });
        }

        // Êî∂Ëµ∑ÊâÄÊúâËäÇÁÇπ
        function collapseAllNodes() {
            document.querySelectorAll('.node-toggle:not(.leaf)').forEach(toggle => {
                const nodeId = toggle.dataset.nodeId;
                const children = document.getElementById(`children_${nodeId}`);
                if (children && children.classList.contains('expanded')) {
                    toggleNode(nodeId);
                }
            });
        }

        // Ëé∑ÂèñÂàÜÁªÑÂõæÊ†á
        function getGroupIcon(type) {
            const icons = {
                page: 'üåê',
                section: 'üî¥',
                article: 'üü†',
                header: 'üü°',
                nav: 'üü§',
                main: 'üü¢',
                aside: 'üîµ',
                div: 'üî∑',
                component: 'üîπ'
            };
            return icons[type] || 'üì¶';
        }

        // Ëé∑ÂèñÂÖÉÁ¥†ÂõæÊ†á
        function getElementIcon(type) {
            const icons = {
                container: 'üì¶',
                text: 'üìù',
                button: 'üîò',
                image: 'üñºÔ∏è',
                normal: '‚ö™'
            };
            return icons[type] || '‚ö™';
        }

        // üéØ Ëé∑ÂèñÂ∏ÉÂ±ÄÊñπÂêëÂõæÊ†á
        function getDirectionIcon(direction) {
            const icons = {
                'HORIZONTAL': '‚ÜîÔ∏è',  // Ê®™ÂêëÂ∏ÉÂ±Ä
                'VERTICAL': '‚ÜïÔ∏è',    // Á∫µÂêëÂ∏ÉÂ±Ä
                'NONE': '‚ö™'         // Âçï‰∏™ÂÖÉÁ¥†
            };
            return icons[direction] || '‚ÜîÔ∏è'; // ÈªòËÆ§Ê®™Âêë
        }

        function updateStats(elements, hierarchy) {
            const totalGroups = countTotalGroups(hierarchy);
            const maxDepth = getMaxDepth(hierarchy);
            const avgGroupSize = calculateAverageGroupSize(hierarchy);
            const coverageRate = 100; // ÊâÄÊúâÂÖÉÁ¥†ÈÉΩË¢´Ë¶ÜÁõñ

            document.getElementById('total-elements').textContent = elements.length;
            document.getElementById('total-groups').textContent = totalGroups;
            document.getElementById('coverage-rate').textContent = coverageRate + '%';
            document.getElementById('max-depth').textContent = maxDepth;
            document.getElementById('avg-group-size').textContent = avgGroupSize.toFixed(1);
        }

        function countTotalGroups(group) {
            let count = 1; // ÂΩìÂâçÂàÜÁªÑ
            group.children.forEach(child => {
                count += countTotalGroups(child);
            });
            return count;
        }

        function getMaxDepth(group) {
            if (group.children.length === 0) return group.level;

            let maxChildDepth = 0;
            group.children.forEach(child => {
                maxChildDepth = Math.max(maxChildDepth, getMaxDepth(child));
            });

            return maxChildDepth;
        }

        function calculateAverageGroupSize(group) {
            const allGroups = [];

            function collectGroups(currentGroup) {
                allGroups.push(currentGroup);
                currentGroup.children.forEach(child => {
                    collectGroups(child);
                });
            }

            collectGroups(group);

            const totalElements = allGroups.reduce((sum, g) => sum + g.elements.length, 0);
            return totalElements / allGroups.length;
        }

        function runGrouping() {
            console.log('üîÑ ÂºÄÂßãÊâßË°åÊó†ÈòàÂÄºÂàÜÁªÑÁÆóÊ≥ï...');

            const elements = testCases[currentCase];
            console.log('üìä ÂÖÉÁ¥†Êï∞ÊçÆ:', elements);

            if (!elements || elements.length === 0) {
                console.error('‚ùå Ê≤°ÊúâÊâæÂà∞ÊµãËØïÊï∞ÊçÆ');
                return;
            }

            const hierarchy = performCompleteHierarchicalGrouping(elements);
            console.log('üèóÔ∏è ÂàÜÁªÑÁªìÊûú:', hierarchy);

            currentGroups = [hierarchy];

            try {
                renderCanvas(elements, 'original-canvas');
                console.log('‚úÖ ÂéüÂßãÁîªÂ∏ÉÊ∏≤ÊüìÂÆåÊàê');

                renderGroupedCanvas(elements, hierarchy);
                console.log('‚úÖ ÂàÜÁªÑÁîªÂ∏ÉÊ∏≤ÊüìÂÆåÊàê');

                renderOriginalTree(elements);
                console.log('‚úÖ ÂéüÂßãÊ†ëÂΩ¢ÁªìÊûÑÊ∏≤ÊüìÂÆåÊàê');

                renderGroupTree(hierarchy);
                console.log('‚úÖ ÂàÜÁªÑÊ†ëÂΩ¢ÁªìÊûÑÊ∏≤ÊüìÂÆåÊàê');

                updateStats(elements, hierarchy);
                console.log('‚úÖ ÁªüËÆ°‰ø°ÊÅØÊõ¥Êñ∞ÂÆåÊàê');

            } catch (error) {
                console.error('‚ùå Ê∏≤ÊüìÈîôËØØ:', error);
            }
        }

        // ‰∫ã‰ª∂ÁõëÂê¨Âô®
        function initEventListeners() {
            // ÊµãËØïÁî®‰æãÊåâÈíÆ
            document.querySelectorAll('.test-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.test-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentCase = btn.dataset.case;
                    runGrouping();
                });
            });

            // Ê†ëÂΩ¢ÊéßÂà∂ÊåâÈíÆ
            document.getElementById('expand-all-btn').addEventListener('click', expandAllNodes);
            document.getElementById('collapse-all-btn').addEventListener('click', collapseAllNodes);
            document.getElementById('refresh-btn').addEventListener('click', runGrouping);
        }

        // ÂàùÂßãÂåñ
        function init() {
            console.log('üöÄ ÂºÄÂßãÂàùÂßãÂåñ...');
            console.log('ÂΩìÂâçÊµãËØïÁî®‰æã:', currentCase);
            console.log('ÊµãËØïÊï∞ÊçÆ:', testCases[currentCase]);

            // ÂÖàÊµãËØïÂü∫Êú¨ÁöÑDOMÊìç‰Ωú
            const originalCanvas = document.getElementById('original-canvas');
            const groupedCanvas = document.getElementById('grouped-canvas');

            if (!originalCanvas || !groupedCanvas) {
                console.error('‚ùå Êâæ‰∏çÂà∞ÁîªÂ∏ÉÂÖÉÁ¥†');
                return;
            }

            console.log('‚úÖ ÁîªÂ∏ÉÂÖÉÁ¥†ÊâæÂà∞');

            try {
                initEventListeners();
                console.log('‚úÖ ‰∫ã‰ª∂ÁõëÂê¨Âô®ÂàùÂßãÂåñÂÆåÊàê');

                // Âª∂ËøüÊâßË°åÂàÜÁªÑÁÆóÊ≥ïÔºåÁ°Æ‰øùDOMÂÆåÂÖ®Âä†ËΩΩ
                setTimeout(() => {
                    runGrouping();
                    console.log('‚úÖ ÂàÜÁªÑÁÆóÊ≥ïÊâßË°åÂÆåÊàê');
                }, 100);

                console.log('üåê ÂÆåÊï¥Â±ÇÊ¨°ÂåñÂàÜÁªÑÁÆóÊ≥ïÂ∑≤Âä†ËΩΩ');
            } catch (error) {
                console.error('‚ùå ÂàùÂßãÂåñÈîôËØØ:', error);
                console.error('ÈîôËØØÂ†ÜÊ†à:', error.stack);
            }
        }

        // ÂàÜÁªÑÊ≠£Á°ÆÊÄßÊ†°È™åÂáΩÊï∞
        function validateGrouping(elements, hierarchy) {
            console.log('\nüîç ÂºÄÂßãÊ†°È™åÂàÜÁªÑÊ≠£Á°ÆÊÄß...');

            const issues = [];
            const warnings = [];

            // 1. Ê£ÄÊü•ÊâÄÊúâÂÖÉÁ¥†ÊòØÂê¶ÈÉΩË¢´ÂåÖÂê´
            const allElementsInHierarchy = getAllElementsFromHierarchy(hierarchy);
            const originalElementIds = new Set(elements.map(e => e.id));
            const hierarchyElementIds = new Set(allElementsInHierarchy.map(e => e.id));

            for (const id of originalElementIds) {
                if (!hierarchyElementIds.has(id)) {
                    issues.push(`‚ùå ÂÖÉÁ¥† ${id} Âú®ÂàÜÁªÑ‰∏≠‰∏¢Â§±`);
                }
            }

            // 2. Ê£ÄÊü•Á©∫Èó¥ÂåÖÂê´ÂÖ≥Á≥ªÊòØÂê¶Ê≠£Á°Æ
            function validateSpatialRelations(group) {
                if (group.children.length === 0) return;

                for (const child of group.children) {
                    // Ê£ÄÊü•Â≠êÂÖÉÁ¥†ÊòØÂê¶ÁúüÁöÑÂú®Áà∂ÂÖÉÁ¥†ÂÜÖÈÉ®
                    if (child.elements && child.elements.length > 0) {
                        const childBounds = child.bounds;
                        const parentBounds = group.bounds;

                        if (childBounds.x < parentBounds.x ||
                            childBounds.y < parentBounds.y ||
                            childBounds.x + childBounds.width > parentBounds.x + parentBounds.width ||
                            childBounds.y + childBounds.height > parentBounds.y + parentBounds.height) {
                            warnings.push(`‚ö†Ô∏è Â≠êÂàÜÁªÑ ${child.name} Ë∂ÖÂá∫Áà∂ÂàÜÁªÑ ${group.name} ËæπÁïå`);
                        }
                    }

                    // ÈÄíÂΩíÊ£ÄÊü•Â≠êÂàÜÁªÑ
                    validateSpatialRelations(child);
                }
            }

            validateSpatialRelations(hierarchy);

            // 3. Ê£ÄÊü•ÂàÜÁªÑÁöÑÂêàÁêÜÊÄß
            function validateGroupLogic(group) {
                if (group.children.length === 0) return;

                // Ê£ÄÊü•ÊòØÂê¶ÊúâÂçïÂ≠êËäÇÁÇπÂàÜÁªÑÔºàÂ∫îËØ•Â∑≤ÁªèË¢´‰ºòÂåñÊéâ‰∫ÜÔºâ
                if (group.children.length === 1) {
                    warnings.push(`‚ö†Ô∏è ÂàÜÁªÑ ${group.name} Âè™Êúâ‰∏Ä‰∏™Â≠êÂàÜÁªÑÔºåÂèØËÉΩÈúÄË¶ÅËøõ‰∏ÄÊ≠•‰ºòÂåñ`);
                }

                // Ê£ÄÊü•ÂàÜÁªÑÊñπÂêëÊòØÂê¶ÂêàÁêÜ
                if (group.children.length > 1) {
                    const direction = group.direction;
                    const childPositions = group.children.map(child => ({
                        x: child.bounds.x,
                        y: child.bounds.y,
                        width: child.bounds.width,
                        height: child.bounds.height
                    }));

                    if (direction === 'HORIZONTAL') {
                        // Ê∞¥Âπ≥ÂàÜÁªÑÔºöÊ£ÄÊü•ÊòØÂê¶ÁúüÁöÑÊòØÊ∞¥Âπ≥ÊéíÂàó
                        const avgY = childPositions.reduce((sum, pos) => sum + pos.y, 0) / childPositions.length;
                        const yVariance = childPositions.reduce((sum, pos) => sum + Math.pow(pos.y - avgY, 2), 0) / childPositions.length;

                        if (yVariance > 1000) { // ÈòàÂÄºÂèØË∞ÉÊï¥
                            warnings.push(`‚ö†Ô∏è ÂàÜÁªÑ ${group.name} Ê†áËÆ∞‰∏∫Ê∞¥Âπ≥Â∏ÉÂ±ÄÔºå‰ΩÜÂ≠êÂÖÉÁ¥†ÂûÇÁõ¥‰ΩçÁΩÆÂ∑ÆÂºÇËæÉÂ§ß`);
                        }
                    } else if (direction === 'VERTICAL') {
                        // ÂûÇÁõ¥ÂàÜÁªÑÔºöÊ£ÄÊü•ÊòØÂê¶ÁúüÁöÑÊòØÂûÇÁõ¥ÊéíÂàó
                        const avgX = childPositions.reduce((sum, pos) => sum + pos.x, 0) / childPositions.length;
                        const xVariance = childPositions.reduce((sum, pos) => sum + Math.pow(pos.x - avgX, 2), 0) / childPositions.length;

                        if (xVariance > 1000) { // ÈòàÂÄºÂèØË∞ÉÊï¥
                            warnings.push(`‚ö†Ô∏è ÂàÜÁªÑ ${group.name} Ê†áËÆ∞‰∏∫ÂûÇÁõ¥Â∏ÉÂ±ÄÔºå‰ΩÜÂ≠êÂÖÉÁ¥†Ê∞¥Âπ≥‰ΩçÁΩÆÂ∑ÆÂºÇËæÉÂ§ß`);
                        }
                    }
                }

                // ÈÄíÂΩíÊ£ÄÊü•Â≠êÂàÜÁªÑ
                group.children.forEach(validateGroupLogic);
            }

            validateGroupLogic(hierarchy);

            // 4. ËæìÂá∫Ê†°È™åÁªìÊûú
            console.log('\nüìä ÂàÜÁªÑÊ†°È™åÁªìÊûú:');
            console.log('================');

            if (issues.length === 0 && warnings.length === 0) {
                console.log('‚úÖ ÂàÜÁªÑÂÆåÂÖ®Ê≠£Á°ÆÔºÅÊ≤°ÊúâÂèëÁé∞ÈóÆÈ¢ò„ÄÇ');
            } else {
                if (issues.length > 0) {
                    console.log('‚ùå ÂèëÁé∞‰∏•ÈáçÈóÆÈ¢ò:');
                    issues.forEach(issue => console.log('  ' + issue));
                }

                if (warnings.length > 0) {
                    console.log('‚ö†Ô∏è ÂèëÁé∞ÊΩúÂú®ÈóÆÈ¢ò:');
                    warnings.forEach(warning => console.log('  ' + warning));
                }
            }

            // 5. ËæìÂá∫ÂàÜÁªÑÁªüËÆ°
            const stats = {
                totalElements: elements.length,
                totalGroups: countTotalGroups(hierarchy),
                maxDepth: getMaxDepth(hierarchy),
                avgGroupSize: calculateAverageGroupSize(hierarchy)
            };

            console.log('\nüìà ÂàÜÁªÑÁªüËÆ°:');
            console.log(`  ÊÄªÂÖÉÁ¥†Êï∞: ${stats.totalElements}`);
            console.log(`  ÊÄªÂàÜÁªÑÊï∞: ${stats.totalGroups}`);
            console.log(`  ÊúÄÂ§ßÊ∑±Â∫¶: ${stats.maxDepth}`);
            console.log(`  Âπ≥ÂùáÂàÜÁªÑÂ§ßÂ∞è: ${stats.avgGroupSize.toFixed(1)}`);

            return {
                isValid: issues.length === 0,
                issues,
                warnings,
                stats
            };
        }

        // ‰ªéÂ±ÇÊ¨°ÁªìÊûÑ‰∏≠Ëé∑ÂèñÊâÄÊúâÂÖÉÁ¥†
        function getAllElementsFromHierarchy(group) {
            let allElements = [...group.elements];
            for (const child of group.children) {
                allElements = allElements.concat(getAllElementsFromHierarchy(child));
            }
            return allElements;
        }

        // üéØ Ê†°È™åÂΩìÂâçÁî®‰æãÁöÑÂàÜÁªÑÈÄªËæë
        function testFunction() {
            console.log(`\nüîç ===== ËØ¶ÁªÜÊ†°È™åÁî®‰æã: ${currentCase} =====`);
            validateSingleCaseDetailed(currentCase);
        }

        // üéØ ËØ¶ÁªÜÊ†°È™åÂçï‰∏™Áî®‰æã
        function validateSingleCaseDetailed(caseId) {
            const elements = testCases[caseId];
            if (!elements || elements.length === 0) {
                console.error(`‚ùå ${caseId}: Ê≤°ÊúâÊµãËØïÊï∞ÊçÆ`);
                return false;
            }

            console.log(`\nüìã ËØ¶ÁªÜÂàÜÊûêÁî®‰æã: ${caseId}`);
            console.log(`ÂÖÉÁ¥†ÂàóË°®: ${elements.map(e => `${e.name}(${e.x},${e.y},${e.width}√ó${e.height})`).join(', ')}`);

            try {
                // ÊâßË°åÂàÜÁªÑÁÆóÊ≥ïÂπ∂Ëé∑ÂèñËØ¶ÁªÜËøáÁ®ã
                const hierarchy = performCompleteHierarchicalGrouping(elements);
                const actualGroups = extractGroupsFromHierarchy(hierarchy);
                const expectedGroups = getExpectedGroups(caseId);

                console.log(`\nüìä ÂàÜÁªÑÂØπÊØî:`);
                console.log(`È¢ÑÊúüÂàÜÁªÑ (${expectedGroups.length} ÁªÑ):`);
                expectedGroups.forEach((group, index) => {
                    console.log(`  ${index + 1}. [${group.join(', ')}]`);
                });

                console.log(`ÂÆûÈôÖÂàÜÁªÑ (${actualGroups.length} ÁªÑ):`);
                actualGroups.forEach((group, index) => {
                    console.log(`  ${index + 1}. [${group.join(', ')}]`);
                });

                return compareGroupingResults(caseId, actualGroups, expectedGroups);

            } catch (error) {
                console.error(`‚ùå ${caseId}: ÂàÜÁªÑÁÆóÊ≥ïÊâßË°åÈîôËØØ:`, error);
                return false;
            }
        }

        // ÂÖ®Â±ÄÈîôËØØ‰ø°ÊÅØÊî∂ÈõÜ
        let globalErrorMessages = [];

        // üéØ Ê†°È™åÊâÄÊúâÁî®‰æãÁöÑÂàÜÁªÑÈÄªËæë
        function validateAllCases() {
            console.log(`\nüîç ===== Ê†°È™åÊâÄÊúâÂàÜÁªÑÈÄªËæë =====`);

            // Ê∏ÖÁ©∫‰πãÂâçÁöÑÈîôËØØ‰ø°ÊÅØ
            globalErrorMessages = [];

            const cases = ['simple_card', 'basic_layout', 'form_example', 'navigation_bar', 'dashboard_simple'];
            let passedCount = 0;

            cases.forEach(caseId => {
                const passed = validateSingleCase(caseId);
                if (passed) passedCount++;
            });

            const summary = `üìä ÊÄª‰ΩìÊ†°È™åÁªìÊûú: ${passedCount}/${cases.length} ÈÄöËøá`;
            console.log(`\n${summary}`);
            globalErrorMessages.push(summary);

            if (passedCount === cases.length) {
                const successMsg = 'üéâ ÊâÄÊúâÁî®‰æãÊ†°È™åÈÄöËøáÔºÅ';
                console.log(successMsg);
                globalErrorMessages.push(successMsg);
            } else {
                const warningMsg = '‚ö†Ô∏è ÈÉ®ÂàÜÁî®‰æãÈúÄË¶ÅÊîπËøõ';
                console.log(warningMsg);
                globalErrorMessages.push(warningMsg);
            }

            // ÊòæÁ§∫ÈîôËØØ‰ø°ÊÅØÂà∞È°µÈù¢
            displayErrorMessages();
        }

        // üéØ Ê†°È™åÂçï‰∏™Áî®‰æã
        function validateSingleCase(caseId) {
            const elements = testCases[caseId];
            if (!elements || elements.length === 0) {
                const errorMsg = `‚ùå ${caseId}: Ê≤°ÊúâÊµãËØïÊï∞ÊçÆ`;
                console.error(errorMsg);
                globalErrorMessages.push(errorMsg);
                return false;
            }

            const caseHeader = `\nüìã Ê†°È™åÁî®‰æã: ${caseId}`;
            console.log(caseHeader);
            globalErrorMessages.push(caseHeader);

            const elementList = `ÂÖÉÁ¥†ÂàóË°®: ${elements.map(e => e.name).join(', ')}`;
            console.log(elementList);
            globalErrorMessages.push(elementList);

            try {
                const hierarchy = performCompleteHierarchicalGrouping(elements);
                const actualGroups = extractGroupsFromHierarchy(hierarchy);
                const expectedGroups = getExpectedGroups(caseId);

                return compareGroupingResults(caseId, actualGroups, expectedGroups);

            } catch (error) {
                const errorMsg = `‚ùå ${caseId}: ÂàÜÁªÑÁÆóÊ≥ïÊâßË°åÈîôËØØ: ${error.message}`;
                console.error(errorMsg);
                globalErrorMessages.push(errorMsg);
                return false;
            }
        }

        // üéØ Ëé∑ÂèñÈ¢ÑÊúüÁöÑÂàÜÁªÑÁªìÊûú
        function getExpectedGroups(caseId) {
            const expected = {
                'simple_card': [
                    ['Áî®Êà∑‰ø°ÊÅØ'],
                    ['Â§¥ÂÉè', 'Âº†‰∏â', 'zhang@email.com'],
                    ['ÁºñËæëÊåâÈíÆ']
                ],
                'basic_layout': [
                    ['Logo', 'È¶ñÈ°µ', 'ÂÖ≥‰∫é'],
                    ['Ê¨¢Ëøé‰ΩøÁî®', 'ËøôÊòØ‰∏ªË¶ÅÂÜÖÂÆπÂå∫Âüü...'],
                    ['Áõ∏ÂÖ≥ÈìæÊé•', 'Â∏ÆÂä©ÊñáÊ°£', 'ËÅîÁ≥ªÊàë‰ª¨'],
                    ['ÂºÄÂßã‰ΩøÁî®']
                ],
                'form_example': [
                    ['Âü∫Êú¨‰ø°ÊÅØ'],
                    ['ÂßìÂêç:', 'ÂßìÂêçËæìÂÖ•Ê°Ü', 'ÈÇÆÁÆ±:', 'ÈÇÆÁÆ±ËæìÂÖ•Ê°Ü'],
                    ['ÂØÜÁ†ÅËÆæÁΩÆ'],
                    ['ÂØÜÁ†Å:', 'ÂØÜÁ†ÅËæìÂÖ•Ê°Ü', 'Á°ÆËÆ§ÂØÜÁ†Å:', 'Á°ÆËÆ§ÂØÜÁ†ÅËæìÂÖ•Ê°Ü'],
                    ['Ê≥®ÂÜå', 'ÂèñÊ∂à']
                ],
                'navigation_bar': [
                    ['Logo', 'ÊàëÁöÑÁΩëÁ´ô'],
                    ['È¶ñÈ°µ', '‰∫ßÂìÅ', 'ÊúçÂä°', 'ÂÖ≥‰∫é'],
                    ['ÊêúÁ¥¢Ê°Ü', 'ÁôªÂΩï', 'Ê≥®ÂÜå']
                ],
                'dashboard_simple': [
                    ['Êï∞ÊçÆ‰ª™Ë°®Êùø', 'Âà∑Êñ∞'],
                    ['ÊÄªÁî®Êà∑', '1,234', '+12%'],
                    ['ÈîÄÂîÆÈ¢ù', '¬•56,789', '+8%'],
                    ['ËÆ¢ÂçïÊï∞', '456', '+15%'],
                    ['ÊúÄËøëÊ¥ªÂä®', 'Êñ∞Áî®Êà∑Ê≥®ÂÜå', 'ËÆ¢ÂçïÂÆåÊàê', 'ÊîØ‰ªòÊàêÂäü'],
                    ['ÈîÄÂîÆË∂ãÂäø', 'ÂõæË°®ÂÜÖÂÆπ']
                ]
            };

            return expected[caseId] || [];
        }

        // üéØ ‰ªéÂ±ÇÊ¨°ÁªìÊûÑ‰∏≠ÊèêÂèñÂàÜÁªÑÔºà‰øÆÂ§çÁâàÊú¨Ôºâ
        function extractGroupsFromHierarchy(hierarchy) {
            const groups = [];

            function extractGroups(node) {
                console.log(`üîç ÊèêÂèñÂàÜÁªÑ - ËäÇÁÇπ: ${node.name}, ÂÖÉÁ¥†Êï∞: ${node.elements?.length || 0}, Â≠êËäÇÁÇπÊï∞: ${node.children?.length || 0}`);

                // Â¶ÇÊûúÊúâÂ≠êËäÇÁÇπÔºå‰ºòÂÖàÂ§ÑÁêÜÂ≠êËäÇÁÇπ
                if (node.children && node.children.length > 0) {
                    console.log(`  üìÇ Â§ÑÁêÜ ${node.children.length} ‰∏™Â≠êËäÇÁÇπ`);
                    node.children.forEach(child => extractGroups(child));
                } else if (node.elements && node.elements.length > 0) {
                    // Âè™ÊúâÂú®Ê≤°ÊúâÂ≠êËäÇÁÇπÊó∂ÔºåÊâçÂ∞ÜÂÖÉÁ¥†‰Ωú‰∏∫Âè∂Â≠êÂàÜÁªÑ
                    const elementNames = node.elements.map(e => e.name);
                    console.log(`  üì¶ Âè∂Â≠êÂàÜÁªÑ: [${elementNames.join(', ')}]`);
                    groups.push(elementNames);
                }
            }

            extractGroups(hierarchy);
            console.log(`üéØ ÊúÄÁªàÊèêÂèñÂà∞ ${groups.length} ‰∏™ÂàÜÁªÑ: ${groups.map(g => `[${g.join(', ')}]`).join(', ')}`);
            return groups;
        }

        // üéØ ÊØîËæÉÂàÜÁªÑÁªìÊûú
        function compareGroupingResults(caseId, actualGroups, expectedGroups) {
            const comparisonHeader = `\nüîç ${caseId} - ÂàÜÁªÑÂØπÊØî:`;
            console.log(comparisonHeader);
            globalErrorMessages.push(comparisonHeader);

            const expectedInfo = `È¢ÑÊúüÂàÜÁªÑ (${expectedGroups.length} ÁªÑ): ${JSON.stringify(expectedGroups)}`;
            const actualInfo = `ÂÆûÈôÖÂàÜÁªÑ (${actualGroups.length} ÁªÑ): ${JSON.stringify(actualGroups)}`;
            console.log(expectedInfo);
            console.log(actualInfo);
            globalErrorMessages.push(expectedInfo);
            globalErrorMessages.push(actualInfo);

            let passed = true;
            const issues = [];

            // Ê£ÄÊü•ÂàÜÁªÑÊï∞Èáè
            if (actualGroups.length !== expectedGroups.length) {
                issues.push(`ÂàÜÁªÑÊï∞Èáè‰∏çÂåπÈÖç: È¢ÑÊúü ${expectedGroups.length}, ÂÆûÈôÖ ${actualGroups.length}`);
                passed = false;
            }

            // Ê£ÄÊü•ÊØè‰∏™ÂàÜÁªÑÁöÑÂÜÖÂÆπ
            expectedGroups.forEach((expectedGroup, index) => {
                const actualGroup = actualGroups[index];

                if (!actualGroup) {
                    issues.push(`Áº∫Â∞ëÁ¨¨ ${index + 1} ‰∏™ÂàÜÁªÑ: ${expectedGroup.join(', ')}`);
                    passed = false;
                    return;
                }

                // Ê£ÄÊü•ÂàÜÁªÑÂÜÖÂÆπÊòØÂê¶ÂåπÈÖçÔºàÂøΩÁï•È°∫Â∫èÔºâ
                const expectedSet = new Set(expectedGroup);
                const actualSet = new Set(actualGroup);

                if (expectedSet.size !== actualSet.size) {
                    issues.push(`Á¨¨ ${index + 1} ÁªÑÂÖÉÁ¥†Êï∞Èáè‰∏çÂåπÈÖç: È¢ÑÊúü ${expectedGroup.join(', ')}, ÂÆûÈôÖ ${actualGroup.join(', ')}`);
                    passed = false;
                } else {
                    for (const item of expectedSet) {
                        if (!actualSet.has(item)) {
                            issues.push(`Á¨¨ ${index + 1} ÁªÑÁº∫Â∞ëÂÖÉÁ¥†: ${item}`);
                            passed = false;
                        }
                    }
                    for (const item of actualSet) {
                        if (!expectedSet.has(item)) {
                            issues.push(`Á¨¨ ${index + 1} ÁªÑÂ§ö‰ΩôÂÖÉÁ¥†: ${item}`);
                            passed = false;
                        }
                    }
                }
            });

            // ËæìÂá∫ÁªìÊûú
            if (passed) {
                const successMsg = `‚úÖ ${caseId}: ÂàÜÁªÑÈÄªËæëÊ≠£Á°Æ`;
                console.log(successMsg);
                globalErrorMessages.push(successMsg);
            } else {
                const errorMsg = `‚ùå ${caseId}: ÂàÜÁªÑÈÄªËæëÊúâÈóÆÈ¢ò`;
                console.log(errorMsg);
                globalErrorMessages.push(errorMsg);
                issues.forEach(issue => {
                    const issueMsg = `   - ${issue}`;
                    console.log(issueMsg);
                    globalErrorMessages.push(issueMsg);
                });
            }

            return passed;
        }

        // üéØ ÊòæÁ§∫ÈîôËØØ‰ø°ÊÅØÂà∞È°µÈù¢
        function displayErrorMessages() {
            const errorOutput = document.getElementById('error-output');
            if (globalErrorMessages.length > 0) {
                errorOutput.innerHTML = globalErrorMessages.join('\n');
                errorOutput.style.display = 'block';
            } else {
                errorOutput.style.display = 'none';
            }
        }

        // üéØ Â§çÂà∂ÈîôËØØ‰ø°ÊÅØÂà∞Ââ™Ë¥¥Êùø
        function copyErrorsToClipboard() {
            if (globalErrorMessages.length === 0) {
                alert('Ê≤°ÊúâÈîôËØØ‰ø°ÊÅØÂèØÂ§çÂà∂ÔºåËØ∑ÂÖàËøêË°åÊ†°È™å');
                return;
            }

            const errorText = globalErrorMessages.join('\n');

            // ‰ΩøÁî®Áé∞‰ª£ÁöÑ Clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(errorText).then(() => {
                    alert('ÈîôËØØ‰ø°ÊÅØÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥ÊùøÔºÅ');
                }).catch(err => {
                    console.error('Â§çÂà∂Â§±Ë¥•:', err);
                    fallbackCopyToClipboard(errorText);
                });
            } else {
                // ÈôçÁ∫ßÊñπÊ°à
                fallbackCopyToClipboard(errorText);
            }
        }

        // üéØ ÈôçÁ∫ßÂ§çÂà∂ÊñπÊ°à
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                document.execCommand('copy');
                alert('ÈîôËØØ‰ø°ÊÅØÂ∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥ÊùøÔºÅ');
            } catch (err) {
                console.error('Â§çÂà∂Â§±Ë¥•:', err);
                alert('Â§çÂà∂Â§±Ë¥•ÔºåËØ∑ÊâãÂä®Â§çÂà∂È°µÈù¢‰∏äÊòæÁ§∫ÁöÑÈîôËØØ‰ø°ÊÅØ');
            }

            document.body.removeChild(textArea);
        }

        // üéØ ÊòæÁ§∫Ëá™Âä®ÊµãËØïÁªìÊûú
        function displayAutoTestResults() {
            const autoTestDiv = document.getElementById('auto-test-result');
            const testContent = document.getElementById('test-content');

            if (globalErrorMessages.length > 0) {
                // ÊèêÂèñÂÖ≥ÈîÆ‰ø°ÊÅØ
                const keyLines = globalErrorMessages.filter(line =>
                    line.includes('Ê†°È™åÁî®‰æã:') ||
                    line.includes('È¢ÑÊúüÂàÜÁªÑ') ||
                    line.includes('ÂÆûÈôÖÂàÜÁªÑ') ||
                    line.includes('ÂàÜÁªÑÈÄªËæëÊúâÈóÆÈ¢ò') ||
                    line.includes('ÂàÜÁªÑÈÄªËæëÊ≠£Á°Æ')
                );

                // Ê†ºÂºèÂåñÊòæÁ§∫
                let htmlContent = '';
                let currentCase = '';

                keyLines.forEach(line => {
                    if (line.includes('Ê†°È™åÁî®‰æã:')) {
                        currentCase = line.replace('üìã Ê†°È™åÁî®‰æã: ', '');
                        htmlContent += `<div style="margin: 10px 0; font-weight: bold; color: #0066cc;">${line}</div>`;
                    } else if (line.includes('È¢ÑÊúüÂàÜÁªÑ')) {
                        htmlContent += `<div style="margin: 5px 0; color: #28a745;">${line}</div>`;
                    } else if (line.includes('ÂÆûÈôÖÂàÜÁªÑ')) {
                        htmlContent += `<div style="margin: 5px 0; color: #dc3545;">${line}</div>`;
                    } else if (line.includes('ÂàÜÁªÑÈÄªËæë')) {
                        const isCorrect = line.includes('Ê≠£Á°Æ');
                        const color = isCorrect ? '#28a745' : '#dc3545';
                        const icon = isCorrect ? '‚úÖ' : '‚ùå';
                        htmlContent += `<div style="margin: 5px 0; color: ${color}; font-weight: bold;">${icon} ${line}</div>`;
                    }
                });

                testContent.innerHTML = htmlContent;
                autoTestDiv.style.display = 'block';

                // ÊªöÂä®Âà∞ÁªìÊûúÂå∫Âüü
                autoTestDiv.scrollIntoView({ behavior: 'smooth' });
            }
        }

        // üéØ Ëá™Âä®ÊµãËØïÂíåÂàÜÊûêÂáΩÊï∞
        function runAutoTestAndAnalyze() {
            console.log('\nü§ñ ÂºÄÂßãËá™Âä®ÊµãËØïÂíåÂàÜÊûê...');

            // ËøêË°åÊâÄÊúâÊµãËØï
            validateAllCases();

            // ÂàÜÊûêÁªìÊûú
            const testResults = analyzeTestResults();

            // ËæìÂá∫ÂàÜÊûêÁªìÊûú
            console.log('\nüìä === ÊµãËØïÁªìÊûúÂàÜÊûê ===');
            console.log(`ÊÄªÈÄöËøáÁéá: ${testResults.passRate}%`);
            console.log(`Â§±Ë¥•Áî®‰æã: ${testResults.failedCases.join(', ')}`);

            // ËæìÂá∫ËØ¶ÁªÜÈîôËØØÂàÜÊûê
            testResults.failedCases.forEach(caseId => {
                const caseAnalysis = analyzeCaseErrors(caseId);
                console.log(`\nüîç ${caseId} ÈîôËØØÂàÜÊûê:`);
                console.log(`  ÈóÆÈ¢òÁ±ªÂûã: ${caseAnalysis.problemType}`);
                console.log(`  Âª∫ËÆÆ‰øÆÂ§ç: ${caseAnalysis.suggestion}`);
            });

            return testResults;
        }

        // üéØ ÂàÜÊûêÊµãËØïÁªìÊûú
        function analyzeTestResults() {
            const cases = ['simple_card', 'basic_layout', 'form_example', 'navigation_bar', 'dashboard_simple'];
            const failedCases = [];
            let passedCount = 0;

            // ‰ªéÈîôËØØ‰ø°ÊÅØ‰∏≠ÊèêÂèñÂ§±Ë¥•ÁöÑÁî®‰æã
            globalErrorMessages.forEach(line => {
                if (line.includes('ÂàÜÁªÑÈÄªËæëÊúâÈóÆÈ¢ò')) {
                    const caseId = line.match(/(\w+):/)?.[1];
                    if (caseId && !failedCases.includes(caseId)) {
                        failedCases.push(caseId);
                    }
                } else if (line.includes('ÂàÜÁªÑÈÄªËæëÊ≠£Á°Æ')) {
                    passedCount++;
                }
            });

            return {
                totalCases: cases.length,
                passedCount: passedCount,
                failedCases: failedCases,
                passRate: Math.round((passedCount / cases.length) * 100)
            };
        }

        // üéØ ÂàÜÊûêÂçï‰∏™Áî®‰æãÁöÑÈîôËØØ
        function analyzeCaseErrors(caseId) {
            const caseMessages = globalErrorMessages.filter(line =>
                line.includes(caseId) ||
                (globalErrorMessages.indexOf(line) > globalErrorMessages.findIndex(l => l.includes(`Ê†°È™åÁî®‰æã: ${caseId}`)) &&
                 globalErrorMessages.indexOf(line) < globalErrorMessages.findIndex(l => l.includes('Ê†°È™åÁî®‰æã:') && l.indexOf(caseId) === -1))
            );

            let problemType = 'Êú™Áü•ÈóÆÈ¢ò';
            let suggestion = 'ÈúÄË¶ÅËøõ‰∏ÄÊ≠•ÂàÜÊûê';

            // ÂàÜÊûêÈóÆÈ¢òÁ±ªÂûã
            if (caseMessages.some(line => line.includes('ÂàÜÁªÑÊï∞Èáè‰∏çÂåπÈÖç'))) {
                const actualCount = caseMessages.find(line => line.includes('ÂÆûÈôÖÂàÜÁªÑ'))?.match(/(\d+) ÁªÑ/)?.[1];
                const expectedCount = caseMessages.find(line => line.includes('È¢ÑÊúüÂàÜÁªÑ'))?.match(/(\d+) ÁªÑ/)?.[1];

                if (actualCount && expectedCount) {
                    if (parseInt(actualCount) > parseInt(expectedCount)) {
                        problemType = 'ÂàÜÁªÑËøáÁªÜ';
                        suggestion = 'ÈúÄË¶ÅÊîæÂÆΩÂàÜÁªÑÊù°‰ª∂ÔºåËÆ©Êõ¥Â§öÂÖÉÁ¥†ÂêàÂπ∂Âà∞‰∏ÄÁªÑ';
                    } else {
                        problemType = 'ÂàÜÁªÑËøáÁ≤ó';
                        suggestion = 'ÈúÄË¶Å‰∏•Ê†ºÂàÜÁªÑÊù°‰ª∂ÔºåÈÅøÂÖç‰∏çÁõ∏ÂÖ≥ÂÖÉÁ¥†Ë¢´ÂàÜÂà∞‰∏ÄÁªÑ';
                    }
                }
            }

            return { problemType, suggestion };
        }

        // üéØ Â∞ùËØïËá™Âä®‰øÆÂ§ç
        function attemptAutoFix(testResults) {
            console.log(`\nüîß ÂàÜÊûê ${testResults.failedCases.length} ‰∏™Â§±Ë¥•Áî®‰æã...`);

            // ÁªüËÆ°ÈóÆÈ¢òÁ±ªÂûã
            const problemStats = {
                tooFine: 0,    // ÂàÜÁªÑËøáÁªÜ
                tooCoarse: 0,  // ÂàÜÁªÑËøáÁ≤ó
                mixed: 0       // Ê∑∑ÂêàÈóÆÈ¢ò
            };

            testResults.failedCases.forEach(caseId => {
                const analysis = analyzeCaseErrors(caseId);
                if (analysis.problemType === 'ÂàÜÁªÑËøáÁªÜ') {
                    problemStats.tooFine++;
                } else if (analysis.problemType === 'ÂàÜÁªÑËøáÁ≤ó') {
                    problemStats.tooCoarse++;
                } else {
                    problemStats.mixed++;
                }
            });

            console.log('ÈóÆÈ¢òÁªüËÆ°:', problemStats);

            // Ê†πÊçÆ‰∏ªË¶ÅÈóÆÈ¢òÁ±ªÂûãË∞ÉÊï¥ÁÆóÊ≥ï
            if (problemStats.tooFine > problemStats.tooCoarse) {
                console.log('üîß ‰∏ªË¶ÅÈóÆÈ¢òÔºöÂàÜÁªÑËøáÁªÜÔºåÈúÄË¶ÅÊîæÂÆΩÊù°‰ª∂');
                adjustGroupingForCoarser();
            } else if (problemStats.tooCoarse > problemStats.tooFine) {
                console.log('üîß ‰∏ªË¶ÅÈóÆÈ¢òÔºöÂàÜÁªÑËøáÁ≤óÔºåÈúÄË¶Å‰∏•Ê†ºÊù°‰ª∂');
                adjustGroupingForFiner();
            } else {
                console.log('üîß ÈóÆÈ¢òÁ±ªÂûãÊ∑∑ÂêàÔºåÈúÄË¶ÅÊõ¥Á≤æÁªÜÁöÑË∞ÉÊï¥');
                adjustGroupingMixed();
            }

            // ÈáçÊñ∞ÊµãËØï
            setTimeout(() => {
                console.log('\nüîÑ ÈáçÊñ∞ÊµãËØï‰øÆÂ§çÊïàÊûú...');
                runAutoTestAndAnalyze();
            }, 1000);
        }

        // üéØ Ë∞ÉÊï¥ÁÆóÊ≥ï‰ΩøÂàÜÁªÑÊõ¥Á≤óÁ≥ôÔºàÂêàÂπ∂Êõ¥Â§öÂÖÉÁ¥†Ôºâ
        function adjustGroupingForCoarser() {
            console.log('Ë∞ÉÊï¥Á≠ñÁï•ÔºöÊîæÂÆΩÊà™Êñ≠Ê£ÄÊµãÊù°‰ª∂');
            // ËøôÈáåÂèØ‰ª•Âä®ÊÄÅË∞ÉÊï¥ÁÆóÊ≥ïÂèÇÊï∞
            window.GROUPING_MODE = 'COARSER';
        }

        // üéØ Ë∞ÉÊï¥ÁÆóÊ≥ï‰ΩøÂàÜÁªÑÊõ¥Á≤æÁªÜÔºàÂàÜÁ¶ªÊõ¥Â§öÂÖÉÁ¥†Ôºâ
        function adjustGroupingForFiner() {
            console.log('Ë∞ÉÊï¥Á≠ñÁï•Ôºö‰∏•Ê†ºÊà™Êñ≠Ê£ÄÊµãÊù°‰ª∂');
            // ËøôÈáåÂèØ‰ª•Âä®ÊÄÅË∞ÉÊï¥ÁÆóÊ≥ïÂèÇÊï∞
            window.GROUPING_MODE = 'FINER';
        }

        // üéØ Ê∑∑ÂêàË∞ÉÊï¥Á≠ñÁï•
        function adjustGroupingMixed() {
            console.log('Ë∞ÉÊï¥Á≠ñÁï•Ôºö‰ΩøÁî®Ê∑∑ÂêàÊ®°Âºè');
            window.GROUPING_MODE = 'MIXED';
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
