<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸŒ å®Œæ•´å±‚æ¬¡åŒ–åˆ†ç»„ç®—æ³•</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .content {
            padding: 30px;
        }

        .demo-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .demo-panel {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #e2e8f0;
        }

        .panel-title {
            font-size: 1.3em;
            font-weight: 600;
            margin-bottom: 20px;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .canvas {
            position: relative;
            background: #f9fafb;
            border: 2px solid #e5e7eb;
            border-radius: 12px;
            height: 500px;
            margin: 15px 0;
            overflow: hidden;
        }

        .element {
            position: absolute;
            border: 2px solid;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: 600;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s ease;
        }

        .element:hover {
            transform: scale(1.05);
            z-index: 20;
        }

        .element-container { background-color: #4299e1; border-color: #3182ce; }
        .element-text { background-color: #ed8936; border-color: #dd6b20; }
        .element-button { background-color: #9f7aea; border-color: #805ad5; }
        .element-image { background-color: #48bb78; border-color: #38a169; }
        .element-normal { background-color: #38b2ac; border-color: #319795; }

        .group-boundary {
            position: absolute;
            border: 1px solid;
            background: transparent;
            border-radius: 4px;
            pointer-events: none;
            z-index: 5;
            opacity: 0.7;
        }

        /* ç®€åŒ–çš„å±‚æ¬¡é¢œè‰² - åªæ˜¾ç¤ºå…³é”®å±‚çº§ */
        .group-boundary.page {
            border-color: #1f2937;
            border-width: 3px;
            border-style: solid;
            background: rgba(31, 41, 55, 0.08);
            z-index: 1;
        }
        .group-boundary.section {
            border-color: #dc2626;
            border-width: 2px;
            border-style: dashed;
            background: rgba(220, 38, 38, 0.05);
            z-index: 2;
        }
        .group-boundary.article {
            border-color: #ea580c;
            border-width: 2px;
            border-style: dashed;
            background: rgba(234, 88, 12, 0.05);
            z-index: 3;
        }
        .group-boundary.header {
            border-color: #d97706;
            border-width: 1px;
            border-style: dotted;
            background: transparent;
            z-index: 4;
        }
        .group-boundary.nav {
            border-color: #ca8a04;
            border-width: 1px;
            border-style: dotted;
            background: transparent;
            z-index: 5;
        }
        .group-boundary.main {
            border-color: #65a30d;
            border-width: 2px;
            border-style: dashed;
            background: rgba(101, 163, 13, 0.05);
            z-index: 6;
        }
        .group-boundary.aside {
            border-color: #059669;
            border-width: 1px;
            border-style: dotted;
            background: transparent;
            z-index: 7;
        }
        .group-boundary.div {
            border-color: #0891b2;
            border-width: 1px;
            border-style: dotted;
            background: transparent;
            z-index: 8;
        }
        .group-boundary.component {
            border-color: #0284c7;
            border-width: 1px;
            border-style: dotted;
            background: transparent;
            z-index: 9;
        }

        .group-label {
            position: absolute;
            top: -10px;
            left: 4px;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.65em;
            font-weight: 600;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            opacity: 0.9;
        }

        /* åªä¸ºé‡è¦å±‚çº§æ˜¾ç¤ºæ ‡ç­¾ */
        .group-label.page { background: #1f2937; }
        .group-label.section { background: #dc2626; }
        .group-label.article { background: #ea580c; }
        .group-label.main { background: #65a30d; }

        /* å…¶ä»–å±‚çº§çš„æ ‡ç­¾æ›´å°æ›´é€æ˜ */
        .group-label.header { background: #d97706; opacity: 0.7; font-size: 0.6em; }
        .group-label.nav { background: #ca8a04; opacity: 0.7; font-size: 0.6em; }
        .group-label.aside { background: #059669; opacity: 0.7; font-size: 0.6em; }
        .group-label.div { background: #0891b2; opacity: 0.6; font-size: 0.55em; }
        .group-label.component { background: #0284c7; opacity: 0.6; font-size: 0.55em; }

        .controls {
            background: white;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #e2e8f0;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 10px 0;
        }

        .control-label {
            font-weight: 600;
            min-width: 120px;
        }

        .slider {
            flex: 1;
            max-width: 200px;
        }

        .value-display {
            min-width: 60px;
            font-weight: 600;
            color: #3b82f6;
        }

        .test-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin: 15px 0;
        }

        .test-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            background: #3b82f6;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .test-btn:hover {
            background: #2563eb;
        }

        .test-btn.active {
            background: #1d4ed8;
        }

        .results-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            border: 1px solid #e2e8f0;
            margin-top: 20px;
        }

        .group-tree {
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            line-height: 1.6;
            background: #f8fafc;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #e2e8f0;
            max-height: 500px;
            overflow-y: auto;
        }

        /* äº¤äº’å¼æ ‘èŠ‚ç‚¹æ ·å¼ */
        .tree-node {
            margin: 2px 0;
            user-select: none;
        }

        .node-content {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .node-content:hover {
            background: #f3f4f6;
            transform: translateX(2px);
        }

        .node-toggle {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            color: #6b7280;
            font-size: 10px;
            font-weight: 600;
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .node-toggle:hover {
            background: #d1d5db;
        }

        .node-toggle.expanded {
            background: #3b82f6;
            color: white;
        }

        .node-toggle.leaf {
            background: transparent;
            cursor: default;
            color: #9ca3af;
        }

        .node-icon {
            margin-right: 6px;
            font-size: 14px;
        }

        .node-label {
            font-weight: 500;
            color: #1f2937;
            flex: 1;
            font-size: 13px;
        }

        .node-count {
            background: #e5e7eb;
            color: #6b7280;
            padding: 1px 6px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 6px;
        }

        .node-children {
            margin-left: 24px;
            border-left: 1px solid #e5e7eb;
            padding-left: 8px;
            display: none;
            animation: slideDown 0.2s ease;
        }

        .node-children.expanded {
            display: block;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* ä¸åŒå±‚çº§çš„æ ·å¼ */
        .node-content.page { background: #f9fafb; border-left: 3px solid #1f2937; font-weight: 700; }
        .node-content.section { background: #fef2f2; border-left: 3px solid #dc2626; font-weight: 600; }
        .node-content.article { background: #fff7ed; border-left: 3px solid #ea580c; font-weight: 600; }
        .node-content.header { background: #fffbeb; border-left: 3px solid #d97706; font-weight: 600; }
        .node-content.nav { background: #fefce8; border-left: 3px solid #ca8a04; }
        .node-content.main { background: #f7fee7; border-left: 3px solid #65a30d; }
        .node-content.aside { background: #ecfdf5; border-left: 3px solid #059669; }
        .node-content.div { background: #f0f9ff; border-left: 3px solid #0891b2; }
        .node-content.component { background: #eff6ff; border-left: 3px solid #0284c7; }

        /* åŸå§‹ç»“æ„æ ·å¼ */
        .node-content.flat { background: #fafafa; border-left: 3px solid #9ca3af; color: #6b7280; }
        .node-content.element { background: #f8fafc; border-left: 2px solid #64748b; font-size: 0.85em; }

        /* æ ‘å½¢å¯¹æ¯”ç½‘æ ¼ */
        .tree-comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 15px;
        }

        .tree-panel {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e2e8f0;
        }

        .tree-panel-title {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #1f2937;
            display: flex;
            align-items: center;
            gap: 8px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e2e8f0;
        }

        /* æ§åˆ¶æŒ‰é’®æ ·å¼ */
        .control-btn {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #3b82f6;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .control-btn:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        .control-btn.secondary {
            background: #6b7280;
        }

        .control-btn.secondary:hover {
            background: #4b5563;
        }



        .stats-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .stat-card {
            background: #f8fafc;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e2e8f0;
        }

        .stat-value {
            font-size: 2em;
            font-weight: 700;
            color: #3b82f6;
        }

        .stat-label {
            color: #6b7280;
            font-size: 0.9em;
            margin-top: 5px;
        }

        .legend {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            border: 1px solid #e2e8f0;
        }

        .legend-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #1f2937;
        }

        .legend-items {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9em;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 2px solid;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸŒ å®Œæ•´å±‚æ¬¡åŒ–åˆ†ç»„ç®—æ³•</h1>
            <p>å‚è€ƒWebæ ‡å‡†ï¼Œç¡®ä¿æ‰€æœ‰å…ƒç´ éƒ½è¢«åˆ†ç»„ï¼Œä»é¡µé¢çº§åˆ°ç»„ä»¶çº§çš„å®Œæ•´å±‚æ¬¡</p>
        </div>

        <div class="content">
            <!-- æ§åˆ¶é¢æ¿ -->
            <div class="controls">
                <h3 style="margin-bottom: 15px;">ğŸ§ª æµ‹è¯•ç”¨ä¾‹é€‰æ‹©</h3>

                <div class="test-buttons">
                    <button class="test-btn active" data-case="simple_card">ğŸƒ ç®€å•å¡ç‰‡</button>
                    <button class="test-btn" data-case="basic_layout">ğŸ“„ åŸºç¡€å¸ƒå±€</button>
                    <button class="test-btn" data-case="form_example">ğŸ“ è¡¨å•ç¤ºä¾‹</button>
                    <button class="test-btn" data-case="navigation_bar">ğŸ§­ å¯¼èˆªæ </button>
                    <button class="test-btn" data-case="dashboard_simple">ğŸ“Š ç®€å•ä»ªè¡¨æ¿</button>
                </div>

                <!-- æ ¡éªŒæŒ‰é’® -->
                <div style="margin-top: 15px;">
                    <button onclick="validateAllCases()" style="background: #10b981; color: white; padding: 8px 16px; border: none; border-radius: 4px; margin-right: 10px;">âœ… æ ¡éªŒæ‰€æœ‰ç”¨ä¾‹</button>
                    <button onclick="testFunction()" style="background: #ef4444; color: white; padding: 8px 16px; border: none; border-radius: 4px; margin-right: 10px;">ğŸ”§ æ ¡éªŒå½“å‰ç”¨ä¾‹</button>
                        <button onclick="copyErrorsToClipboard()" style="background: #8b5cf6; color: white; padding: 8px 16px; border: none; border-radius: 4px;">ğŸ“‹ å¤åˆ¶é”™è¯¯ä¿¡æ¯</button>
                </div>
            </div>

                    <!-- é”™è¯¯ä¿¡æ¯æ˜¾ç¤ºåŒºåŸŸ -->
                    <div id="error-output" style="margin-top: 15px; padding: 10px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 4px; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto; display: none;">
                    </div>





            <!-- ç»Ÿè®¡ä¿¡æ¯ -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="total-elements">0</div>
                    <div class="stat-label">æ€»å…ƒç´ æ•°</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="total-groups">0</div>
                    <div class="stat-label">åˆ†ç»„æ€»æ•°</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="coverage-rate">0%</div>
                    <div class="stat-label">è¦†ç›–ç‡</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="max-depth">0</div>
                    <div class="stat-label">æœ€å¤§æ·±åº¦</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avg-group-size">0</div>
                    <div class="stat-label">å¹³å‡ç»„å¤§å°</div>
                </div>
            </div>

            <!-- æ¼”ç¤ºåŒºåŸŸ -->
            <div class="demo-grid">
                <div class="demo-panel">
                    <div class="panel-title">ğŸ“¥ åŸå§‹å…ƒç´ å¸ƒå±€</div>
                    <div class="canvas" id="original-canvas"></div>
                </div>
                
                <div class="demo-panel">
                    <div class="panel-title">ğŸŒ å®Œæ•´å±‚æ¬¡åŒ–åˆ†ç»„</div>
                    <div class="canvas" id="grouped-canvas"></div>
                </div>
            </div>

            <!-- æ ‘å½¢ç»“æ„æ§åˆ¶ -->
            <div class="results-panel">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h3>ğŸŒ³ äº¤äº’å¼æ ‘å½¢ç»“æ„å¯¹æ¯”</h3>
                    <div style="display: flex; gap: 10px;">
                        <button class="control-btn" id="expand-all-btn">ğŸ“‚ å…¨éƒ¨å±•å¼€</button>
                        <button class="control-btn" id="collapse-all-btn">ğŸ“ å…¨éƒ¨æ”¶èµ·</button>
                        <button class="control-btn secondary" id="refresh-btn">ğŸ”„ é‡æ–°åˆ†æ</button>
                    </div>
                </div>

                <!-- æ ‘å½¢ç»“æ„å¯¹æ¯” -->
                <div class="tree-comparison-grid">
                    <div class="tree-panel">
                        <div class="tree-panel-title">ğŸ”´ åˆ†ç»„å‰ç»“æ„ (æ‰å¹³)</div>
                        <div class="group-tree" id="original-tree"></div>
                    </div>

                    <div class="tree-panel">
                        <div class="tree-panel-title">ğŸŒ³ åˆ†ç»„åç»“æ„ (å±‚æ¬¡åŒ–)</div>
                        <div class="group-tree" id="grouped-tree"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æµ‹è¯•æ•°æ®é›† - ä»ç®€å•åˆ°å¤æ‚çš„æ¸è¿›å¼ä¾‹å­
        const testCases = {
            // 1. ğŸƒ ç®€å•å¡ç‰‡ - æœ€åŸºç¡€çš„åˆ†ç»„ç¤ºä¾‹
            simple_card: [
                { id: 'card_title', name: 'ç”¨æˆ·ä¿¡æ¯', x: 20, y: 20, width: 200, height: 30, type: 'text' },
                { id: 'avatar', name: 'å¤´åƒ', x: 30, y: 60, width: 60, height: 60, type: 'image' },
                { id: 'username', name: 'å¼ ä¸‰', x: 100, y: 70, width: 100, height: 20, type: 'text' },
                { id: 'email', name: 'zhang@email.com', x: 100, y: 95, width: 120, height: 15, type: 'text' },
                { id: 'edit_btn', name: 'ç¼–è¾‘', x: 160, y: 130, width: 60, height: 25, type: 'button' }
            ],

            // 2. ğŸ“„ åŸºç¡€å¸ƒå±€ - ç®€å•çš„é¡µé¢ç»“æ„
            basic_layout: [
                // å¤´éƒ¨åŒºåŸŸ
                { id: 'logo', name: 'Logo', x: 20, y: 10, width: 80, height: 30, type: 'image' },
                { id: 'nav_home', name: 'é¦–é¡µ', x: 120, y: 15, width: 50, height: 20, type: 'button' },
                { id: 'nav_about', name: 'å…³äº', x: 180, y: 15, width: 50, height: 20, type: 'button' },

                // ä¸»è¦å†…å®¹
                { id: 'main_title', name: 'æ¬¢è¿ä½¿ç”¨', x: 20, y: 60, width: 300, height: 40, type: 'text' },
                { id: 'content_text', name: 'è¿™æ˜¯ä¸»è¦å†…å®¹åŒºåŸŸ...', x: 20, y: 110, width: 280, height: 60, type: 'text' },
                { id: 'cta_button', name: 'å¼€å§‹ä½¿ç”¨', x: 20, y: 180, width: 100, height: 35, type: 'button' },

                // ä¾§è¾¹æ 
                { id: 'sidebar_title', name: 'ç›¸å…³é“¾æ¥', x: 340, y: 60, width: 120, height: 25, type: 'text' },
                { id: 'link1', name: 'å¸®åŠ©æ–‡æ¡£', x: 350, y: 95, width: 80, height: 20, type: 'button' },
                { id: 'link2', name: 'è”ç³»æˆ‘ä»¬', x: 350, y: 125, width: 80, height: 20, type: 'button' }
            ],

            // 3. ğŸ“ è¡¨å•ç¤ºä¾‹ - å±•ç¤ºè¡¨å•å…ƒç´ çš„åˆ†ç»„
            form_example: [
                { id: 'form_title', name: 'ç”¨æˆ·æ³¨å†Œ', x: 50, y: 20, width: 200, height: 30, type: 'text' },

                // åŸºæœ¬ä¿¡æ¯ç»„
                { id: 'basic_label', name: 'åŸºæœ¬ä¿¡æ¯', x: 50, y: 70, width: 100, height: 20, type: 'text' },
                { id: 'name_label', name: 'å§“å:', x: 60, y: 100, width: 50, height: 15, type: 'text' },
                { id: 'name_input', name: 'å§“åè¾“å…¥æ¡†', x: 120, y: 95, width: 150, height: 25, type: 'text' },
                { id: 'email_label', name: 'é‚®ç®±:', x: 60, y: 130, width: 50, height: 15, type: 'text' },
                { id: 'email_input', name: 'é‚®ç®±è¾“å…¥æ¡†', x: 120, y: 125, width: 150, height: 25, type: 'text' },

                // å¯†ç ä¿¡æ¯ç»„
                { id: 'pwd_label', name: 'å¯†ç è®¾ç½®', x: 50, y: 170, width: 100, height: 20, type: 'text' },
                { id: 'password_label', name: 'å¯†ç :', x: 60, y: 200, width: 50, height: 15, type: 'text' },
                { id: 'password_input', name: 'å¯†ç è¾“å…¥æ¡†', x: 120, y: 195, width: 150, height: 25, type: 'text' },
                { id: 'confirm_label', name: 'ç¡®è®¤:', x: 60, y: 230, width: 50, height: 15, type: 'text' },
                { id: 'confirm_input', name: 'ç¡®è®¤å¯†ç æ¡†', x: 120, y: 225, width: 150, height: 25, type: 'text' },

                // æ“ä½œæŒ‰é’®ç»„
                { id: 'submit_btn', name: 'æ³¨å†Œ', x: 120, y: 270, width: 70, height: 30, type: 'button' },
                { id: 'cancel_btn', name: 'å–æ¶ˆ', x: 200, y: 270, width: 70, height: 30, type: 'button' }
            ],

            // 4. ğŸ§­ å¯¼èˆªæ  - æ°´å¹³å¸ƒå±€çš„åˆ†ç»„ç¤ºä¾‹
            navigation_bar: [
                // å·¦ä¾§å“ç‰ŒåŒº
                { id: 'brand_logo', name: 'Logo', x: 20, y: 15, width: 40, height: 30, type: 'image' },
                { id: 'brand_name', name: 'æˆ‘çš„ç½‘ç«™', x: 70, y: 20, width: 80, height: 20, type: 'text' },

                // ä¸­é—´å¯¼èˆªèœå•
                { id: 'nav_home', name: 'é¦–é¡µ', x: 200, y: 20, width: 50, height: 20, type: 'button' },
                { id: 'nav_products', name: 'äº§å“', x: 260, y: 20, width: 50, height: 20, type: 'button' },
                { id: 'nav_services', name: 'æœåŠ¡', x: 320, y: 20, width: 50, height: 20, type: 'button' },
                { id: 'nav_about', name: 'å…³äº', x: 380, y: 20, width: 50, height: 20, type: 'button' },

                // å³ä¾§ç”¨æˆ·åŒº
                { id: 'search_box', name: 'æœç´¢', x: 480, y: 18, width: 100, height: 24, type: 'text' },
                { id: 'login_btn', name: 'ç™»å½•', x: 590, y: 18, width: 50, height: 24, type: 'button' },
                { id: 'signup_btn', name: 'æ³¨å†Œ', x: 650, y: 18, width: 50, height: 24, type: 'button' }
            ],

            // 5. ğŸ“Š ç®€å•ä»ªè¡¨æ¿ - å¤šåŒºåŸŸå¸ƒå±€ç¤ºä¾‹
            dashboard_simple: [
                // é¡¶éƒ¨æ ‡é¢˜æ 
                { id: 'dash_title', name: 'æ•°æ®ä»ªè¡¨æ¿', x: 20, y: 20, width: 200, height: 30, type: 'text' },
                { id: 'refresh_btn', name: 'åˆ·æ–°', x: 500, y: 25, width: 60, height: 20, type: 'button' },

                // ç»Ÿè®¡å¡ç‰‡åŒºåŸŸ
                { id: 'card1_title', name: 'æ€»ç”¨æˆ·', x: 20, y: 70, width: 120, height: 20, type: 'text' },
                { id: 'card1_value', name: '1,234', x: 20, y: 95, width: 120, height: 35, type: 'text' },
                { id: 'card1_trend', name: '+12%', x: 20, y: 135, width: 120, height: 15, type: 'text' },

                { id: 'card2_title', name: 'é”€å”®é¢', x: 160, y: 70, width: 120, height: 20, type: 'text' },
                { id: 'card2_value', name: 'Â¥56,789', x: 160, y: 95, width: 120, height: 35, type: 'text' },
                { id: 'card2_trend', name: '+8%', x: 160, y: 135, width: 120, height: 15, type: 'text' },

                { id: 'card3_title', name: 'è®¢å•æ•°', x: 300, y: 70, width: 120, height: 20, type: 'text' },
                { id: 'card3_value', name: '456', x: 300, y: 95, width: 120, height: 35, type: 'text' },
                { id: 'card3_trend', name: '+15%', x: 300, y: 135, width: 120, height: 15, type: 'text' },

                // å›¾è¡¨åŒºåŸŸ
                { id: 'chart_title', name: 'é”€å”®è¶‹åŠ¿', x: 20, y: 180, width: 400, height: 25, type: 'text' },
                { id: 'chart_area', name: 'å›¾è¡¨å†…å®¹', x: 20, y: 210, width: 400, height: 150, type: 'container' },

                // æœ€è¿‘æ´»åŠ¨
                { id: 'activity_title', name: 'æœ€è¿‘æ´»åŠ¨', x: 450, y: 70, width: 150, height: 25, type: 'text' },
                { id: 'activity1', name: 'æ–°ç”¨æˆ·æ³¨å†Œ', x: 450, y: 105, width: 150, height: 20, type: 'text' },
                { id: 'activity2', name: 'è®¢å•å®Œæˆ', x: 450, y: 130, width: 150, height: 20, type: 'text' },
                { id: 'activity3', name: 'æ”¯ä»˜æˆåŠŸ', x: 450, y: 155, width: 150, height: 20, type: 'text' }
            ]
        };

        // å…¨å±€å˜é‡
        let currentCase = 'simple_card';
        let currentGroups = [];

        // Webæ ‡å‡†å±‚æ¬¡å®šä¹‰
        const WEB_HIERARCHY = [
            { name: 'page', label: 'Page', minSize: 0, priority: 1 },
            { name: 'section', label: 'Section', minSize: 100, priority: 2 },
            { name: 'article', label: 'Article', minSize: 80, priority: 3 },
            { name: 'header', label: 'Header', minSize: 60, priority: 4 },
            { name: 'nav', label: 'Nav', minSize: 40, priority: 5 },
            { name: 'main', label: 'Main', minSize: 60, priority: 6 },
            { name: 'aside', label: 'Aside', minSize: 40, priority: 7 },
            { name: 'div', label: 'Div', minSize: 30, priority: 8 },
            { name: 'component', label: 'Component', minSize: 20, priority: 9 }
        ];

        // å®Œæ•´å±‚æ¬¡åŒ–åˆ†ç»„ç®—æ³•
        function performCompleteHierarchicalGrouping(elements) {
            console.log('ğŸŒ å¼€å§‹å®Œæ•´å±‚æ¬¡åŒ–åˆ†ç»„åˆ†æ...');

            // 1. åˆ›å»ºé¡µé¢çº§åˆ†ç»„ï¼ˆåŒ…å«æ‰€æœ‰å…ƒç´ ï¼‰
            const pageGroup = createPageGroup(elements);

            // 2. é€’å½’åˆ›å»ºå­åˆ†ç»„
            const completeHierarchy = buildCompleteHierarchy(pageGroup);

            console.log('ğŸ¯ å®Œæ•´åˆ†ç»„å®Œæˆ');
            return completeHierarchy;
        }

        // åˆ›å»ºé¡µé¢çº§åˆ†ç»„
        function createPageGroup(elements) {
            const bounds = calculateBounds(elements);
            return {
                id: 'page_root',
                name: generateMeaningfulGroupName(elements, 'Page'),
                type: 'page',
                level: 1,
                elements: elements,
                bounds: bounds,
                children: []
            };
        }

        // æ„å»ºå®Œæ•´å±‚æ¬¡ç»“æ„
        function buildCompleteHierarchy(parentGroup) {
            const { elements, level } = parentGroup;

            if (elements.length <= 1 || level >= WEB_HIERARCHY.length) {
                return parentGroup;
            }

            // æ ¹æ®å½“å‰å±‚çº§é€‰æ‹©åˆ†ç»„ç­–ç•¥
            const currentHierarchy = WEB_HIERARCHY[level - 1];
            const nextHierarchy = WEB_HIERARCHY[level];

            // æ‰§è¡Œæ— é˜ˆå€¼åˆ†ç»„
            const subGroups = createSubGroups(elements, nextHierarchy, level + 1);

            // é€’å½’å¤„ç†æ¯ä¸ªå­åˆ†ç»„
            parentGroup.children = subGroups.map(group => buildCompleteHierarchy(group));

            // ğŸ”§ ä¼˜åŒ–ï¼šåˆå¹¶åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹çš„åˆ†ç»„ï¼Œå‡å°‘æ ‘çš„æ·±åº¦
            parentGroup = optimizeSingleChildGroups(parentGroup);

            return parentGroup;
        }

        // ğŸ”§ ä¼˜åŒ–å•å­èŠ‚ç‚¹åˆ†ç»„ï¼šåˆå¹¶åªæœ‰ä¸€ä¸ªå­èŠ‚ç‚¹çš„åˆ†ç»„ï¼Œå‡å°‘ä¸å¿…è¦çš„æ ‘æ·±åº¦
        function optimizeSingleChildGroups(group) {
            if (!group.children || group.children.length === 0) {
                return group;
            }

            // é€’å½’ä¼˜åŒ–æ‰€æœ‰å­åˆ†ç»„
            group.children = group.children.map(child => optimizeSingleChildGroups(child));

            // å¦‚æœå½“å‰åˆ†ç»„åªæœ‰ä¸€ä¸ªå­åˆ†ç»„ï¼Œä¸”å­åˆ†ç»„ä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼Œåˆ™è€ƒè™‘åˆå¹¶
            if (group.children.length === 1) {
                const onlyChild = group.children[0];

                // åˆå¹¶æ¡ä»¶ï¼š
                // 1. å­åˆ†ç»„ä¹Ÿæœ‰å­èŠ‚ç‚¹ï¼ˆä¸æ˜¯å¶å­èŠ‚ç‚¹ï¼‰
                // 2. æˆ–è€…å­åˆ†ç»„åªåŒ…å«ä¸€ä¸ªå…ƒç´ ï¼ˆè¿‡åº¦åˆ†ç»„ï¼‰
                if (onlyChild.children.length > 0 || onlyChild.elements.length === 1) {
                    console.log(`ğŸ”§ åˆå¹¶å•å­èŠ‚ç‚¹åˆ†ç»„: ${group.name} -> ${onlyChild.name}`);

                    // ä¿ç•™çˆ¶åˆ†ç»„çš„åŸºæœ¬ä¿¡æ¯ï¼Œä½†ä½¿ç”¨å­åˆ†ç»„çš„å†…å®¹
                    return {
                        id: group.id,
                        name: group.name, // ä¿ç•™çˆ¶åˆ†ç»„çš„åç§°
                        type: group.type, // ä¿ç•™çˆ¶åˆ†ç»„çš„ç±»å‹
                        level: group.level,
                        elements: onlyChild.elements,
                        bounds: onlyChild.bounds,
                        children: onlyChild.children,
                        direction: onlyChild.direction
                    };
                }
            }

            return group;
        }



        // ğŸ¯ ç”ŸæˆåŸºäºåŸå§‹èŠ‚ç‚¹åç§°çš„åˆ†ç»„åç§°
        function generateMeaningfulGroupName(elements, fallbackName) {
            if (!elements || elements.length === 0) {
                return fallbackName;
            }

            // å¦‚æœåªæœ‰ä¸€ä¸ªå…ƒç´ ï¼Œç›´æ¥ä½¿ç”¨å…ƒç´ åç§°
            if (elements.length === 1) {
                return elements[0].name;
            }

            // å¦‚æœæœ‰å¤šä¸ªå…ƒç´ ï¼Œåˆ—å‡ºæ‰€æœ‰å…ƒç´ åç§°
            const elementNames = elements.map(e => e.name);

            // å¦‚æœå…ƒç´ ä¸å¤šï¼Œç›´æ¥åˆ—å‡ºæ‰€æœ‰åç§°
            if (elements.length <= 3) {
                return elementNames.join(' + ');
            }

            // å¦‚æœå…ƒç´ è¾ƒå¤šï¼Œæ˜¾ç¤ºå‰å‡ ä¸ªåŠ çœç•¥å·
            return `${elementNames.slice(0, 2).join(' + ')} + ${elements.length - 2} é¡¹`;
        }

        // åˆ›å»ºå­åˆ†ç»„
        function createSubGroups(elements, hierarchy, level) {
            console.log(`\nğŸ”§ createSubGroups è¢«è°ƒç”¨ï¼Œå±‚çº§: ${level}, å…ƒç´ æ•°é‡: ${elements.length}`);
            console.log(`è¾“å…¥å…ƒç´ : ${elements.map(e => e.name).join(', ')}`);

            if (elements.length <= 1) {
                console.log(`å…ƒç´ æ•°é‡ <= 1ï¼Œè¿”å›ç©ºæ•°ç»„`);
                return [];
            }

            // 1. ä½¿ç”¨æ— é˜ˆå€¼çš„ç©ºé—´èšç±»
            const clusters = performSpatialClustering(elements);
            console.log(`èšç±»ç»“æœ: ${clusters.length} ä¸ªèšç±»`);
            clusters.forEach((cluster, i) => {
                console.log(`  èšç±» ${i + 1}: [${cluster.map(e => e.name).join(', ')}]`);
            });

            // 2. ä¸ºæ¯ä¸ªèšç±»åˆ›å»ºåˆ†ç»„
            const groups = [];
            clusters.forEach((cluster, index) => {
                if (cluster.length >= 1) { // ç¡®ä¿æ‰€æœ‰å…ƒç´ éƒ½è¢«åˆ†ç»„
                    const bounds = calculateBounds(cluster);
                    const groupInfo = determineGroupType(cluster, hierarchy);

                    const group = {
                        id: `${hierarchy.name}_${level}_${index}`,
                        name: generateMeaningfulGroupName(cluster, `${hierarchy.label} ${index + 1}`),
                        type: groupInfo.type || hierarchy.name,
                        level: level,
                        elements: cluster,
                        bounds: bounds,
                        children: [],
                        direction: groupInfo.direction || 'HORIZONTAL' // é»˜è®¤æ¨ªå‘
                    };

                    groups.push(group);
                }
            });

            // 3. å¦‚æœæ²¡æœ‰å½¢æˆæœ‰æ•ˆåˆ†ç»„ï¼Œåˆ›å»ºå•ä¸ªåŒ…å«æ‰€æœ‰å…ƒç´ çš„åˆ†ç»„
            if (groups.length === 0 && elements.length > 0) {
                const bounds = calculateBounds(elements);
                const groupInfo = determineGroupType(elements, hierarchy);
                groups.push({
                    id: `${hierarchy.name}_${level}_0`,
                    name: generateMeaningfulGroupName(elements, `${hierarchy.label} 1`),
                    type: groupInfo.type || hierarchy.name,
                    level: level,
                    elements: elements,
                    bounds: bounds,
                    children: [],
                    direction: groupInfo.direction || 'HORIZONTAL' // é»˜è®¤æ¨ªå‘
                });
            }

            return groups;
        }

        // ğŸ¯ Flexå¸ƒå±€å¯¼å‘çš„ç©ºé—´èšç±»ç®—æ³• - ä¼˜å…ˆæ¨ªå‘åˆ†ç»„
        function performSpatialClustering(elements) {
            if (elements.length <= 1) return [elements];

            console.log(`ğŸ”„ å¼€å§‹æ— é˜ˆå€¼ç©ºé—´åˆ†ç»„`);

            // ä½¿ç”¨æ— é˜ˆå€¼çš„ç›¸å¯¹å…³ç³»åˆ†ç»„
            return performFlexLayoutGrouping(elements);
        }

        // ğŸ¯ åŸºäºç›¸å¯¹å…³ç³»çš„æ— é˜ˆå€¼åˆ†ç»„ç®—æ³•
        function performFlexLayoutGrouping(elements) {
            console.log(`ğŸš€ å¼€å§‹æ— é˜ˆå€¼åˆ†ç»„ï¼Œå…ƒç´ æ•°é‡: ${elements.length}`);
            console.log(`ğŸ’¡ ä¸å†ä¾èµ–å›ºå®šé˜ˆå€¼ï¼Œä½¿ç”¨ç›¸å¯¹ç©ºé—´å…³ç³»è¿›è¡Œåˆ†ç»„`);

            if (elements.length <= 1) {
                return [elements];
            }

            // ğŸ¯ ä½¿ç”¨ç›¸å¯¹å…³ç³»è¿›è¡Œåˆ†ç»„
            return performRelativeGrouping(elements);
        }

        // ğŸ¯ é‡æ–°è®¾è®¡çš„ä¸¥æ ¼åˆ†ç»„ç®—æ³•
        function performRelativeGrouping(elements) {
            console.log(`\nğŸ“ === ä¸¥æ ¼é—´éš™åˆ†ç»„ç®—æ³• ===`);

            // ä½¿ç”¨åŸºäºé—´éš™çš„ä¸¥æ ¼åˆ†ç»„
            const groups = performColumnTruncationGrouping(elements);

            console.log(`\nâœ… åˆ†ç»„å®Œæˆï¼Œç”Ÿæˆ ${groups.length} ä¸ªåˆ†ç»„`);
            return groups;
        }

        function performColumnTruncationGrouping(elements) {
            console.log(`\nğŸ” å¼€å§‹å°„çº¿åˆ†ç»„ç®—æ³•`);
            console.log(`è¾“å…¥å…ƒç´ : ${elements.map(e => e.name).join(', ')}`);

            const rayGraph = buildRayRelationGraph(elements);
            const groups = dynamicProgrammingGrouping(elements, rayGraph);

            console.log(`\nğŸ“Š æœ€ç»ˆåˆ†ç»„ç»“æœ:`);
            groups.forEach((group, index) => {
                console.log(`  ç»„ ${index + 1}: [${group.map(e => e.name).join(', ')}]`);
            });

            return groups;
        }

        function buildRayRelationGraph(elements) {
            const graph = {
                horizontal: new Map(),
                vertical: new Map(),
                elements: new Map()
            };

            elements.forEach(element => {
                graph.horizontal.set(element.id, new Set());
                graph.vertical.set(element.id, new Set());
                graph.elements.set(element.id, element);
            });

            for (let i = 0; i < elements.length; i++) {
                for (let j = i + 1; j < elements.length; j++) {
                    const elem1 = elements[i];
                    const elem2 = elements[j];

                    if (canConnectHorizontally(elem1, elem2, elements)) {
                        graph.horizontal.get(elem1.id).add(elem2.id);
                        graph.horizontal.get(elem2.id).add(elem1.id);
                    }

                    if (canConnectVertically(elem1, elem2, elements)) {
                        graph.vertical.get(elem1.id).add(elem2.id);
                        graph.vertical.get(elem2.id).add(elem1.id);
                    }
                }
            }

            return graph;
        }

        function canConnectHorizontally(elem1, elem2, allElements) {
            const yOverlap = !(elem1.y + elem1.height <= elem2.y || elem2.y + elem2.height <= elem1.y);
            return yOverlap && !isHorizontalRayBlocked(elem1, elem2, allElements);
        }

        function canConnectVertically(elem1, elem2, allElements) {
            const xOverlap = !(elem1.x + elem1.width <= elem2.x || elem2.x + elem2.width <= elem1.x);
            return xOverlap && !isVerticalRayBlocked(elem1, elem2, allElements);
        }

        function dynamicProgrammingGrouping(elements, rayGraph) {
            const validGroupings = findAllValidGroupings(elements, rayGraph);

            if (validGroupings.length === 0) {
                console.log(`âš ï¸ æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆåˆ†ç»„æ–¹æ¡ˆï¼Œä½¿ç”¨å•å…ƒç´ åˆ†ç»„`);
                return elements.map(e => [e]);
            }

            console.log(`\nğŸ¯ è¯„ä¼° ${validGroupings.length} ç§åˆ†ç»„æ–¹æ¡ˆ:`);

            let bestSolution = null;
            let bestScore = Infinity;

            validGroupings.forEach((grouping, index) => {
                const score = calculateGroupingScore(grouping);
                console.log(`  æ–¹æ¡ˆ ${index + 1}: ${grouping.length} ç»„, å¾—åˆ†: ${score.total}`);
                grouping.forEach((group, groupIndex) => {
                    console.log(`    ç»„ ${groupIndex + 1}: [${group.map(e => e.name).join(', ')}]`);
                });

                if (score.total < bestScore) {
                    bestScore = score.total;
                    bestSolution = grouping;
                    console.log(`    âœ… å½“å‰æœ€ä½³æ–¹æ¡ˆ!`);
                }
            });

            console.log(`\nğŸ† é€‰æ‹©æ–¹æ¡ˆï¼Œå¾—åˆ†: ${bestScore}`);
            return bestSolution;
        }

        function findAllValidGroupings(elements, rayGraph) {
            const connectedComponents = findAllConnectedComponents(elements, rayGraph);
            const allGroupings = [];

            if (connectedComponents.length === 1 && connectedComponents[0].length > 1) {
                const component = connectedComponents[0];
                const subGroupings = findValidSubGroupings(component, rayGraph);
                allGroupings.push(...subGroupings);
            } else {
                const componentGroupings = connectedComponents.map(component => {
                    if (component.length === 1) {
                        return [[component]];
                    } else {
                        return findValidSubGroupings(component, rayGraph);
                    }
                });

                allGroupings.push(...combineComponentGroupings(componentGroupings));
            }

            return allGroupings;
        }

        function findAllConnectedComponents(elements, rayGraph) {
            const basicComponents = findBasicConnectedComponents(elements, rayGraph);
            console.log(`\nğŸ“¦ åŸºç¡€è¿é€šåˆ†é‡:`);
            basicComponents.forEach((component, index) => {
                console.log(`  åˆ†é‡ ${index + 1}: [${component.map(e => e.name).join(', ')}]`);
            });

            const continuousComponents = mergeContinuousComponents(basicComponents, rayGraph);
            if (continuousComponents.length !== basicComponents.length) {
                console.log(`\nğŸ”— è¿ç»­æ€§åˆå¹¶å:`);
                continuousComponents.forEach((component, index) => {
                    console.log(`  åˆ†é‡ ${index + 1}: [${component.map(e => e.name).join(', ')}]`);
                });
            }

            return continuousComponents;
        }

        function findBasicConnectedComponents(elements, rayGraph) {
            const components = [];
            const visited = new Set();

            for (const element of elements) {
                if (visited.has(element.id)) continue;

                const component = [];
                const queue = [element];
                const componentVisited = new Set([element.id]);

                while (queue.length > 0) {
                    const current = queue.shift();
                    component.push(current);
                    visited.add(current.id);

                    const allConnections = new Set([
                        ...(rayGraph.horizontal.get(current.id) || []),
                        ...(rayGraph.vertical.get(current.id) || [])
                    ]);

                    for (const connectedId of allConnections) {
                        if (!componentVisited.has(connectedId)) {
                            const connectedElement = rayGraph.elements.get(connectedId);
                            if (connectedElement) {
                                queue.push(connectedElement);
                                componentVisited.add(connectedId);
                            }
                        }
                    }
                }

                components.push(component);
            }

            return components;
        }

        function mergeContinuousComponents(components, rayGraph) {
            if (components.length <= 1) return components;

            const continuousGroups = [];
            const processed = new Set();

            for (let i = 0; i < components.length; i++) {
                if (processed.has(i)) continue;

                const continuousGroup = [components[i]];
                processed.add(i);

                for (let j = i + 1; j < components.length; j++) {
                    if (processed.has(j)) continue;

                    if (areComponentsContinuous(components[i], components[j])) {
                        continuousGroup.push(components[j]);
                        processed.add(j);
                    }
                }

                if (continuousGroup.length > 1) {
                    const mergedComponent = continuousGroup.flat();
                    continuousGroups.push(mergedComponent);
                } else {
                    continuousGroups.push(components[i]);
                }
            }

            return continuousGroups;
        }

        function areComponentsContinuous(component1, component2) {
            const bounds1 = calculateGroupBounds(component1);
            const bounds2 = calculateGroupBounds(component2);

            const sameRow = Math.abs(bounds1.y - bounds2.y) <= Math.max(bounds1.height, bounds2.height) * 0.5;
            const sameColumn = Math.abs(bounds1.x - bounds2.x) <= Math.max(bounds1.width, bounds2.width) * 0.5;

            if (sameRow) {
                const horizontalGap = Math.min(
                    Math.abs(bounds1.x + bounds1.width - bounds2.x),
                    Math.abs(bounds2.x + bounds2.width - bounds1.x)
                );
                const avgWidth = (bounds1.width + bounds2.width) / 2;
                return horizontalGap <= avgWidth * 0.8;
            }

            if (sameColumn) {
                const verticalGap = Math.min(
                    Math.abs(bounds1.y + bounds1.height - bounds2.y),
                    Math.abs(bounds2.y + bounds2.height - bounds1.y)
                );
                const avgHeight = (bounds1.height + bounds2.height) / 2;
                return verticalGap <= avgHeight * 0.8;
            }

            return false;
        }

        // ğŸ¯ æ‰¾åˆ°è¿é€šåˆ†é‡çš„æœ‰æ•ˆå­åˆ†ç»„
        function findValidSubGroupings(component, rayGraph) {
            console.log(`\nğŸ” ä¸ºè¿é€šåˆ†é‡å¯»æ‰¾å­åˆ†ç»„: [${component.map(e => e.name).join(', ')}]`);

            const subGroupings = [];

            // æ–¹æ¡ˆ1ï¼šä¿æŒæ•´ä½“
            if (isHighlyConnected(component, rayGraph) && isSemanticallyCoherent(component)) {
                subGroupings.push([component]);
                console.log(`  æ–¹æ¡ˆ1 - ä¿æŒæ•´ä½“: [${component.map(e => e.name).join(', ')}]`);
            }

            // æ–¹æ¡ˆ2ï¼šæŒ‰è¡Œåˆ†ç»„
            const rowGroups = groupByRayDirection(component, rayGraph, 'horizontal');
            if (rowGroups.length > 1) {
                subGroupings.push(rowGroups);
                console.log(`  æ–¹æ¡ˆ2 - æŒ‰è¡Œåˆ†ç»„:`);
                rowGroups.forEach((group, i) => {
                    console.log(`    è¡Œ ${i + 1}: [${group.map(e => e.name).join(', ')}]`);
                });
            }

            // æ–¹æ¡ˆ3ï¼šæŒ‰åˆ—åˆ†ç»„
            const columnGroups = groupByRayDirection(component, rayGraph, 'vertical');
            if (columnGroups.length > 1) {
                subGroupings.push(columnGroups);
                console.log(`  æ–¹æ¡ˆ3 - æŒ‰åˆ—åˆ†ç»„:`);
                columnGroups.forEach((group, i) => {
                    console.log(`    åˆ— ${i + 1}: [${group.map(e => e.name).join(', ')}]`);
                });
            }

            // æ–¹æ¡ˆ4ï¼šè¯­ä¹‰åˆ†å‰²
            const semanticGroups = findSemanticGrouping(component, rayGraph);
            if (semanticGroups.length > 1) {
                subGroupings.push(semanticGroups);
                console.log(`  æ–¹æ¡ˆ4 - è¯­ä¹‰åˆ†ç»„:`);
                semanticGroups.forEach((group, i) => {
                    console.log(`    è¯­ä¹‰ç»„ ${i + 1}: [${group.map(e => e.name).join(', ')}]`);
                });
            }

            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ä»»ä½•æœ‰æ•ˆåˆ†ç»„ï¼Œè¿”å›å•å…ƒç´ åˆ†ç»„
            if (subGroupings.length === 0) {
                subGroupings.push(component.map(e => [e]));
                console.log(`  å›é€€ - å•å…ƒç´ åˆ†ç»„: ${component.map(e => `[${e.name}]`).join(', ')}`);
            }

            return subGroupings;
        }

        // ğŸ¯ æ£€æŸ¥è¯­ä¹‰ä¸€è‡´æ€§
        function isSemanticallyCoherent(component) {
            // ç®€å•å¯å‘å¼ï¼šå¦‚æœå…ƒç´ æ•°é‡è¾ƒå°‘ä¸”ç©ºé—´ç´§å¯†ï¼Œè®¤ä¸ºè¯­ä¹‰ç›¸å…³
            if (component.length <= 2) return true;
            if (component.length > 4) return false; // è¶…è¿‡4ä¸ªå…ƒç´ å¾ˆå¯èƒ½ä¸æ˜¯ä¸€ä¸ªè¯­ä¹‰å•å…ƒ

            // æ£€æŸ¥ç©ºé—´ç´§å¯†æ€§
            const bounds = calculateGroupBounds(component);
            const density = component.length / (bounds.width * bounds.height);

            return density > 0.001; // å¯†åº¦é˜ˆå€¼
        }

        // ğŸ¯ è¯­ä¹‰åˆ†ç»„ï¼ˆåŸºäºé—´éš™åˆ†æï¼‰
        function findSemanticGrouping(component, rayGraph) {
            console.log(`      ğŸ” è¿›è¡Œè¯­ä¹‰åˆ†ç»„åˆ†æ`);

            // æŒ‰Yåæ ‡æ’åºï¼Œåˆ†æå‚ç›´é—´éš™
            const sortedByY = [...component].sort((a, b) => a.y - b.y);
            const groups = [];
            let currentGroup = [];

            for (let i = 0; i < sortedByY.length; i++) {
                const element = sortedByY[i];

                if (currentGroup.length === 0) {
                    currentGroup.push(element);
                } else {
                    const lastElement = currentGroup[currentGroup.length - 1];
                    const gap = element.y - (lastElement.y + lastElement.height);

                    // è®¡ç®—è¯­ä¹‰åˆ†å‰²é˜ˆå€¼
                    const semanticThreshold = calculateSemanticThreshold(lastElement, element);

                    console.log(`        ğŸ“ "${lastElement.name}" åˆ° "${element.name}" é—´éš™: ${gap}, è¯­ä¹‰é˜ˆå€¼: ${semanticThreshold}`);

                    if (gap > semanticThreshold) {
                        // é—´éš™è¿‡å¤§ï¼Œå¼€å§‹æ–°ç»„
                        groups.push([...currentGroup]);
                        console.log(`        ğŸ“¦ è¯­ä¹‰åˆ†å‰²: [${currentGroup.map(e => e.name).join(', ')}]`);
                        currentGroup = [element];
                    } else {
                        // ç»§ç»­å½“å‰ç»„
                        currentGroup.push(element);
                    }
                }
            }

            if (currentGroup.length > 0) {
                groups.push(currentGroup);
                console.log(`        ğŸ“¦ æœ€åè¯­ä¹‰ç»„: [${currentGroup.map(e => e.name).join(', ')}]`);
            }

            return groups;
        }

        // ğŸ¯ è®¡ç®—è¯­ä¹‰åˆ†å‰²é˜ˆå€¼
        function calculateSemanticThreshold(elem1, elem2) {
            // åŸºäºå…ƒç´ é«˜åº¦çš„åŠ¨æ€é˜ˆå€¼
            const avgHeight = (elem1.height + elem2.height) / 2;

            // å¦‚æœå…ƒç´ é«˜åº¦å·®å¼‚å¾ˆå¤§ï¼Œå¯èƒ½æ˜¯ä¸åŒç±»å‹çš„ä¿¡æ¯
            const heightDiff = Math.abs(elem1.height - elem2.height);
            const heightRatio = heightDiff / avgHeight;

            // åŸºç¡€é˜ˆå€¼ï¼šå¹³å‡é«˜åº¦çš„30%
            let threshold = avgHeight * 0.3;

            // å¦‚æœé«˜åº¦å·®å¼‚å¤§ï¼Œé™ä½é˜ˆå€¼ï¼ˆæ›´å®¹æ˜“åˆ†å‰²ï¼‰
            if (heightRatio > 0.5) {
                threshold *= 0.7;
            }

            // å¦‚æœå…ƒç´ å¾ˆå°ï¼Œä½¿ç”¨å›ºå®šæœ€å°é˜ˆå€¼
            threshold = Math.max(threshold, 5);

            return threshold;
        }

        // ğŸ¯ æ£€æŸ¥åˆ†ç»„æ˜¯å¦ç­‰ä»·
        function isEquivalentGrouping(groups1, groups2) {
            if (groups1.length !== groups2.length) return false;

            // ç®€åŒ–æ£€æŸ¥ï¼šæ¯”è¾ƒæ¯ç»„çš„å…ƒç´ æ•°é‡
            const sizes1 = groups1.map(g => g.length).sort();
            const sizes2 = groups2.map(g => g.length).sort();

            return sizes1.every((size, index) => size === sizes2[index]);
        }

        // ğŸ¯ è®¡ç®—åˆ†ç»„è¾¹ç•Œ
        function calculateGroupBounds(group) {
            const minX = Math.min(...group.map(e => e.x));
            const maxX = Math.max(...group.map(e => e.x + e.width));
            const minY = Math.min(...group.map(e => e.y));
            const maxY = Math.max(...group.map(e => e.y + e.height));

            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        // ğŸ¯ æ£€æŸ¥æ˜¯å¦é«˜åº¦è¿æ¥
        function isHighlyConnected(component, rayGraph) {
            if (component.length <= 2) return true;

            const totalPossibleConnections = component.length * (component.length - 1) / 2;
            const actualConnections = calculateGroupConnections(component, rayGraph);
            const connectionRatio = actualConnections / totalPossibleConnections;

            return connectionRatio > 0.6; // 60%ä»¥ä¸Šçš„è¿æ¥ç‡è®¤ä¸ºæ˜¯é«˜åº¦è¿æ¥
        }

        // ğŸ¯ æŒ‰å°„çº¿æ–¹å‘åˆ†ç»„
        function groupByRayDirection(component, rayGraph, direction) {
            const groups = [];
            const processed = new Set();

            for (const element of component) {
                if (processed.has(element.id)) continue;

                const group = [];
                const queue = [element];
                const visited = new Set([element.id]);

                while (queue.length > 0) {
                    const current = queue.shift();
                    group.push(current);
                    processed.add(current.id);

                    // åªè€ƒè™‘æŒ‡å®šæ–¹å‘çš„è¿æ¥
                    const connections = rayGraph[direction].get(current.id) || new Set();
                    for (const connectedId of connections) {
                        if (!visited.has(connectedId) && !processed.has(connectedId)) {
                            const connectedElement = rayGraph.elements.get(connectedId);
                            if (connectedElement && component.some(e => e.id === connectedId)) {
                                queue.push(connectedElement);
                                visited.add(connectedId);
                            }
                        }
                    }
                }

                if (group.length > 0) {
                    groups.push(group);
                }
            }

            return groups;
        }

        // ğŸ¯ æ‰¾åˆ°æ··åˆåˆ†ç»„
        function findMixedGrouping(component, rayGraph) {
            // ä½¿ç”¨è´ªå¿ƒç®—æ³•ï¼Œä¼˜å…ˆé€‰æ‹©è¿æ¥æœ€å¯†é›†çš„å­ç»„
            const groups = [];
            const processed = new Set();

            // æŒ‰è¿æ¥åº¦æ’åºå…ƒç´ 
            const sortedElements = component.sort((a, b) => {
                const aConnections = (rayGraph.horizontal.get(a.id)?.size || 0) + (rayGraph.vertical.get(a.id)?.size || 0);
                const bConnections = (rayGraph.horizontal.get(b.id)?.size || 0) + (rayGraph.vertical.get(b.id)?.size || 0);
                return bConnections - aConnections;
            });

            for (const element of sortedElements) {
                if (processed.has(element.id)) continue;

                const group = findOptimalSubGroup(element, component, rayGraph, processed);
                if (group.length > 0) {
                    groups.push(group);
                    group.forEach(e => processed.add(e.id));
                }
            }

            return groups;
        }

        // ğŸ¯ æ‰¾åˆ°æœ€ä¼˜å­ç»„
        function findOptimalSubGroup(startElement, component, rayGraph, processed) {
            const group = [startElement];
            const candidates = component.filter(e => !processed.has(e.id) && e.id !== startElement.id);

            // è´ªå¿ƒæ·»åŠ æœ€ç›¸å…³çš„å…ƒç´ 
            while (candidates.length > 0) {
                let bestCandidate = null;
                let bestScore = -1;

                for (const candidate of candidates) {
                    const score = calculateGroupRelevance(candidate, group, rayGraph);
                    if (score > bestScore) {
                        bestScore = score;
                        bestCandidate = candidate;
                    }
                }

                if (bestCandidate && bestScore > 0) {
                    group.push(bestCandidate);
                    candidates.splice(candidates.indexOf(bestCandidate), 1);
                } else {
                    break;
                }
            }

            return group;
        }

        // ğŸ¯ è®¡ç®—ç»„ç›¸å…³æ€§
        function calculateGroupRelevance(candidate, group, rayGraph) {
            let score = 0;

            for (const groupMember of group) {
                if (rayGraph.horizontal.get(candidate.id)?.has(groupMember.id)) score += 2;
                if (rayGraph.vertical.get(candidate.id)?.has(groupMember.id)) score += 2;
            }

            return score;
        }

        // ğŸ¯ ç»„åˆåˆ†é‡åˆ†ç»„
        function combineComponentGroupings(componentGroupings) {
            // ç®€åŒ–ç‰ˆæœ¬ï¼šå–æ¯ä¸ªåˆ†é‡çš„ç¬¬ä¸€ä¸ªåˆ†ç»„æ–¹æ¡ˆ
            const combined = [];
            for (const groupings of componentGroupings) {
                if (groupings.length > 0) {
                    combined.push(...groupings[0]);
                }
            }
            return [combined];
        }

        // ğŸ¯ è®¡ç®—åˆ†ç»„å¾—åˆ†ï¼ˆæ·±åº¦Ã—å¹¿åº¦ + å‡è¡¡æ€§æƒ©ç½šï¼‰
        function calculateGroupingScore(groups) {
            // åŸºç¡€æŒ‡æ ‡
            const maxGroupSize = Math.max(...groups.map(g => g.length));
            const groupCount = groups.length;
            const totalElements = groups.reduce((sum, g) => sum + g.length, 0);

            // æ·±åº¦ = æœ€å¤§ç»„å†…å…ƒç´ æ•°
            // å¹¿åº¦ = æ€»åˆ†ç»„æ•°
            const depth = maxGroupSize;
            const breadth = groupCount;
            const baseScore = depth * breadth;

            // å‡è¡¡æ€§åˆ†æ
            const avgGroupSize = totalElements / groupCount;
            const sizeVariance = groups.reduce((sum, g) => sum + Math.pow(g.length - avgGroupSize, 2), 0) / groupCount;
            const balancePenalty = sizeVariance * 0.5; // æ–¹å·®æƒ©ç½š

            // æç«¯å€¼æƒ©ç½š
            const extremePenalty = calculateExtremePenalty(depth, breadth, totalElements);

            const total = baseScore + balancePenalty + extremePenalty;

            return {
                depth,
                breadth,
                baseScore,
                balancePenalty: Math.round(balancePenalty * 100) / 100,
                extremePenalty: Math.round(extremePenalty * 100) / 100,
                total: Math.round(total * 100) / 100
            };
        }

        // ğŸ¯ è®¡ç®—æç«¯å€¼æƒ©ç½š
        function calculateExtremePenalty(depth, breadth, totalElements) {
            let penalty = 0;

            // ç†æƒ³çš„å¹³è¡¡ç‚¹ï¼šæ·±åº¦å’Œå¹¿åº¦æ¥è¿‘ sqrt(totalElements)
            const idealBalance = Math.sqrt(totalElements);

            // æ·±åº¦è¿‡å¤§æƒ©ç½šï¼ˆé¿å…å•ä¸ªç»„è¿‡å¤§ï¼‰
            if (depth > idealBalance * 1.5) {
                penalty += (depth - idealBalance * 1.5) * 2;
            }

            // å¹¿åº¦è¿‡å¤§æƒ©ç½šï¼ˆé¿å…åˆ†ç»„è¿‡å¤šï¼‰
            if (breadth > idealBalance * 1.5) {
                penalty += (breadth - idealBalance * 1.5) * 2;
            }

            // æ·±åº¦è¿‡å°æƒ©ç½šï¼ˆé¿å…åˆ†ç»„è¿‡ç»†ï¼‰
            if (depth < 2 && totalElements > 4) {
                penalty += (2 - depth) * 3;
            }

            // å¹¿åº¦è¿‡å°æƒ©ç½šï¼ˆé¿å…å•ä¸€å¤§ç»„ï¼‰
            if (breadth < 2 && totalElements > 4) {
                penalty += (2 - breadth) * 5;
            }

            return penalty;
        }



        // ğŸ¯ æ„å»ºç›®æ ‡å¤§å°çš„åˆ†ç»„
        function buildTargetSizeGroup(startElement, allElements, rayGraph, processed, targetSize) {
            const group = [startElement];
            const candidates = allElements.filter(e => !processed.has(e.id) && e.id !== startElement.id);

            // æŒ‰è¿æ¥å¼ºåº¦æ’åºå€™é€‰å…ƒç´ 
            const scoredCandidates = candidates.map(candidate => ({
                element: candidate,
                score: calculateConnectionScore(startElement, candidate, rayGraph, group)
            })).sort((a, b) => b.score - a.score);

            // è´ªå¿ƒæ·»åŠ å…ƒç´ ç›´åˆ°è¾¾åˆ°ç›®æ ‡å¤§å°
            for (const { element } of scoredCandidates) {
                if (group.length >= targetSize) break;

                // æ£€æŸ¥æ˜¯å¦ä¸ç»„å†…ä»»ä½•å…ƒç´ æœ‰è¿æ¥
                if (hasConnectionToGroup(element, group, rayGraph)) {
                    group.push(element);
                }
            }

            return group;
        }

        // ğŸ¯ è®¡ç®—è¿æ¥å¾—åˆ†
        function calculateConnectionScore(anchor, candidate, rayGraph, currentGroup) {
            let score = 0;

            // ä¸é”šç‚¹çš„ç›´æ¥è¿æ¥
            if (rayGraph.horizontal.get(anchor.id)?.has(candidate.id)) score += 3;
            if (rayGraph.vertical.get(anchor.id)?.has(candidate.id)) score += 3;

            // ä¸ç»„å†…å…¶ä»–å…ƒç´ çš„è¿æ¥
            for (const groupMember of currentGroup) {
                if (rayGraph.horizontal.get(groupMember.id)?.has(candidate.id)) score += 2;
                if (rayGraph.vertical.get(groupMember.id)?.has(candidate.id)) score += 2;
            }

            // è·ç¦»æƒ©ç½š
            const distance = calculateMinDistance(anchor, candidate);
            score -= distance * 0.01;

            return score;
        }

        // ğŸ¯ æ£€æŸ¥æ˜¯å¦ä¸åˆ†ç»„æœ‰è¿æ¥
        function hasConnectionToGroup(element, group, rayGraph) {
            return group.some(groupMember => {
                return rayGraph.horizontal.get(element.id)?.has(groupMember.id) ||
                       rayGraph.vertical.get(element.id)?.has(groupMember.id);
            });
        }

        // ğŸ¯ è¯„ä¼°åˆ†ç»„å‡è¡¡æ€§
        function evaluateGroupBalance(group, idealSize, rayGraph) {
            if (group.length === 0) return -Infinity;

            // å¤§å°æ¥è¿‘ç†æƒ³å€¼çš„å¾—åˆ†æ›´é«˜
            const sizeScore = idealSize - Math.abs(group.length - idealSize);

            // è¿æ¥å¯†åº¦å¾—åˆ†
            const connectionDensity = rayGraph ?
                calculateGroupConnections(group, rayGraph) / Math.max(1, group.length - 1) : 0;

            return sizeScore + connectionDensity;
        }

        // ğŸ¯ æ‰¾åˆ°æœ€ä¼˜è¡Œåˆ†ç»„
        function findOptimalRows(elements, rayGraph) {
            console.log(`      ğŸ” å¯»æ‰¾æœ€ä¼˜è¡Œåˆ†ç»„`);

            const rows = [];
            const processed = new Set();

            const sortedByY = [...elements].sort((a, b) => a.y - b.y);

            for (const element of sortedByY) {
                if (processed.has(element.id)) continue;

                const row = findMaxHorizontalComponent(element, elements, rayGraph, processed);

                if (row.length > 0) {
                    rows.push(row);
                    row.forEach(e => processed.add(e.id));
                }
            }

            return rows;
        }

        // ğŸ¯ åœ¨è¡Œå†…æ‰¾åˆ°æœ€ä¼˜åˆ—åˆ†ç»„
        function findOptimalColumnsInRow(rowElements, rayGraph) {
            console.log(`      ğŸ” åœ¨è¡Œå†…å¯»æ‰¾æœ€ä¼˜åˆ—åˆ†ç»„`);

            const columns = [];
            const processed = new Set();

            const sortedByX = [...rowElements].sort((a, b) => a.x - b.x);

            for (const element of sortedByX) {
                if (processed.has(element.id)) continue;

                const column = findMaxVerticalComponent(element, rowElements, rayGraph, processed);

                if (column.length > 0) {
                    columns.push(column);
                    column.forEach(e => processed.add(e.id));
                }
            }

            return columns;
        }

        // ğŸ¯ æ‰¾åˆ°æœ€å¤§è¿é€šåˆ†é‡
        function findMaxConnectedComponent(startElement, allElements, rayGraph, processed) {
            const component = [];
            const queue = [startElement];
            const visited = new Set([startElement.id]);

            while (queue.length > 0) {
                const current = queue.shift();
                if (processed.has(current.id)) continue;

                component.push(current);

                // éå†æ‰€æœ‰è¿æ¥ï¼ˆæ°´å¹³+å‚ç›´ï¼‰
                const allConnections = new Set([
                    ...(rayGraph.horizontal.get(current.id) || []),
                    ...(rayGraph.vertical.get(current.id) || [])
                ]);

                for (const connectedId of allConnections) {
                    if (!visited.has(connectedId) && !processed.has(connectedId)) {
                        const connectedElement = rayGraph.elements.get(connectedId);
                        if (connectedElement) {
                            queue.push(connectedElement);
                            visited.add(connectedId);
                        }
                    }
                }
            }

            return component;
        }

        // ğŸ¯ è®¡ç®—åˆ†ç»„å†…è¿æ¥æ•°
        function calculateGroupConnections(group, rayGraph) {
            let connections = 0;

            for (let i = 0; i < group.length; i++) {
                for (let j = i + 1; j < group.length; j++) {
                    const elem1 = group[i];
                    const elem2 = group[j];

                    const horizontalConnected = rayGraph.horizontal.get(elem1.id)?.has(elem2.id);
                    const verticalConnected = rayGraph.vertical.get(elem1.id)?.has(elem2.id);

                    if (horizontalConnected || verticalConnected) {
                        connections++;
                    }
                }
            }

            return connections;
        }

        // ğŸ¯ æ‰¾åˆ°æœ€ä¼˜åˆ—åˆ†ç»„
        function findOptimalColumns(elements, rayGraph) {
            console.log(`  ğŸ” å¯»æ‰¾æœ€ä¼˜åˆ—åˆ†ç»„`);

            const columns = [];
            const processed = new Set();

            // æŒ‰Xåæ ‡æ’åºï¼Œä¼˜å…ˆå¤„ç†å·¦ä¾§å…ƒç´ 
            const sortedByX = [...elements].sort((a, b) => a.x - b.x);

            for (const element of sortedByX) {
                if (processed.has(element.id)) continue;

                // ä½¿ç”¨åŠ¨æ€è§„åˆ’æ‰¾åˆ°åŒ…å«å½“å‰å…ƒç´ çš„æœ€å¤§å‚ç›´è¿é€šåˆ†é‡
                const column = findMaxVerticalComponent(element, elements, rayGraph, processed);

                if (column.length > 0) {
                    columns.push(column);
                    column.forEach(e => processed.add(e.id));

                    // è®¡ç®—åˆ—çš„è¾¹ç•Œä¿¡æ¯
                    const columnBounds = calculateColumnBounds(column);
                    console.log(`    ğŸ“¦ åˆ— ${columns.length}: [${column.map(e => e.name).join(', ')}] å®½åº¦=${columnBounds.width}`);
                }
            }

            return columns;
        }

        // ğŸ¯ æ‰¾åˆ°æœ€å¤§å‚ç›´è¿é€šåˆ†é‡
        function findMaxVerticalComponent(startElement, allElements, rayGraph, processed) {
            const component = [];
            const queue = [startElement];
            const visited = new Set([startElement.id]);

            while (queue.length > 0) {
                const current = queue.shift();
                if (processed.has(current.id)) continue;

                component.push(current);

                // éå†æ‰€æœ‰å‚ç›´è¿æ¥çš„å…ƒç´ 
                const verticalConnections = rayGraph.vertical.get(current.id) || new Set();
                for (const connectedId of verticalConnections) {
                    if (!visited.has(connectedId) && !processed.has(connectedId)) {
                        const connectedElement = rayGraph.elements.get(connectedId);
                        queue.push(connectedElement);
                        visited.add(connectedId);
                    }
                }
            }

            return component;
        }

        // ğŸ¯ åœ¨åˆ—å†…æ‰¾åˆ°æœ€ä¼˜è¡Œåˆ†ç»„
        function findOptimalRowsInColumn(columnElements, rayGraph) {
            console.log(`    ğŸ” åœ¨åˆ—å†…å¯»æ‰¾æœ€ä¼˜è¡Œåˆ†ç»„`);

            const rows = [];
            const processed = new Set();

            // æŒ‰Yåæ ‡æ’åºï¼Œä¼˜å…ˆå¤„ç†é¡¶éƒ¨å…ƒç´ 
            const sortedByY = [...columnElements].sort((a, b) => a.y - b.y);

            for (const element of sortedByY) {
                if (processed.has(element.id)) continue;

                // ä½¿ç”¨åŠ¨æ€è§„åˆ’æ‰¾åˆ°åŒ…å«å½“å‰å…ƒç´ çš„æœ€å¤§æ°´å¹³è¿é€šåˆ†é‡
                const row = findMaxHorizontalComponent(element, columnElements, rayGraph, processed);

                if (row.length > 0) {
                    rows.push(row);
                    row.forEach(e => processed.add(e.id));

                    // è®¡ç®—è¡Œçš„è¾¹ç•Œä¿¡æ¯
                    const rowBounds = calculateRowBounds(row);
                    console.log(`      ğŸ“¦ è¡Œ ${rows.length}: [${row.map(e => e.name).join(', ')}] é«˜åº¦=${rowBounds.height}`);
                }
            }

            return rows;
        }

        // ğŸ¯ æ‰¾åˆ°æœ€å¤§æ°´å¹³è¿é€šåˆ†é‡
        function findMaxHorizontalComponent(startElement, columnElements, rayGraph, processed) {
            const component = [];
            const queue = [startElement];
            const visited = new Set([startElement.id]);

            while (queue.length > 0) {
                const current = queue.shift();
                if (processed.has(current.id)) continue;

                component.push(current);

                // éå†æ‰€æœ‰æ°´å¹³è¿æ¥çš„å…ƒç´ ï¼ˆé™åˆ¶åœ¨å½“å‰åˆ—å†…ï¼‰
                const horizontalConnections = rayGraph.horizontal.get(current.id) || new Set();
                for (const connectedId of horizontalConnections) {
                    if (!visited.has(connectedId) && !processed.has(connectedId)) {
                        const connectedElement = rayGraph.elements.get(connectedId);
                        // ç¡®ä¿è¿æ¥çš„å…ƒç´ åœ¨å½“å‰åˆ—å†…
                        if (columnElements.some(e => e.id === connectedId)) {
                            queue.push(connectedElement);
                            visited.add(connectedId);
                        }
                    }
                }
            }

            return component;
        }

        // ğŸ¯ è®¡ç®—åˆ—è¾¹ç•Œ
        function calculateColumnBounds(column) {
            const minX = Math.min(...column.map(e => e.x));
            const maxX = Math.max(...column.map(e => e.x + e.width));
            const minY = Math.min(...column.map(e => e.y));
            const maxY = Math.max(...column.map(e => e.y + e.height));

            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        // ğŸ¯ è®¡ç®—è¡Œè¾¹ç•Œ
        function calculateRowBounds(row) {
            const minX = Math.min(...row.map(e => e.x));
            const maxX = Math.max(...row.map(e => e.x + e.width));
            const minY = Math.min(...row.map(e => e.y));
            const maxY = Math.max(...row.map(e => e.y + e.height));

            return {
                x: minX,
                y: minY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        // ğŸ¯ é€’å½’å°„çº¿åˆ†ç»„
        function recursiveRayGrouping(elements, depth) {
            const indent = '  '.repeat(depth);
            console.log(`${indent}ğŸ” é€’å½’åˆ†ç»„ (æ·±åº¦${depth}): [${elements.map(e => e.name).join(', ')}]`);

            if (elements.length <= 1) {
                console.log(`${indent}ğŸ“¦ å•å…ƒç´ æˆ–ç©ºç»„ï¼Œç›´æ¥è¿”å›`);
                return elements.length > 0 ? [elements] : [];
            }

            // 1. å°è¯•æ°´å¹³å°„çº¿åˆ†ç»„
            const horizontalGroups = groupByHorizontalRays(elements, depth);

            if (horizontalGroups.length > 1) {
                // æ°´å¹³åˆ†ç»„æˆåŠŸï¼Œé€’å½’å¤„ç†æ¯ä¸ªæ°´å¹³ç»„
                console.log(`${indent}âœ… æ°´å¹³åˆ†ç»„æˆåŠŸï¼Œåˆ†æˆ ${horizontalGroups.length} ç»„`);
                const finalGroups = [];

                horizontalGroups.forEach((hGroup, index) => {
                    console.log(`${indent}ğŸ”„ é€’å½’å¤„ç†æ°´å¹³ç»„ ${index + 1}: [${hGroup.map(e => e.name).join(', ')}]`);
                    const subGroups = recursiveRayGrouping(hGroup, depth + 1);
                    finalGroups.push(...subGroups);
                });

                return finalGroups;
            } else {
                // æ°´å¹³åˆ†ç»„å¤±è´¥ï¼Œå°è¯•å‚ç›´å°„çº¿åˆ†ç»„
                console.log(`${indent}ğŸ”„ æ°´å¹³åˆ†ç»„å¤±è´¥ï¼Œå°è¯•å‚ç›´åˆ†ç»„`);
                const verticalGroups = groupByVerticalRays(elements, depth);

                if (verticalGroups.length > 1) {
                    console.log(`${indent}âœ… å‚ç›´åˆ†ç»„æˆåŠŸï¼Œåˆ†æˆ ${verticalGroups.length} ç»„`);
                    const finalGroups = [];

                    verticalGroups.forEach((vGroup, index) => {
                        console.log(`${indent}ğŸ”„ é€’å½’å¤„ç†å‚ç›´ç»„ ${index + 1}: [${vGroup.map(e => e.name).join(', ')}]`);
                        const subGroups = recursiveRayGrouping(vGroup, depth + 1);
                        finalGroups.push(...subGroups);
                    });

                    return finalGroups;
                } else {
                    // æ— æ³•è¿›ä¸€æ­¥åˆ†ç»„ï¼Œè¿”å›æ•´ä½“
                    console.log(`${indent}ğŸ“¦ æ— æ³•è¿›ä¸€æ­¥åˆ†ç»„ï¼Œä½œä¸ºæ•´ä½“: [${elements.map(e => e.name).join(', ')}]`);
                    return [elements];
                }
            }
        }

        // ğŸ¯ åŸºäºæ°´å¹³å°„çº¿åˆ†ç»„
        function groupByHorizontalRays(elements, depth) {
            const indent = '  '.repeat(depth);
            console.log(`${indent}ğŸ” å°è¯•æ°´å¹³å°„çº¿åˆ†ç»„`);

            // æŒ‰Yåæ ‡æ’åº
            const sortedByY = [...elements].sort((a, b) => a.y - b.y);

            const groups = [];
            const processed = new Set();

            for (const element of sortedByY) {
                if (processed.has(element.id)) continue;

                // æ‰¾åˆ°æ‰€æœ‰èƒ½é€šè¿‡æ°´å¹³å°„çº¿è¿æ¥çš„å…ƒç´ 
                const horizontalGroup = findHorizontalRayGroup(element, elements, processed);

                if (horizontalGroup.length > 0) {
                    groups.push(horizontalGroup);
                    horizontalGroup.forEach(e => processed.add(e.id));
                    console.log(`${indent}  ğŸ“¦ æ°´å¹³ç»„: [${horizontalGroup.map(e => e.name).join(', ')}]`);
                }
            }

            console.log(`${indent}ğŸ“Š æ°´å¹³åˆ†ç»„ç»“æœ: ${groups.length} ç»„`);
            return groups;
        }

        // ğŸ¯ åŸºäºå‚ç›´å°„çº¿åˆ†ç»„
        function groupByVerticalRays(elements, depth) {
            const indent = '  '.repeat(depth);
            console.log(`${indent}ğŸ” å°è¯•å‚ç›´å°„çº¿åˆ†ç»„`);

            // æŒ‰Xåæ ‡æ’åº
            const sortedByX = [...elements].sort((a, b) => a.x - b.x);

            const groups = [];
            const processed = new Set();

            for (const element of sortedByX) {
                if (processed.has(element.id)) continue;

                // æ‰¾åˆ°æ‰€æœ‰èƒ½é€šè¿‡å‚ç›´å°„çº¿è¿æ¥çš„å…ƒç´ 
                const verticalGroup = findVerticalRayGroup(element, elements, processed);

                if (verticalGroup.length > 0) {
                    groups.push(verticalGroup);
                    verticalGroup.forEach(e => processed.add(e.id));
                    console.log(`${indent}  ğŸ“¦ å‚ç›´ç»„: [${verticalGroup.map(e => e.name).join(', ')}]`);
                }
            }

            console.log(`${indent}ğŸ“Š å‚ç›´åˆ†ç»„ç»“æœ: ${groups.length} ç»„`);
            return groups;
        }

        // ğŸ¯ æ‰¾åˆ°æ°´å¹³å°„çº¿è¿æ¥çš„ç»„
        function findHorizontalRayGroup(startElement, allElements, processed) {
            const group = [startElement];
            const queue = [startElement];
            const inGroup = new Set([startElement.id]);

            while (queue.length > 0) {
                const current = queue.shift();

                // å‘å°„å·¦å³å°„çº¿
                for (const candidate of allElements) {
                    if (processed.has(candidate.id) || inGroup.has(candidate.id)) continue;

                    // æ£€æŸ¥æ˜¯å¦åœ¨åŒä¸€æ°´å¹³çº¿ä¸Šï¼ˆYè½´é‡å ï¼‰
                    const yOverlap = !(
                        current.y + current.height <= candidate.y ||
                        candidate.y + candidate.height <= current.y
                    );

                    if (yOverlap) {
                        // æ£€æŸ¥æ°´å¹³å°„çº¿æ˜¯å¦è¢«é˜»æŒ¡
                        if (!isHorizontalRayBlocked(current, candidate, allElements)) {
                            group.push(candidate);
                            queue.push(candidate);
                            inGroup.add(candidate.id);
                        }
                    }
                }
            }

            return group;
        }

        // ğŸ¯ æ‰¾åˆ°å‚ç›´å°„çº¿è¿æ¥çš„ç»„
        function findVerticalRayGroup(startElement, allElements, processed) {
            const group = [startElement];
            const queue = [startElement];
            const inGroup = new Set([startElement.id]);

            while (queue.length > 0) {
                const current = queue.shift();

                // å‘å°„ä¸Šä¸‹å°„çº¿
                for (const candidate of allElements) {
                    if (processed.has(candidate.id) || inGroup.has(candidate.id)) continue;

                    // æ£€æŸ¥æ˜¯å¦åœ¨åŒä¸€å‚ç›´çº¿ä¸Šï¼ˆXè½´é‡å ï¼‰
                    const xOverlap = !(
                        current.x + current.width <= candidate.x ||
                        candidate.x + candidate.width <= current.x
                    );

                    if (xOverlap) {
                        // æ£€æŸ¥å‚ç›´å°„çº¿æ˜¯å¦è¢«é˜»æŒ¡
                        if (!isVerticalRayBlocked(current, candidate, allElements)) {
                            group.push(candidate);
                            queue.push(candidate);
                            inGroup.add(candidate.id);
                        }
                    }
                }
            }

            return group;
        }

        // ğŸ¯ æ£€æŸ¥æ°´å¹³å°„çº¿æ˜¯å¦è¢«é˜»æŒ¡
        function isHorizontalRayBlocked(elem1, elem2, allElements) {
            // åˆ›å»ºæ°´å¹³å°„çº¿è·¯å¾„
            const rayPath = {
                left: Math.min(elem1.x + elem1.width, elem2.x),
                right: Math.max(elem1.x, elem2.x + elem2.width),
                top: Math.max(elem1.y, elem2.y),
                bottom: Math.min(elem1.y + elem1.height, elem2.y + elem2.height)
            };

            // å¦‚æœæ²¡æœ‰Yè½´é‡å åŒºåŸŸï¼Œæ— æ³•è¿æ¥
            if (rayPath.top >= rayPath.bottom) return true;

            // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–å…ƒç´ é˜»æŒ¡å°„çº¿è·¯å¾„
            for (const other of allElements) {
                if (other.id === elem1.id || other.id === elem2.id) continue;

                // æ£€æŸ¥å…¶ä»–å…ƒç´ æ˜¯å¦ä¸å°„çº¿è·¯å¾„ç›¸äº¤
                const intersects = !(
                    other.x + other.width <= rayPath.left ||
                    other.x >= rayPath.right ||
                    other.y + other.height <= rayPath.top ||
                    other.y >= rayPath.bottom
                );

                if (intersects) {
                    return true; // è¢«é˜»æŒ¡
                }
            }

            return false; // æœªè¢«é˜»æŒ¡
        }

        // ğŸ¯ æ£€æŸ¥å‚ç›´å°„çº¿æ˜¯å¦è¢«é˜»æŒ¡
        function isVerticalRayBlocked(elem1, elem2, allElements) {
            // åˆ›å»ºå‚ç›´å°„çº¿è·¯å¾„
            const rayPath = {
                left: Math.max(elem1.x, elem2.x),
                right: Math.min(elem1.x + elem1.width, elem2.x + elem2.width),
                top: Math.min(elem1.y + elem1.height, elem2.y),
                bottom: Math.max(elem1.y, elem2.y + elem2.height)
            };

            // å¦‚æœæ²¡æœ‰Xè½´é‡å åŒºåŸŸï¼Œæ— æ³•è¿æ¥
            if (rayPath.left >= rayPath.right) return true;

            // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–å…ƒç´ é˜»æŒ¡å°„çº¿è·¯å¾„
            for (const other of allElements) {
                if (other.id === elem1.id || other.id === elem2.id) continue;

                // æ£€æŸ¥å…¶ä»–å…ƒç´ æ˜¯å¦ä¸å°„çº¿è·¯å¾„ç›¸äº¤
                const intersects = !(
                    other.x + other.width <= rayPath.left ||
                    other.x >= rayPath.right ||
                    other.y + other.height <= rayPath.top ||
                    other.y >= rayPath.bottom
                );

                if (intersects) {
                    return true; // è¢«é˜»æŒ¡
                }
            }

            return false; // æœªè¢«é˜»æŒ¡
        }

        // ğŸ¯ è¯†åˆ«åˆ—ç»“æ„
        function identifyColumns(elements) {
            console.log(`\nğŸ” è¯†åˆ«åˆ—ç»“æ„`);

            // æŒ‰Xåæ ‡æ’åº
            const sortedByX = [...elements].sort((a, b) => a.x - b.x);

            const columns = [];
            let currentColumn = [];

            for (const element of sortedByX) {
                if (currentColumn.length === 0) {
                    currentColumn.push(element);
                } else {
                    // æ£€æŸ¥æ˜¯å¦ä¸å½“å‰åˆ—æœ‰Xè½´é‡å æˆ–æ¥è¿‘
                    const canJoinColumn = currentColumn.some(colElement => {
                        // Xè½´é‡å æ£€æŸ¥
                        const xOverlap = !(element.x >= colElement.x + colElement.width ||
                                         element.x + element.width <= colElement.x);

                        // Xè½´æ¥è¿‘æ£€æŸ¥ï¼ˆè·ç¦»å°äºå¹³å‡å®½åº¦çš„50%ï¼‰
                        const avgWidth = (element.width + colElement.width) / 2;
                        const xDistance = Math.min(
                            Math.abs(element.x - (colElement.x + colElement.width)),
                            Math.abs(colElement.x - (element.x + element.width))
                        );
                        const xClose = xDistance <= avgWidth * 0.5;

                        return xOverlap || xClose;
                    });

                    if (canJoinColumn) {
                        currentColumn.push(element);
                    } else {
                        columns.push([...currentColumn]);
                        console.log(`  ğŸ“¦ å®Œæˆåˆ—: [${currentColumn.map(e => e.name).join(', ')}]`);
                        currentColumn = [element];
                    }
                }
            }

            if (currentColumn.length > 0) {
                columns.push(currentColumn);
                console.log(`  ğŸ“¦ æœ€ååˆ—: [${currentColumn.map(e => e.name).join(', ')}]`);
            }

            return columns;
        }

        // ğŸ¯ åœ¨åˆ—å†…æ™ºèƒ½åˆ†ç»„ï¼ˆè€ƒè™‘ä¸Šä¸‹å¸ƒå±€ï¼‰
        function groupColumnByRows(columnElements) {
            console.log(`  ğŸ” åœ¨åˆ—å†…æ™ºèƒ½åˆ†ç»„: [${columnElements.map(e => e.name).join(', ')}]`);

            // æŒ‰Yåæ ‡æ’åº
            const sortedByY = [...columnElements].sort((a, b) => a.y - b.y);

            // 1. å…ˆè¯†åˆ«æ°´å¹³è¡Œï¼ˆåŒä¸€Yè½´ä½ç½®çš„å…ƒç´ ï¼‰
            const horizontalRows = identifyHorizontalRows(sortedByY);

            // 2. ç„¶åè¯†åˆ«å‚ç›´ç»„ï¼ˆä¸Šä¸‹ç›¸é‚»çš„å…ƒç´ ï¼‰
            const finalGroups = [];

            horizontalRows.forEach(row => {
                if (row.length === 1) {
                    // å•ä¸ªå…ƒç´ ï¼Œæ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–å•ä¸ªå…ƒç´ å½¢æˆå‚ç›´ç»„
                    finalGroups.push(row);
                } else {
                    // å¤šä¸ªå…ƒç´ åœ¨åŒä¸€è¡Œï¼Œä¿æŒä¸ºä¸€ç»„
                    finalGroups.push(row);
                    console.log(`    ğŸ“¦ æ°´å¹³è¡Œç»„: [${row.map(e => e.name).join(', ')}]`);
                }
            });

            // 3. åˆå¹¶ç›¸é‚»çš„å•å…ƒç´ ç»„ä¸ºå‚ç›´ç»„
            const mergedGroups = mergeVerticalGroups(finalGroups);

            return mergedGroups;
        }

        // ğŸ¯ è¯†åˆ«æ°´å¹³è¡Œ
        function identifyHorizontalRows(sortedElements) {
            console.log(`    ğŸ” è¯†åˆ«æ°´å¹³è¡Œ`);

            const rows = [];
            let currentRow = [];

            for (const element of sortedElements) {
                if (currentRow.length === 0) {
                    currentRow.push(element);
                } else {
                    // æ£€æŸ¥æ˜¯å¦ä¸å½“å‰è¡Œæœ‰Yè½´é‡å ï¼ˆåŒä¸€æ°´å¹³è¡Œï¼‰
                    const canJoinRow = currentRow.some(rowElement => {
                        const yOverlap = !(element.y >= rowElement.y + rowElement.height ||
                                         element.y + element.height <= rowElement.y);
                        return yOverlap;
                    });

                    if (canJoinRow) {
                        currentRow.push(element);
                        console.log(`      â¡ï¸ æ·»åŠ åˆ°æ°´å¹³è¡Œ: ${element.name}`);
                    } else {
                        rows.push([...currentRow]);
                        console.log(`      ğŸ“¦ å®Œæˆæ°´å¹³è¡Œ: [${currentRow.map(e => e.name).join(', ')}]`);
                        currentRow = [element];
                    }
                }
            }

            if (currentRow.length > 0) {
                rows.push(currentRow);
                console.log(`      ğŸ“¦ æœ€åæ°´å¹³è¡Œ: [${currentRow.map(e => e.name).join(', ')}]`);
            }

            return rows;
        }

        // ğŸ¯ åˆå¹¶å‚ç›´ç›¸é‚»çš„å•å…ƒç´ ç»„
        function mergeVerticalGroups(groups) {
            console.log(`    ğŸ” åˆå¹¶å‚ç›´ç»„`);

            const result = [];
            let i = 0;

            while (i < groups.length) {
                const currentGroup = groups[i];

                if (currentGroup.length === 1) {
                    // å•å…ƒç´ ç»„ï¼Œæ£€æŸ¥æ˜¯å¦å¯ä»¥ä¸ä¸‹ä¸€ä¸ªå•å…ƒç´ ç»„åˆå¹¶
                    const verticalGroup = [currentGroup[0]];
                    let j = i + 1;

                    while (j < groups.length && groups[j].length === 1) {
                        const nextElement = groups[j][0];
                        const lastElement = verticalGroup[verticalGroup.length - 1];

                        // æ£€æŸ¥æ˜¯å¦å‚ç›´ç›¸é‚»
                        const yGap = nextElement.y - (lastElement.y + lastElement.height);
                        const avgHeight = (nextElement.height + lastElement.height) / 2;

                        if (yGap <= avgHeight * 0.5) { // å‚ç›´é—´è·å°äºå¹³å‡é«˜åº¦çš„50%
                            verticalGroup.push(nextElement);
                            console.log(`      â¬‡ï¸ åˆå¹¶å‚ç›´å…ƒç´ : ${nextElement.name}`);
                            j++;
                        } else {
                            break;
                        }
                    }

                    result.push(verticalGroup);
                    if (verticalGroup.length > 1) {
                        console.log(`    ğŸ“¦ å‚ç›´ç»„: [${verticalGroup.map(e => e.name).join(', ')}]`);
                    }
                    i = j;
                } else {
                    // å¤šå…ƒç´ ç»„ï¼Œç›´æ¥æ·»åŠ 
                    result.push(currentGroup);
                    i++;
                }
            }

            return result;
        }

        // ğŸ¯ æ„å»ºå°„çº¿å…³ç³»
        function buildRayRelations(elements) {
            console.log(`\nğŸ” æ„å»ºå°„çº¿å…³ç³»`);
            const relations = new Map();

            elements.forEach(element => {
                const rays = {
                    left: [],    // å·¦å°„çº¿èƒ½åˆ°è¾¾çš„å…ƒç´ 
                    right: [],   // å³å°„çº¿èƒ½åˆ°è¾¾çš„å…ƒç´ 
                    up: [],      // ä¸Šå°„çº¿èƒ½åˆ°è¾¾çš„å…ƒç´ 
                    down: []     // ä¸‹å°„çº¿èƒ½åˆ°è¾¾çš„å…ƒç´ 
                };

                // æ£€æŸ¥æ¯ä¸ªæ–¹å‘çš„å°„çº¿
                elements.forEach(other => {
                    if (other.id === element.id) return;

                    const rayHit = checkRayHit(element, other);
                    if (rayHit.direction) {
                        rays[rayHit.direction].push(other);
                    }
                });

                relations.set(element.id, rays);
                console.log(`  ${element.name} å°„çº¿å…³ç³»:`, {
                    left: rays.left.map(e => e.name),
                    right: rays.right.map(e => e.name),
                    up: rays.up.map(e => e.name),
                    down: rays.down.map(e => e.name)
                });
            });

            return relations;
        }

        // ğŸ¯ æ£€æŸ¥å°„çº¿æ˜¯å¦å‡»ä¸­ç›®æ ‡å…ƒç´ 
        function checkRayHit(source, target) {
            const sourceCenter = {
                x: source.x + source.width / 2,
                y: source.y + source.height / 2
            };
            const targetCenter = {
                x: target.x + target.width / 2,
                y: target.y + target.height / 2
            };

            // æ£€æŸ¥æ˜¯å¦åœ¨åŒä¸€è¡Œï¼ˆæ°´å¹³å°„çº¿ï¼‰
            const verticalOverlap = !(
                source.y + source.height <= target.y ||
                target.y + target.height <= source.y
            );

            // æ£€æŸ¥æ˜¯å¦åœ¨åŒä¸€åˆ—ï¼ˆå‚ç›´å°„çº¿ï¼‰
            const horizontalOverlap = !(
                source.x + source.width <= target.x ||
                target.x + target.width <= source.x
            );

            if (verticalOverlap) {
                // æ°´å¹³å°„çº¿
                if (targetCenter.x > sourceCenter.x) {
                    return { direction: 'right', distance: targetCenter.x - sourceCenter.x };
                } else if (targetCenter.x < sourceCenter.x) {
                    return { direction: 'left', distance: sourceCenter.x - targetCenter.x };
                }
            }

            if (horizontalOverlap) {
                // å‚ç›´å°„çº¿
                if (targetCenter.y > sourceCenter.y) {
                    return { direction: 'down', distance: targetCenter.y - sourceCenter.y };
                } else if (targetCenter.y < sourceCenter.y) {
                    return { direction: 'up', distance: sourceCenter.y - targetCenter.y };
                }
            }

            return { direction: null };
        }

        // ğŸ¯ æ‰¾åˆ°å°„çº¿è¿æ¥çš„åˆ†ç»„
        function findRayConnectedGroup(startElement, allElements, rayRelations, processed) {
            const group = [startElement];
            console.log(`\nğŸ” ä» "${startElement.name}" å¼€å§‹å¯»æ‰¾å°„çº¿è¿æ¥åˆ†ç»„`);

            // ä½¿ç”¨å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼Œé€šè¿‡å°„çº¿å…³ç³»è¿æ¥å…ƒç´ 
            const queue = [startElement];
            const inGroup = new Set([startElement.id]);

            while (queue.length > 0) {
                const current = queue.shift();
                const rays = rayRelations.get(current.id);

                if (!rays) continue;

                // æ£€æŸ¥æ‰€æœ‰æ–¹å‘çš„å°„çº¿è¿æ¥
                ['left', 'right', 'up', 'down'].forEach(direction => {
                    rays[direction].forEach(neighbor => {
                        if (processed.has(neighbor.id) || inGroup.has(neighbor.id)) return;

                        // æ£€æŸ¥æ˜¯å¦åº”è¯¥åŠ å…¥åˆ†ç»„
                        if (shouldJoinRayGroup(current, neighbor, direction, allElements)) {
                            group.push(neighbor);
                            queue.push(neighbor);
                            inGroup.add(neighbor.id);
                            console.log(`  âœ… é€šè¿‡${direction}å°„çº¿æ·»åŠ : ${neighbor.name}`);
                        }
                    });
                });
            }

            return group;
        }

        // ğŸ¯ åˆ¤æ–­æ˜¯å¦åº”è¯¥é€šè¿‡å°„çº¿åŠ å…¥åˆ†ç»„
        function shouldJoinRayGroup(source, target, direction, allElements) {
            // 1. æ£€æŸ¥å°„çº¿è·¯å¾„æ˜¯å¦è¢«é˜»æŒ¡
            if (isRayBlocked(source, target, direction, allElements)) {
                console.log(`    ğŸš« ${direction}å°„çº¿è¢«é˜»æŒ¡ï¼Œä¸èƒ½åˆ†ç»„`);
                return false;
            }

            // 2. æ£€æŸ¥è·ç¦»æ˜¯å¦åˆç†
            const distance = calculateMinDistance(source, target);
            const avgSize = (source.width + source.height + target.width + target.height) / 4;

            if (distance > avgSize * 2) {
                console.log(`    ğŸ“ å°„çº¿è·ç¦»è¿‡è¿œ: ${distance} > ${avgSize * 2}`);
                return false;
            }

            return true;
        }

        // ğŸ¯ æ£€æŸ¥å°„çº¿æ˜¯å¦è¢«é˜»æŒ¡
        function isRayBlocked(source, target, direction, allElements) {
            const sourceCenter = {
                x: source.x + source.width / 2,
                y: source.y + source.height / 2
            };
            const targetCenter = {
                x: target.x + target.width / 2,
                y: target.y + target.height / 2
            };

            // æ ¹æ®æ–¹å‘åˆ›å»ºå°„çº¿è·¯å¾„
            let rayPath;
            if (direction === 'left' || direction === 'right') {
                // æ°´å¹³å°„çº¿
                rayPath = {
                    x1: Math.min(sourceCenter.x, targetCenter.x),
                    x2: Math.max(sourceCenter.x, targetCenter.x),
                    y1: Math.min(source.y, target.y),
                    y2: Math.max(source.y + source.height, target.y + target.height)
                };
            } else {
                // å‚ç›´å°„çº¿
                rayPath = {
                    x1: Math.min(source.x, target.x),
                    x2: Math.max(source.x + source.width, target.x + target.width),
                    y1: Math.min(sourceCenter.y, targetCenter.y),
                    y2: Math.max(sourceCenter.y, targetCenter.y)
                };
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–å…ƒç´ é˜»æŒ¡å°„çº¿è·¯å¾„
            for (const other of allElements) {
                if (other.id === source.id || other.id === target.id) continue;

                // æ£€æŸ¥å…¶ä»–å…ƒç´ æ˜¯å¦ä¸å°„çº¿è·¯å¾„ç›¸äº¤
                const intersects = !(
                    other.x + other.width <= rayPath.x1 ||
                    other.x >= rayPath.x2 ||
                    other.y + other.height <= rayPath.y1 ||
                    other.y >= rayPath.y2
                );

                if (intersects) {
                    console.log(`      ğŸš« "${other.name}" é˜»æŒ¡äº†${direction}å°„çº¿`);
                    return true;
                }
            }

            return false;
        }

        // ğŸ¯ æ‰¾åˆ°ç©ºé—´ç›¸å…³çš„åˆ†ç»„ï¼ˆä¿®å¤ç‰ˆæœ¬ï¼‰
        function findSpatialGroup(startElement, allElements, processed) {
            const group = [startElement];
            console.log(`\nğŸ” ä» "${startElement.name}" å¼€å§‹å¯»æ‰¾ç©ºé—´åˆ†ç»„`);

            // ä½¿ç”¨è¿­ä»£æ–¹å¼ï¼Œæ¯æ¬¡æ·»åŠ æ–°å…ƒç´ åé‡æ–°æ£€æŸ¥
            let changed = true;
            while (changed) {
                changed = false;

                for (const candidate of allElements) {
                    if (processed.has(candidate.id) || group.some(g => g.id === candidate.id)) continue;

                    // æ£€æŸ¥å€™é€‰å…ƒç´ æ˜¯å¦ä¸ç»„å†…ä»»ä½•å…ƒç´ ç›¸é‚»
                    const canJoinGroup = group.some(groupMember => {
                        return shouldJoinSpatialGroup(groupMember, candidate, allElements);
                    });

                    if (canJoinGroup) {
                        group.push(candidate);
                        console.log(`  âœ… æ·»åŠ åˆ°åˆ†ç»„: ${candidate.name}`);
                        changed = true; // æœ‰æ–°å…ƒç´ åŠ å…¥ï¼Œéœ€è¦é‡æ–°æ£€æŸ¥
                    }
                }
            }

            return group;
        }

        // ğŸ¯ åŸºäºæˆªæ–­æ£€æµ‹çš„åˆ†ç»„åˆ¤æ–­ï¼ˆæ— é˜ˆå€¼ç‰ˆæœ¬ï¼‰
        function shouldJoinSpatialGroup(anchor, candidate, allElements) {
            console.log(`    ğŸ” æ£€æŸ¥ "${candidate.name}" æ˜¯å¦å¯ä»¥ä¸ "${anchor.name}" åˆ†ç»„`);
            console.log(`      é”šç‚¹: (${anchor.x},${anchor.y},${anchor.width}Ã—${anchor.height})`);
            console.log(`      å€™é€‰: (${candidate.x},${candidate.y},${candidate.width}Ã—${candidate.height})`);

            // 1. æ£€æŸ¥ä»anchoråˆ°candidateçš„è·¯å¾„æ˜¯å¦è¢«æˆªæ–­
            const isBlocked = isPathBlocked(anchor, candidate, allElements);

            if (isBlocked) {
                console.log(`    ğŸš« "${candidate.name}" è¢«å…¶ä»–å…ƒç´ æˆªæ–­ï¼Œæ— æ³•ä¸ "${anchor.name}" åˆ†ç»„`);
                return false;
            }

            console.log(`    âœ… "${candidate.name}" å¯ä»¥ä¸ "${anchor.name}" åˆ†ç»„ï¼ˆæ— æˆªæ–­ï¼‰`);
            return true;
        }

        // ğŸ¯ æ£€æŸ¥è·¯å¾„æ˜¯å¦è¢«é˜»æŒ¡ï¼ˆä¿®å¤ç‰ˆæœ¬ï¼‰
        function isPathBlocked(elem1, elem2, allElements) {
            // 1. é¦–å…ˆæ£€æŸ¥åŸºæœ¬è·ç¦» - å¦‚æœè·ç¦»å¤ªè¿œï¼Œç›´æ¥è®¤ä¸ºè¢«"è™šæ‹Ÿé˜»æŒ¡"
            const distance = calculateMinDistance(elem1, elem2);
            const avgSize = (elem1.width + elem1.height + elem2.width + elem2.height) / 4;

            // å¦‚æœè·ç¦»è¶…è¿‡å¹³å‡å°ºå¯¸çš„1.5å€ï¼Œè®¤ä¸ºè¢«é˜»æŒ¡
            if (distance > avgSize * 1.5) {
                console.log(`      ğŸ“ è·ç¦»è¿‡è¿œè¢«è§†ä¸ºé˜»æŒ¡: ${distance} > ${avgSize * 1.5}`);
                return true;
            }

            // 2. æ£€æŸ¥Yåæ ‡å·®è· - é˜²æ­¢è·¨è¡Œåˆ†ç»„
            const yGap = Math.abs(elem1.y - elem2.y);
            const maxHeight = Math.max(elem1.height, elem2.height);

            if (yGap > maxHeight * 0.8) {
                console.log(`      ğŸ“ Yåæ ‡å·®è·è¿‡å¤§è¢«è§†ä¸ºé˜»æŒ¡: ${yGap} > ${maxHeight * 0.8}`);
                return true;
            }

            // 3. æ£€æŸ¥å®é™…çš„ç‰©ç†é˜»æŒ¡
            const connectionRect = {
                left: Math.min(elem1.x, elem2.x),
                right: Math.max(elem1.x + elem1.width, elem2.x + elem2.width),
                top: Math.min(elem1.y, elem2.y),
                bottom: Math.max(elem1.y + elem1.height, elem2.y + elem2.height)
            };

            console.log(`      è¿æ¥åŒºåŸŸ: (${connectionRect.left},${connectionRect.top}) åˆ° (${connectionRect.right},${connectionRect.bottom})`);

            // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–å…ƒç´ åœ¨è¿æ¥è·¯å¾„ä¸Š
            for (const other of allElements) {
                if (other.id === elem1.id || other.id === elem2.id) continue;

                // æ£€æŸ¥å…¶ä»–å…ƒç´ æ˜¯å¦ä¸è¿æ¥åŒºåŸŸé‡å 
                const otherRect = {
                    left: other.x,
                    right: other.x + other.width,
                    top: other.y,
                    bottom: other.y + other.height
                };

                // æ£€æŸ¥é‡å 
                const overlaps = !(
                    otherRect.right <= connectionRect.left ||
                    otherRect.left >= connectionRect.right ||
                    otherRect.bottom <= connectionRect.top ||
                    otherRect.top >= connectionRect.bottom
                );

                if (overlaps) {
                    // è¿›ä¸€æ­¥æ£€æŸ¥æ˜¯å¦çœŸçš„é˜»æŒ¡äº†è¿æ¥
                    if (isReallyBlocking(elem1, elem2, other)) {
                        console.log(`      ğŸš« "${other.name}" ç‰©ç†é˜»æŒ¡äº†è¿æ¥`);
                        return true;
                    }
                }
            }

            return false;
        }

        // ğŸ¯ æ£€æŸ¥å…ƒç´ æ˜¯å¦çœŸçš„é˜»æŒ¡è¿æ¥
        function isReallyBlocking(elem1, elem2, blocker) {
            // æ£€æŸ¥é˜»æŒ¡å…ƒç´ æ˜¯å¦åœ¨ä¸¤ä¸ªå…ƒç´ çš„è¿æ¥è·¯å¾„çš„å…³é”®åŒºåŸŸ
            const elem1Center = { x: elem1.x + elem1.width / 2, y: elem1.y + elem1.height / 2 };
            const elem2Center = { x: elem2.x + elem2.width / 2, y: elem2.y + elem2.height / 2 };
            const blockerCenter = { x: blocker.x + blocker.width / 2, y: blocker.y + blocker.height / 2 };

            // ç®€åŒ–ç‰ˆæœ¬ï¼šå¦‚æœé˜»æŒ¡å…ƒç´ çš„ä¸­å¿ƒåœ¨ä¸¤ä¸ªå…ƒç´ çš„è¾¹ç•Œæ¡†å†…ï¼Œåˆ™è®¤ä¸ºé˜»æŒ¡
            const minX = Math.min(elem1.x, elem2.x);
            const maxX = Math.max(elem1.x + elem1.width, elem2.x + elem2.width);
            const minY = Math.min(elem1.y, elem2.y);
            const maxY = Math.max(elem1.y + elem1.height, elem2.y + elem2.height);

            const isInPath = (
                blockerCenter.x >= minX && blockerCenter.x <= maxX &&
                blockerCenter.y >= minY && blockerCenter.y <= maxY
            );

            return isInPath;
        }

        // ğŸ¯ æ£€æŸ¥ç©ºé—´å…³ç³»æ˜¯å¦åˆç†
        function checkSpatialRelationship(elem1, elem2) {
            // æ£€æŸ¥æ˜¯å¦åœ¨åˆç†çš„ç›¸å¯¹ä½ç½®
            const xOverlap = !(elem1.x + elem1.width <= elem2.x || elem2.x + elem2.width <= elem1.x);
            const yOverlap = !(elem1.y + elem1.height <= elem2.y || elem2.y + elem2.height <= elem1.y);

            // å¦‚æœæœ‰é‡å ï¼Œæˆ–è€…åœ¨åˆç†çš„é‚»è¿‘ä½ç½®ï¼Œåˆ™è®¤ä¸ºåˆç†
            if (xOverlap || yOverlap) {
                return true;
            }

            // æ£€æŸ¥æ˜¯å¦åœ¨åˆç†çš„é‚»è¿‘ä½ç½®ï¼ˆæ¨ªå‘æˆ–çºµå‘å¯¹é½ï¼‰
            const horizontallyAligned = Math.abs(elem1.y - elem2.y) <= Math.max(elem1.height, elem2.height) * 0.5;
            const verticallyAligned = Math.abs(elem1.x - elem2.x) <= Math.max(elem1.width, elem2.width) * 0.5;

            return horizontallyAligned || verticallyAligned;
        }

        // ğŸ¯ æ‰¾åˆ°ç´§é‚»çš„å…ƒç´ ï¼ˆè¶…ä¸¥æ ¼ç‰ˆæœ¬ï¼‰
        function findImmediateNeighbors(startElement, allElements, processed) {
            const group = [startElement];

            console.log(`\nğŸ” ä» "${startElement.name}" å¼€å§‹å¯»æ‰¾ç´§é‚»å…ƒç´ `);

            // åªæŸ¥æ‰¾çœŸæ­£ç´§é‚»çš„å…ƒç´ 
            for (const candidate of allElements) {
                if (processed.has(candidate.id) || candidate.id === startElement.id) continue;

                // æ£€æŸ¥æ˜¯å¦ä¸å½“å‰ç»„ä¸­çš„ä»»ä½•å…ƒç´ ç´§é‚»
                const isNeighbor = group.some(groupMember => {
                    return areImmediateNeighbors(groupMember, candidate);
                });

                if (isNeighbor) {
                    group.push(candidate);
                    console.log(`  âœ… æ·»åŠ ç´§é‚»å…ƒç´ : ${candidate.name}`);
                }
            }

            return group;
        }

        // ğŸ¯ æ£€æŸ¥ä¸¤ä¸ªå…ƒç´ æ˜¯å¦ç´§é‚»ï¼ˆè¶…ä¸¥æ ¼æ ‡å‡†ï¼‰
        function areImmediateNeighbors(elem1, elem2) {
            // 1. Yåæ ‡å¿…é¡»éå¸¸æ¥è¿‘ï¼ˆåŒä¸€è¡Œï¼‰
            const yDiff = Math.abs(elem1.y - elem2.y);
            const maxHeight = Math.max(elem1.height, elem2.height);

            if (yDiff > maxHeight * 0.1) { // Yåæ ‡å·®è·ä¸èƒ½è¶…è¿‡æœ€å¤§é«˜åº¦çš„10%
                return false;
            }

            // 2. Xåæ ‡å¿…é¡»ç´§é‚»ï¼ˆé—´éš™å¾ˆå°ï¼‰
            const distance = calculateMinDistance(elem1, elem2);
            const minWidth = Math.min(elem1.width, elem2.width);

            // é—´éš™ä¸èƒ½è¶…è¿‡æœ€å°å®½åº¦çš„20%
            if (distance > minWidth * 0.2) {
                console.log(`    ğŸ“ "${elem1.name}" ä¸ "${elem2.name}" è·ç¦»è¿‡è¿œ: ${distance} > ${minWidth * 0.2}`);
                return false;
            }

            console.log(`    âœ… "${elem1.name}" ä¸ "${elem2.name}" æ˜¯ç´§é‚»å…ƒç´ `);
            return true;
        }

        // ğŸ¯ è¯†åˆ«è¡Œï¼ˆåŸºäºYåæ ‡å’Œé‡å ï¼‰
        function identifyRowsWithGaps(elements) {
            const sortedByY = [...elements].sort((a, b) => a.y - b.y);
            const rows = [];
            let currentRow = [];

            for (const element of sortedByY) {
                if (currentRow.length === 0) {
                    currentRow.push(element);
                } else {
                    // æ£€æŸ¥æ˜¯å¦ä¸å½“å‰è¡Œæœ‰Yè½´é‡å æˆ–æ¥è¿‘ï¼ˆæ›´ä¸¥æ ¼ï¼‰
                    const canJoinRow = currentRow.some(rowElement => {
                        const yOverlap = !(element.y >= rowElement.y + rowElement.height ||
                                         element.y + element.height <= rowElement.y);
                        const avgHeight = (element.height + rowElement.height) / 2;
                        const yClose = Math.abs(element.y - rowElement.y) <= avgHeight * 0.2; // å¹³å‡é«˜åº¦çš„20%å®¹å·®
                        return yOverlap || yClose;
                    });

                    if (canJoinRow) {
                        currentRow.push(element);
                    } else {
                        rows.push([...currentRow]);
                        currentRow = [element];
                    }
                }
            }

            if (currentRow.length > 0) {
                rows.push(currentRow);
            }

            return rows;
        }

        // ğŸ¯ åœ¨è¡Œå†…æŒ‰é—´éš™åˆ†ç»„
        function groupRowByGaps(rowElements) {
            const sortedByX = [...rowElements].sort((a, b) => a.x - b.x);
            const groups = [];
            let currentGroup = [];

            console.log(`  ğŸ” åˆ†æè¡Œå†…é—´éš™: [${sortedByX.map(e => e.name).join(', ')}]`);

            for (let i = 0; i < sortedByX.length; i++) {
                const element = sortedByX[i];

                if (currentGroup.length === 0) {
                    currentGroup.push(element);
                } else {
                    const lastElement = currentGroup[currentGroup.length - 1];
                    const gap = element.x - (lastElement.x + lastElement.width);

                    // è®¡ç®—ä¸¥æ ¼çš„é—´éš™é˜ˆå€¼
                    const minWidth = Math.min(lastElement.width, element.width);
                    const gapThreshold = minWidth * 0.3; // é—´éš™è¶…è¿‡æœ€å°å®½åº¦çš„30%å°±åˆ†ç»„

                    console.log(`    ğŸ“ "${lastElement.name}" åˆ° "${element.name}" é—´éš™: ${gap}, é˜ˆå€¼: ${gapThreshold}`);

                    if (gap <= gapThreshold) {
                        currentGroup.push(element);
                        console.log(`    â¡ï¸ ç»§ç»­å½“å‰ç»„`);
                    } else {
                        groups.push([...currentGroup]);
                        console.log(`    ğŸ“¦ å®Œæˆåˆ†ç»„: [${currentGroup.map(e => e.name).join(', ')}]`);
                        currentGroup = [element];
                        console.log(`    ğŸ†• å¼€å§‹æ–°ç»„`);
                    }
                }
            }

            if (currentGroup.length > 0) {
                groups.push(currentGroup);
                console.log(`    ğŸ“¦ æœ€ååˆ†ç»„: [${currentGroup.map(e => e.name).join(', ')}]`);
            }

            return groups;
        }











        // ğŸ¯ æ£€æŸ¥ä¸¤ä¸ªå…ƒç´ çš„è¿æ¥æ˜¯å¦è¢«æˆªæ–­
        function isConnectionTruncated(elem1, elem2, allElements, currentGroup) {
            // è®¡ç®—è¿æ¥åŒºåŸŸ
            const connectionBounds = {
                left: Math.min(elem1.x, elem2.x),
                right: Math.max(elem1.x + elem1.width, elem2.x + elem2.width),
                top: Math.min(elem1.y, elem2.y),
                bottom: Math.max(elem1.y + elem1.height, elem2.y + elem2.height)
            };

            // æ£€æŸ¥æ˜¯å¦æœ‰å…¶ä»–å…ƒç´ æˆªæ–­è¿™ä¸ªè¿æ¥
            for (const other of allElements) {
                if (other.id === elem1.id || other.id === elem2.id || currentGroup.has(other.id)) {
                    continue;
                }

                // æ£€æŸ¥å…¶ä»–å…ƒç´ æ˜¯å¦åœ¨è¿æ¥è·¯å¾„ä¸Š
                if (isElementBlockingConnection(other, elem1, elem2, connectionBounds)) {
                    return true;
                }
            }

            return false;
        }

        // ğŸ¯ æ£€æŸ¥å…ƒç´ æ˜¯å¦é˜»æŒ¡è¿æ¥
        function isElementBlockingConnection(blockingElement, elem1, elem2, connectionBounds) {
            const blocker = {
                left: blockingElement.x,
                right: blockingElement.x + blockingElement.width,
                top: blockingElement.y,
                bottom: blockingElement.y + blockingElement.height
            };

            // æ£€æŸ¥æ˜¯å¦ä¸è¿æ¥åŒºåŸŸé‡å 
            const overlaps = !(
                blocker.right <= connectionBounds.left ||
                blocker.left >= connectionBounds.right ||
                blocker.bottom <= connectionBounds.top ||
                blocker.top >= connectionBounds.bottom
            );

            if (!overlaps) return false;

            // æ£€æŸ¥æ˜¯å¦çœŸçš„åœ¨è¿æ¥è·¯å¾„ä¸Šï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
            const isInPath = (
                (blocker.left < connectionBounds.right && blocker.right > connectionBounds.left) &&
                (blocker.top < connectionBounds.bottom && blocker.bottom > connectionBounds.top)
            );

            return isInPath;
        }

        // ğŸ¯ åˆ›å»ºåˆ†ç»„æ“ä½œæè¿°
        function createGroupingOperation(candidate, index) {
            const bounds = calculateBounds(candidate.children);
            const direction = determineGroupDirection(candidate.children);
            const parentName = generateGroupName(candidate.children, candidate.type, index);

            return {
                id: `group_${index}`,
                parentName: parentName,
                children: candidate.children,
                reason: candidate.reason,
                direction: direction,
                bounds: bounds,
                type: candidate.type
            };
        }

        // ğŸ¯ ç”Ÿæˆåˆ†ç»„åç§°
        function generateGroupName(children, type, index) {
            if (children.length === 1) {
                return children[0].name;
            }

            // æ ¹æ®å­å…ƒç´ ç”Ÿæˆæœ‰æ„ä¹‰çš„åç§°
            if (children.length <= 3) {
                return children.map(c => c.name).join(' + ');
            } else {
                return `${children[0].name} + ${children[1].name} + ${children.length - 2} é¡¹`;
            }
        }

        // ğŸ¯ ç¡®å®šåˆ†ç»„æ–¹å‘
        function determineGroupDirection(elements) {
            if (elements.length <= 1) return 'NONE';

            // è®¡ç®—å…ƒç´ åˆ†å¸ƒ
            const xPositions = elements.map(e => e.x);
            const yPositions = elements.map(e => e.y);
            const xRange = Math.max(...xPositions) - Math.min(...xPositions);
            const yRange = Math.max(...yPositions) - Math.min(...yPositions);

            // è®¡ç®—å¹³å‡å°ºå¯¸
            const avgWidth = elements.reduce((sum, e) => sum + e.width, 0) / elements.length;
            const avgHeight = elements.reduce((sum, e) => sum + e.height, 0) / elements.length;

            if (xRange > avgWidth && xRange > yRange) {
                return 'HORIZONTAL';
            } else if (yRange > avgHeight && yRange > xRange) {
                return 'VERTICAL';
            } else {
                return 'MIXED';
            }
        }

        // ğŸ¯ æ‰§è¡Œåˆ†ç»„æ“ä½œ
        function executeGroupingOperations(operations, originalElements) {
            console.log(`\nğŸ”§ æ‰§è¡Œåˆ†ç»„æ“ä½œ:`);

            const groups = [];

            operations.forEach((operation, index) => {
                console.log(`\næ‰§è¡Œæ“ä½œ ${index + 1}: åˆ›å»ºåˆ†ç»„ "${operation.parentName}"`);
                console.log(`   åŒ…å«å…ƒç´ : ${operation.children.map(c => c.name).join(', ')}`);
                console.log(`   å¸ƒå±€æ–¹å‘: ${operation.direction}`);

                groups.push(operation.children);
            });

            return groups;
        }



        // ğŸ¯ åœ¨è¿ç»­åŒºåŸŸå†…è¿›è¡Œåˆ†ç»„
        function groupElementsInRegion(regionElements, threshold) {
            if (regionElements.length === 1) {
                return [regionElements];
            }

            console.log(`ğŸ”„ åœ¨åŒºåŸŸå†…åˆ†ç»„ ${regionElements.length} ä¸ªå…ƒç´ `);

            // åˆ†æåŒºåŸŸå†…å…ƒç´ çš„å¸ƒå±€ç‰¹å¾
            const layoutAnalysis = analyzeRegionLayout(regionElements);
            console.log(`ğŸ“Š å¸ƒå±€åˆ†æ:`, layoutAnalysis);

            // æ ¹æ®å¸ƒå±€ç‰¹å¾é€‰æ‹©åˆ†ç»„ç­–ç•¥
            if (layoutAnalysis.isPrimaryHorizontal) {
                console.log(`â¡ï¸ ä¸»è¦æ˜¯æ¨ªå‘å¸ƒå±€ï¼Œä½¿ç”¨æ¨ªå‘åˆ†ç»„`);
                return groupRegionHorizontally(regionElements, threshold);
            } else if (layoutAnalysis.isPrimaryVertical) {
                console.log(`â¬‡ï¸ ä¸»è¦æ˜¯çºµå‘å¸ƒå±€ï¼Œä½¿ç”¨çºµå‘åˆ†ç»„`);
                return groupRegionVertically(regionElements, threshold);
            } else {
                console.log(`ğŸ”„ æ··åˆå¸ƒå±€ï¼Œä½¿ç”¨æ··åˆåˆ†ç»„ç­–ç•¥`);
                return groupRegionMixed(regionElements, threshold);
            }
        }

        // ğŸ¯ åˆ†æåŒºåŸŸå†…çš„å¸ƒå±€ç‰¹å¾
        function analyzeRegionLayout(elements) {
            if (elements.length <= 1) {
                return { isPrimaryHorizontal: false, isPrimaryVertical: false, isMixed: false };
            }

            // è®¡ç®—å…ƒç´ çš„åˆ†å¸ƒèŒƒå›´
            const xPositions = elements.map(e => e.x);
            const yPositions = elements.map(e => e.y);
            const widths = elements.map(e => e.width);
            const heights = elements.map(e => e.height);

            const xRange = Math.max(...xPositions) - Math.min(...xPositions);
            const yRange = Math.max(...yPositions) - Math.min(...yPositions);
            const avgWidth = widths.reduce((sum, w) => sum + w, 0) / widths.length;
            const avgHeight = heights.reduce((sum, h) => sum + h, 0) / heights.length;

            // åˆ¤æ–­ä¸»è¦å¸ƒå±€æ–¹å‘
            const isPrimaryHorizontal = xRange > avgWidth && xRange > yRange;
            const isPrimaryVertical = yRange > avgHeight && yRange > xRange;
            const isMixed = !isPrimaryHorizontal && !isPrimaryVertical;

            return {
                isPrimaryHorizontal,
                isPrimaryVertical,
                isMixed,
                xRange,
                yRange,
                avgWidth,
                avgHeight
            };
        }

        // ğŸ¯ æ¨ªå‘åˆ†ç»„ç­–ç•¥
        function groupRegionHorizontally(elements, threshold) {
            // å…ˆæŒ‰è¡Œåˆ†ç»„
            const rows = identifyRowsByAlignment(elements, threshold);
            const groups = [];

            rows.forEach(row => {
                if (row.length === 1) {
                    groups.push(row);
                } else {
                    // è¡Œå†…æŒ‰Xåæ ‡å’Œé—´è·åˆ†ç»„
                    const rowGroups = groupBySpacing(row, threshold, 'horizontal');
                    groups.push(...rowGroups);
                }
            });

            return groups;
        }

        // ğŸ¯ çºµå‘åˆ†ç»„ç­–ç•¥
        function groupRegionVertically(elements, threshold) {
            // å…ˆæŒ‰åˆ—åˆ†ç»„
            const columns = identifyColumnsByAlignment(elements, threshold);
            const groups = [];

            columns.forEach(column => {
                if (column.length === 1) {
                    groups.push(column);
                } else {
                    // åˆ—å†…æŒ‰Yåæ ‡å’Œé—´è·åˆ†ç»„
                    const columnGroups = groupBySpacing(column, threshold, 'vertical');
                    groups.push(...columnGroups);
                }
            });

            return groups;
        }

        // ğŸ¯ æ··åˆåˆ†ç»„ç­–ç•¥ï¼ˆå¤„ç†å¤æ‚å¸ƒå±€ï¼‰
        function groupRegionMixed(elements, threshold) {
            // å¯¹äºæ··åˆå¸ƒå±€ï¼Œå°è¯•æ‰¾åˆ°æœ€ä½³çš„åˆ†ç»„ç»„åˆ
            // è¿™é‡Œå®ç°ç®€åŒ–ç‰ˆæœ¬ï¼Œå¯ä»¥æ ¹æ®éœ€è¦æ‰©å±•

            // å°è¯•æ¨ªå‘åˆ†ç»„
            const horizontalGroups = groupRegionHorizontally(elements, threshold);

            // å°è¯•çºµå‘åˆ†ç»„
            const verticalGroups = groupRegionVertically(elements, threshold);

            // é€‰æ‹©äº§ç”Ÿæ›´åˆç†åˆ†ç»„çš„ç­–ç•¥
            // ç®€å•ç­–ç•¥ï¼šé€‰æ‹©äº§ç”Ÿè¾ƒå°‘å•å…ƒç´ ç»„çš„æ–¹æ¡ˆ
            const horizontalSingleCount = horizontalGroups.filter(g => g.length === 1).length;
            const verticalSingleCount = verticalGroups.filter(g => g.length === 1).length;

            if (horizontalSingleCount <= verticalSingleCount) {
                console.log(`ğŸ¯ æ··åˆå¸ƒå±€é€‰æ‹©æ¨ªå‘åˆ†ç»„`);
                return horizontalGroups;
            } else {
                console.log(`ğŸ¯ æ··åˆå¸ƒå±€é€‰æ‹©çºµå‘åˆ†ç»„`);
                return verticalGroups;
            }
        }



        // ğŸ¯ æŒ‰å¯¹é½è¯†åˆ«è¡Œ
        function identifyRowsByAlignment(elements, threshold) {
            const sortedByY = [...elements].sort((a, b) => a.y - b.y);
            const rows = [];
            let currentRow = [];

            for (const element of sortedByY) {
                if (currentRow.length === 0) {
                    currentRow.push(element);
                } else {
                    // æ£€æŸ¥æ˜¯å¦ä¸å½“å‰è¡Œå¯¹é½
                    const isAligned = currentRow.some(rowElement => {
                        const yOverlap = !(element.y + element.height <= rowElement.y ||
                                         element.y >= rowElement.y + rowElement.height);
                        const yClose = Math.abs(element.y - rowElement.y) <= threshold;
                        return yOverlap || yClose;
                    });

                    if (isAligned) {
                        currentRow.push(element);
                    } else {
                        rows.push([...currentRow]);
                        currentRow = [element];
                    }
                }
            }

            if (currentRow.length > 0) {
                rows.push(currentRow);
            }

            return rows;
        }

        // ğŸ¯ æŒ‰å¯¹é½è¯†åˆ«åˆ—
        function identifyColumnsByAlignment(elements, threshold) {
            const sortedByX = [...elements].sort((a, b) => a.x - b.x);
            const columns = [];
            let currentColumn = [];

            for (const element of sortedByX) {
                if (currentColumn.length === 0) {
                    currentColumn.push(element);
                } else {
                    // æ£€æŸ¥æ˜¯å¦ä¸å½“å‰åˆ—å¯¹é½
                    const isAligned = currentColumn.some(colElement => {
                        const xOverlap = !(element.x + element.width <= colElement.x ||
                                         element.x >= colElement.x + colElement.width);
                        const xClose = Math.abs(element.x - colElement.x) <= threshold;
                        return xOverlap || xClose;
                    });

                    if (isAligned) {
                        currentColumn.push(element);
                    } else {
                        columns.push([...currentColumn]);
                        currentColumn = [element];
                    }
                }
            }

            if (currentColumn.length > 0) {
                columns.push(currentColumn);
            }

            return columns;
        }

        // ğŸ¯ æŒ‰é—´è·åˆ†ç»„
        function groupBySpacing(elements, threshold, direction) {
            const sortKey = direction === 'horizontal' ? 'x' : 'y';
            const sizeKey = direction === 'horizontal' ? 'width' : 'height';

            const sorted = [...elements].sort((a, b) => a[sortKey] - b[sortKey]);
            const groups = [];
            let currentGroup = [];

            for (const element of sorted) {
                if (currentGroup.length === 0) {
                    currentGroup.push(element);
                } else {
                    const lastElement = currentGroup[currentGroup.length - 1];
                    const gap = element[sortKey] - (lastElement[sortKey] + lastElement[sizeKey]);

                    if (gap <= threshold) {
                        currentGroup.push(element);
                    } else {
                        groups.push([...currentGroup]);
                        currentGroup = [element];
                    }
                }
            }

            if (currentGroup.length > 0) {
                groups.push(currentGroup);
            }

            return groups;
        }

        // ğŸ¯ è®¡ç®—ä¸¤ä¸ªå…ƒç´ ä¹‹é—´çš„æœ€å°è·ç¦»
        function calculateMinDistance(elem1, elem2) {
            const rect1 = {
                left: elem1.x,
                right: elem1.x + elem1.width,
                top: elem1.y,
                bottom: elem1.y + elem1.height
            };

            const rect2 = {
                left: elem2.x,
                right: elem2.x + elem2.width,
                top: elem2.y,
                bottom: elem2.y + elem2.height
            };

            // è®¡ç®—çŸ©å½¢é—´çš„æœ€å°è·ç¦»
            const xDistance = Math.max(0, Math.max(rect1.left - rect2.right, rect2.left - rect1.right));
            const yDistance = Math.max(0, Math.max(rect1.top - rect2.bottom, rect2.top - rect1.bottom));

            return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
        }





        // æŒ‰ä½ç½®åˆ†ç»„ï¼ˆè¡Œåˆ—åˆ†ç»„ï¼‰
        function groupByPosition(elements, threshold) {
            // å…ˆæŒ‰è¡Œåˆ†ç»„
            const rows = groupByRows(elements, threshold);

            // å†åœ¨æ¯è¡Œå†…æŒ‰åˆ—åˆ†ç»„
            const groups = [];
            rows.forEach(row => {
                const cols = groupByColumns(row, threshold);
                groups.push(...cols);
            });

            return groups.filter(group => group.length > 0);
        }

        // æŒ‰è¡Œåˆ†ç»„
        function groupByRows(elements, threshold) {
            const sortedByY = [...elements].sort((a, b) => a.y - b.y);
            const rows = [];
            let currentRow = [sortedByY[0]];

            for (let i = 1; i < sortedByY.length; i++) {
                const current = sortedByY[i];
                const previous = sortedByY[i - 1];

                const yGap = current.y - (previous.y + previous.height);

                if (yGap > threshold) {
                    rows.push(currentRow);
                    currentRow = [current];
                } else {
                    currentRow.push(current);
                }
            }

            if (currentRow.length > 0) {
                rows.push(currentRow);
            }

            return rows;
        }

        // æŒ‰åˆ—åˆ†ç»„
        function groupByColumns(elements, threshold) {
            const sortedByX = [...elements].sort((a, b) => a.x - b.x);
            const columns = [];
            let currentColumn = [sortedByX[0]];

            for (let i = 1; i < sortedByX.length; i++) {
                const current = sortedByX[i];
                const previous = sortedByX[i - 1];

                const xGap = current.x - (previous.x + previous.width);

                if (xGap > threshold) {
                    columns.push(currentColumn);
                    currentColumn = [current];
                } else {
                    currentColumn.push(current);
                }
            }

            if (currentColumn.length > 0) {
                columns.push(currentColumn);
            }

            return columns;
        }

        // è®¡ç®—ä¸¤ä¸ªå…ƒç´ ä¹‹é—´çš„è·ç¦»
        function calculateDistance(elem1, elem2) {
            const center1 = {
                x: elem1.x + elem1.width / 2,
                y: elem1.y + elem1.height / 2
            };
            const center2 = {
                x: elem2.x + elem2.width / 2,
                y: elem2.y + elem2.height / 2
            };

            return Math.sqrt(
                Math.pow(center1.x - center2.x, 2) +
                Math.pow(center1.y - center2.y, 2)
            );
        }

        // è®¡ç®—è¾¹ç•Œ
        function calculateBounds(elements) {
            if (elements.length === 0) return { x: 0, y: 0, width: 0, height: 0 };

            const minX = Math.min(...elements.map(e => e.x));
            const minY = Math.min(...elements.map(e => e.y));
            const maxX = Math.max(...elements.map(e => e.x + e.width));
            const maxY = Math.max(...elements.map(e => e.y + e.height));

            return {
                x: minX - 5,
                y: minY - 5,
                width: maxX - minX + 10,
                height: maxY - minY + 10
            };
        }

        // ğŸ¯ ç¡®å®šåˆ†ç»„ç±»å‹å’Œå¸ƒå±€æ–¹å‘ï¼ˆFlexå¸ƒå±€å¯¼å‘ï¼‰
        function determineGroupType(elements, hierarchy) {
            if (elements.length <= 1) {
                return { type: hierarchy.name, direction: 'NONE' };
            }

            // è®¡ç®—å¸ƒå±€æ–¹å‘
            const direction = determineFlexDirection(elements);

            // æ ¹æ®å…ƒç´ ç±»å‹å’Œä½ç½®ç‰¹å¾ç¡®å®šæœ€é€‚åˆçš„åˆ†ç»„ç±»å‹
            const hasImages = elements.some(e => e.type === 'image');
            const hasButtons = elements.some(e => e.type === 'button');
            const hasText = elements.some(e => e.type === 'text');

            let groupType = hierarchy.name;

            // ç®€åŒ–çš„ç±»å‹åˆ¤æ–­é€»è¾‘
            if (hasButtons && hasText) groupType = 'nav';
            else if (hasImages && hasText) groupType = 'article';
            else if (elements.length > 3) groupType = 'section';

            return { type: groupType, direction };
        }

        // ğŸ¯ ç¡®å®šFlexå¸ƒå±€æ–¹å‘
        function determineFlexDirection(elements) {
            if (elements.length <= 1) return 'NONE';

            // è®¡ç®—å…ƒç´ çš„ä½ç½®åˆ†å¸ƒ
            const positions = elements.map(e => ({ x: e.x, y: e.y, width: e.width, height: e.height }));

            // è®¡ç®—Xå’ŒYæ–¹å‘çš„å˜åŒ–ç¨‹åº¦
            const xPositions = positions.map(p => p.x);
            const yPositions = positions.map(p => p.y);

            const xRange = Math.max(...xPositions) - Math.min(...xPositions);
            const yRange = Math.max(...yPositions) - Math.min(...yPositions);

            // è®¡ç®—å¹³å‡å…ƒç´ å°ºå¯¸
            const avgWidth = positions.reduce((sum, p) => sum + p.width, 0) / positions.length;
            const avgHeight = positions.reduce((sum, p) => sum + p.height, 0) / positions.length;

            // åˆ¤æ–­ä¸»è¦å¸ƒå±€æ–¹å‘
            // å¦‚æœXæ–¹å‘çš„åˆ†å¸ƒè¿œå¤§äºYæ–¹å‘ï¼Œä¸”XèŒƒå›´å¤§äºå¹³å‡å®½åº¦ï¼Œåˆ™ä¸ºæ¨ªå‘
            if (xRange > yRange && xRange > avgWidth) {
                console.log(`ğŸ“ æ£€æµ‹åˆ°æ¨ªå‘å¸ƒå±€: XèŒƒå›´=${xRange}, YèŒƒå›´=${yRange}`);
                return 'HORIZONTAL';
            }
            // å¦‚æœYæ–¹å‘çš„åˆ†å¸ƒè¿œå¤§äºXæ–¹å‘ï¼Œä¸”YèŒƒå›´å¤§äºå¹³å‡é«˜åº¦ï¼Œåˆ™ä¸ºçºµå‘
            else if (yRange > xRange && yRange > avgHeight) {
                console.log(`ğŸ“ æ£€æµ‹åˆ°çºµå‘å¸ƒå±€: XèŒƒå›´=${xRange}, YèŒƒå›´=${yRange}`);
                return 'VERTICAL';
            }
            // é»˜è®¤æ¨ªå‘ï¼ˆä¼˜å…ˆæ¨ªå‘çš„ç­–ç•¥ï¼‰
            else {
                console.log(`ğŸ“ é»˜è®¤æ¨ªå‘å¸ƒå±€: XèŒƒå›´=${xRange}, YèŒƒå›´=${yRange}`);
                return 'HORIZONTAL';
            }
        }

        // æ¸²æŸ“å‡½æ•°
        function renderCanvas(elements, canvasId) {
            const canvas = document.getElementById(canvasId);
            canvas.innerHTML = '';

            if (!elements || elements.length === 0) return;

            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
            const maxX = Math.max(...elements.map(e => e.x + e.width));
            const maxY = Math.max(...elements.map(e => e.y + e.height));
            const scale = Math.min(canvas.clientWidth / maxX, canvas.clientHeight / maxY, 1) * 0.9;

            elements.forEach(element => {
                const div = document.createElement('div');
                div.className = `element element-${element.type}`;
                div.style.left = (element.x * scale) + 'px';
                div.style.top = (element.y * scale) + 'px';
                div.style.width = (element.width * scale) + 'px';
                div.style.height = (element.height * scale) + 'px';
                div.textContent = element.name.length > 8 ? element.name.substring(0, 8) + '...' : element.name;
                div.title = `${element.name}\nä½ç½®: (${element.x}, ${element.y})\nå°ºå¯¸: ${element.width} Ã— ${element.height}`;
                canvas.appendChild(div);
            });
        }

        function renderGroupBoundaries(group, canvasId, scale) {
            const canvas = document.getElementById(canvasId);

            function renderGroup(currentGroup) {
                // æ¸²æŸ“å½“å‰åˆ†ç»„è¾¹ç•Œ
                const boundary = document.createElement('div');
                boundary.className = `group-boundary ${currentGroup.type}`;
                boundary.style.left = (currentGroup.bounds.x * scale) + 'px';
                boundary.style.top = (currentGroup.bounds.y * scale) + 'px';
                boundary.style.width = (currentGroup.bounds.width * scale) + 'px';
                boundary.style.height = (currentGroup.bounds.height * scale) + 'px';

                const label = document.createElement('div');
                label.className = `group-label ${currentGroup.type}`;
                label.textContent = currentGroup.name;
                boundary.appendChild(label);

                canvas.appendChild(boundary);

                // é€’å½’æ¸²æŸ“å­åˆ†ç»„
                currentGroup.children.forEach(child => {
                    renderGroup(child);
                });
            }

            renderGroup(group);
        }

        function renderGroupedCanvas(elements, hierarchy) {
            renderCanvas(elements, 'grouped-canvas');

            // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹
            const canvas = document.getElementById('grouped-canvas');
            const maxX = Math.max(...elements.map(e => e.x + e.width));
            const maxY = Math.max(...elements.map(e => e.y + e.height));
            const scale = Math.min(canvas.clientWidth / maxX, canvas.clientHeight / maxY, 1) * 0.9;

            renderGroupBoundaries(hierarchy, 'grouped-canvas', scale);
        }

        // æ¸²æŸ“åŸå§‹æ‰å¹³ç»“æ„
        function renderOriginalTree(elements) {
            const container = document.getElementById('original-tree');
            container.innerHTML = '';

            const rootNode = createTreeNode('flat', 'ğŸ“„ åŸå§‹å…ƒç´ åˆ—è¡¨', elements.length, 'root');
            container.appendChild(rootNode);

            const childrenContainer = rootNode.querySelector('.node-children');
            elements.forEach((element, index) => {
                const elementNode = createTreeNode('element', `${getElementIcon(element.type)} ${element.name}`, 0, `element_${index}`, true);
                childrenContainer.appendChild(elementNode);
            });

            // é»˜è®¤å±•å¼€æ ¹èŠ‚ç‚¹
            toggleNode('root');
        }

        // æ¸²æŸ“åˆ†ç»„åçš„å±‚æ¬¡ç»“æ„
        function renderGroupTree(group) {
            const container = document.getElementById('grouped-tree');
            container.innerHTML = '';

            function buildInteractiveTree(currentGroup, parentContainer) {
                const hasChildren = currentGroup.children.length > 0;
                const nodeId = `group_${currentGroup.id}`;

                // æ·»åŠ å¸ƒå±€æ–¹å‘å›¾æ ‡
                const directionIcon = getDirectionIcon(currentGroup.direction);
                const treeNode = createTreeNode(
                    currentGroup.type,
                    `${directionIcon} ${currentGroup.name}`,
                    currentGroup.elements.length,
                    nodeId,
                    !hasChildren
                );

                parentContainer.appendChild(treeNode);

                if (hasChildren) {
                    const childrenContainer = treeNode.querySelector('.node-children');
                    currentGroup.children.forEach(child => {
                        buildInteractiveTree(child, childrenContainer);
                    });
                } else {
                    // å¶å­èŠ‚ç‚¹æ˜¾ç¤ºå…ƒç´ åˆ—è¡¨
                    const childrenContainer = treeNode.querySelector('.node-children');
                    currentGroup.elements.forEach((element, index) => {
                        const elementNode = createTreeNode('element', `${getElementIcon(element.type)} ${element.name}`, 0, `${nodeId}_element_${index}`, true);
                        childrenContainer.appendChild(elementNode);
                    });
                }
            }

            buildInteractiveTree(group, container);

            // é»˜è®¤å±•å¼€æ ¹èŠ‚ç‚¹
            toggleNode(`group_${group.id}`);
        }

        // åˆ›å»ºäº¤äº’å¼æ ‘èŠ‚ç‚¹
        function createTreeNode(type, label, count, nodeId, isLeaf = false) {
            const treeNode = document.createElement('div');
            treeNode.className = 'tree-node';
            treeNode.innerHTML = `
                <div class="node-content ${type}">
                    <div class="node-toggle ${isLeaf ? 'leaf' : ''}" data-node-id="${nodeId}">
                        ${isLeaf ? 'â€¢' : '+'}
                    </div>
                    <span class="node-label">${label}</span>
                    ${count > 0 ? `<span class="node-count">${count}</span>` : ''}
                </div>
                <div class="node-children" id="children_${nodeId}"></div>
            `;

            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            if (!isLeaf) {
                const toggle = treeNode.querySelector('.node-toggle');
                toggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleNode(nodeId);
                });
            }

            return treeNode;
        }

        // åˆ‡æ¢èŠ‚ç‚¹å±•å¼€/æ”¶èµ·çŠ¶æ€
        function toggleNode(nodeId) {
            const toggle = document.querySelector(`[data-node-id="${nodeId}"]`);
            const children = document.getElementById(`children_${nodeId}`);

            if (!toggle || !children) return;

            const isExpanded = children.classList.contains('expanded');

            if (isExpanded) {
                children.classList.remove('expanded');
                toggle.textContent = '+';
                toggle.classList.remove('expanded');
            } else {
                children.classList.add('expanded');
                toggle.textContent = 'âˆ’';
                toggle.classList.add('expanded');
            }
        }

        // å±•å¼€æ‰€æœ‰èŠ‚ç‚¹
        function expandAllNodes() {
            document.querySelectorAll('.node-toggle:not(.leaf)').forEach(toggle => {
                const nodeId = toggle.dataset.nodeId;
                const children = document.getElementById(`children_${nodeId}`);
                if (children && !children.classList.contains('expanded')) {
                    toggleNode(nodeId);
                }
            });
        }

        // æ”¶èµ·æ‰€æœ‰èŠ‚ç‚¹
        function collapseAllNodes() {
            document.querySelectorAll('.node-toggle:not(.leaf)').forEach(toggle => {
                const nodeId = toggle.dataset.nodeId;
                const children = document.getElementById(`children_${nodeId}`);
                if (children && children.classList.contains('expanded')) {
                    toggleNode(nodeId);
                }
            });
        }

        // è·å–åˆ†ç»„å›¾æ ‡
        function getGroupIcon(type) {
            const icons = {
                page: 'ğŸŒ',
                section: 'ğŸ”´',
                article: 'ğŸŸ ',
                header: 'ğŸŸ¡',
                nav: 'ğŸŸ¤',
                main: 'ğŸŸ¢',
                aside: 'ğŸ”µ',
                div: 'ğŸ”·',
                component: 'ğŸ”¹'
            };
            return icons[type] || 'ğŸ“¦';
        }

        // è·å–å…ƒç´ å›¾æ ‡
        function getElementIcon(type) {
            const icons = {
                container: 'ğŸ“¦',
                text: 'ğŸ“',
                button: 'ğŸ”˜',
                image: 'ğŸ–¼ï¸',
                normal: 'âšª'
            };
            return icons[type] || 'âšª';
        }

        // ğŸ¯ è·å–å¸ƒå±€æ–¹å‘å›¾æ ‡
        function getDirectionIcon(direction) {
            const icons = {
                'HORIZONTAL': 'â†”ï¸',  // æ¨ªå‘å¸ƒå±€
                'VERTICAL': 'â†•ï¸',    // çºµå‘å¸ƒå±€
                'NONE': 'âšª'         // å•ä¸ªå…ƒç´ 
            };
            return icons[direction] || 'â†”ï¸'; // é»˜è®¤æ¨ªå‘
        }

        function updateStats(elements, hierarchy) {
            const totalGroups = countTotalGroups(hierarchy);
            const maxDepth = getMaxDepth(hierarchy);
            const avgGroupSize = calculateAverageGroupSize(hierarchy);
            const coverageRate = 100; // æ‰€æœ‰å…ƒç´ éƒ½è¢«è¦†ç›–

            document.getElementById('total-elements').textContent = elements.length;
            document.getElementById('total-groups').textContent = totalGroups;
            document.getElementById('coverage-rate').textContent = coverageRate + '%';
            document.getElementById('max-depth').textContent = maxDepth;
            document.getElementById('avg-group-size').textContent = avgGroupSize.toFixed(1);
        }

        function countTotalGroups(group) {
            let count = 1; // å½“å‰åˆ†ç»„
            group.children.forEach(child => {
                count += countTotalGroups(child);
            });
            return count;
        }

        function getMaxDepth(group) {
            if (group.children.length === 0) return group.level;

            let maxChildDepth = 0;
            group.children.forEach(child => {
                maxChildDepth = Math.max(maxChildDepth, getMaxDepth(child));
            });

            return maxChildDepth;
        }

        function calculateAverageGroupSize(group) {
            const allGroups = [];

            function collectGroups(currentGroup) {
                allGroups.push(currentGroup);
                currentGroup.children.forEach(child => {
                    collectGroups(child);
                });
            }

            collectGroups(group);

            const totalElements = allGroups.reduce((sum, g) => sum + g.elements.length, 0);
            return totalElements / allGroups.length;
        }

        function runGrouping() {
            console.log('ğŸ”„ å¼€å§‹æ‰§è¡Œæ— é˜ˆå€¼åˆ†ç»„ç®—æ³•...');

            const elements = testCases[currentCase];
            console.log('ğŸ“Š å…ƒç´ æ•°æ®:', elements);

            if (!elements || elements.length === 0) {
                console.error('âŒ æ²¡æœ‰æ‰¾åˆ°æµ‹è¯•æ•°æ®');
                return;
            }

            const hierarchy = performCompleteHierarchicalGrouping(elements);
            console.log('ğŸ—ï¸ åˆ†ç»„ç»“æœ:', hierarchy);

            currentGroups = [hierarchy];

            try {
                renderCanvas(elements, 'original-canvas');
                console.log('âœ… åŸå§‹ç”»å¸ƒæ¸²æŸ“å®Œæˆ');

                renderGroupedCanvas(elements, hierarchy);
                console.log('âœ… åˆ†ç»„ç”»å¸ƒæ¸²æŸ“å®Œæˆ');

                renderOriginalTree(elements);
                console.log('âœ… åŸå§‹æ ‘å½¢ç»“æ„æ¸²æŸ“å®Œæˆ');

                renderGroupTree(hierarchy);
                console.log('âœ… åˆ†ç»„æ ‘å½¢ç»“æ„æ¸²æŸ“å®Œæˆ');

                updateStats(elements, hierarchy);
                console.log('âœ… ç»Ÿè®¡ä¿¡æ¯æ›´æ–°å®Œæˆ');

            } catch (error) {
                console.error('âŒ æ¸²æŸ“é”™è¯¯:', error);
            }
        }

        // äº‹ä»¶ç›‘å¬å™¨
        function initEventListeners() {
            // æµ‹è¯•ç”¨ä¾‹æŒ‰é’®
            document.querySelectorAll('.test-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.test-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentCase = btn.dataset.case;
                    runGrouping();
                });
            });

            // æ ‘å½¢æ§åˆ¶æŒ‰é’®
            document.getElementById('expand-all-btn').addEventListener('click', expandAllNodes);
            document.getElementById('collapse-all-btn').addEventListener('click', collapseAllNodes);
            document.getElementById('refresh-btn').addEventListener('click', runGrouping);
        }

        // åˆå§‹åŒ–
        function init() {
            console.log('ğŸš€ å¼€å§‹åˆå§‹åŒ–...');
            console.log('å½“å‰æµ‹è¯•ç”¨ä¾‹:', currentCase);
            console.log('æµ‹è¯•æ•°æ®:', testCases[currentCase]);

            // å…ˆæµ‹è¯•åŸºæœ¬çš„DOMæ“ä½œ
            const originalCanvas = document.getElementById('original-canvas');
            const groupedCanvas = document.getElementById('grouped-canvas');

            if (!originalCanvas || !groupedCanvas) {
                console.error('âŒ æ‰¾ä¸åˆ°ç”»å¸ƒå…ƒç´ ');
                return;
            }

            console.log('âœ… ç”»å¸ƒå…ƒç´ æ‰¾åˆ°');

            try {
                initEventListeners();
                console.log('âœ… äº‹ä»¶ç›‘å¬å™¨åˆå§‹åŒ–å®Œæˆ');

                // å»¶è¿Ÿæ‰§è¡Œåˆ†ç»„ç®—æ³•ï¼Œç¡®ä¿DOMå®Œå…¨åŠ è½½
                setTimeout(() => {
                    runGrouping();
                    console.log('âœ… åˆ†ç»„ç®—æ³•æ‰§è¡Œå®Œæˆ');
                }, 100);

                console.log('ğŸŒ å®Œæ•´å±‚æ¬¡åŒ–åˆ†ç»„ç®—æ³•å·²åŠ è½½');
            } catch (error) {
                console.error('âŒ åˆå§‹åŒ–é”™è¯¯:', error);
                console.error('é”™è¯¯å †æ ˆ:', error.stack);
            }
        }

        // åˆ†ç»„æ­£ç¡®æ€§æ ¡éªŒå‡½æ•°
        function validateGrouping(elements, hierarchy) {
            console.log('\nğŸ” å¼€å§‹æ ¡éªŒåˆ†ç»„æ­£ç¡®æ€§...');

            const issues = [];
            const warnings = [];

            // 1. æ£€æŸ¥æ‰€æœ‰å…ƒç´ æ˜¯å¦éƒ½è¢«åŒ…å«
            const allElementsInHierarchy = getAllElementsFromHierarchy(hierarchy);
            const originalElementIds = new Set(elements.map(e => e.id));
            const hierarchyElementIds = new Set(allElementsInHierarchy.map(e => e.id));

            for (const id of originalElementIds) {
                if (!hierarchyElementIds.has(id)) {
                    issues.push(`âŒ å…ƒç´  ${id} åœ¨åˆ†ç»„ä¸­ä¸¢å¤±`);
                }
            }

            // 2. æ£€æŸ¥ç©ºé—´åŒ…å«å…³ç³»æ˜¯å¦æ­£ç¡®
            function validateSpatialRelations(group) {
                if (group.children.length === 0) return;

                for (const child of group.children) {
                    // æ£€æŸ¥å­å…ƒç´ æ˜¯å¦çœŸçš„åœ¨çˆ¶å…ƒç´ å†…éƒ¨
                    if (child.elements && child.elements.length > 0) {
                        const childBounds = child.bounds;
                        const parentBounds = group.bounds;

                        if (childBounds.x < parentBounds.x ||
                            childBounds.y < parentBounds.y ||
                            childBounds.x + childBounds.width > parentBounds.x + parentBounds.width ||
                            childBounds.y + childBounds.height > parentBounds.y + parentBounds.height) {
                            warnings.push(`âš ï¸ å­åˆ†ç»„ ${child.name} è¶…å‡ºçˆ¶åˆ†ç»„ ${group.name} è¾¹ç•Œ`);
                        }
                    }

                    // é€’å½’æ£€æŸ¥å­åˆ†ç»„
                    validateSpatialRelations(child);
                }
            }

            validateSpatialRelations(hierarchy);

            // 3. æ£€æŸ¥åˆ†ç»„çš„åˆç†æ€§
            function validateGroupLogic(group) {
                if (group.children.length === 0) return;

                // æ£€æŸ¥æ˜¯å¦æœ‰å•å­èŠ‚ç‚¹åˆ†ç»„ï¼ˆåº”è¯¥å·²ç»è¢«ä¼˜åŒ–æ‰äº†ï¼‰
                if (group.children.length === 1) {
                    warnings.push(`âš ï¸ åˆ†ç»„ ${group.name} åªæœ‰ä¸€ä¸ªå­åˆ†ç»„ï¼Œå¯èƒ½éœ€è¦è¿›ä¸€æ­¥ä¼˜åŒ–`);
                }

                // æ£€æŸ¥åˆ†ç»„æ–¹å‘æ˜¯å¦åˆç†
                if (group.children.length > 1) {
                    const direction = group.direction;
                    const childPositions = group.children.map(child => ({
                        x: child.bounds.x,
                        y: child.bounds.y,
                        width: child.bounds.width,
                        height: child.bounds.height
                    }));

                    if (direction === 'HORIZONTAL') {
                        // æ°´å¹³åˆ†ç»„ï¼šæ£€æŸ¥æ˜¯å¦çœŸçš„æ˜¯æ°´å¹³æ’åˆ—
                        const avgY = childPositions.reduce((sum, pos) => sum + pos.y, 0) / childPositions.length;
                        const yVariance = childPositions.reduce((sum, pos) => sum + Math.pow(pos.y - avgY, 2), 0) / childPositions.length;

                        if (yVariance > 1000) { // é˜ˆå€¼å¯è°ƒæ•´
                            warnings.push(`âš ï¸ åˆ†ç»„ ${group.name} æ ‡è®°ä¸ºæ°´å¹³å¸ƒå±€ï¼Œä½†å­å…ƒç´ å‚ç›´ä½ç½®å·®å¼‚è¾ƒå¤§`);
                        }
                    } else if (direction === 'VERTICAL') {
                        // å‚ç›´åˆ†ç»„ï¼šæ£€æŸ¥æ˜¯å¦çœŸçš„æ˜¯å‚ç›´æ’åˆ—
                        const avgX = childPositions.reduce((sum, pos) => sum + pos.x, 0) / childPositions.length;
                        const xVariance = childPositions.reduce((sum, pos) => sum + Math.pow(pos.x - avgX, 2), 0) / childPositions.length;

                        if (xVariance > 1000) { // é˜ˆå€¼å¯è°ƒæ•´
                            warnings.push(`âš ï¸ åˆ†ç»„ ${group.name} æ ‡è®°ä¸ºå‚ç›´å¸ƒå±€ï¼Œä½†å­å…ƒç´ æ°´å¹³ä½ç½®å·®å¼‚è¾ƒå¤§`);
                        }
                    }
                }

                // é€’å½’æ£€æŸ¥å­åˆ†ç»„
                group.children.forEach(validateGroupLogic);
            }

            validateGroupLogic(hierarchy);

            // 4. è¾“å‡ºæ ¡éªŒç»“æœ
            console.log('\nğŸ“Š åˆ†ç»„æ ¡éªŒç»“æœ:');
            console.log('================');

            if (issues.length === 0 && warnings.length === 0) {
                console.log('âœ… åˆ†ç»„å®Œå…¨æ­£ç¡®ï¼æ²¡æœ‰å‘ç°é—®é¢˜ã€‚');
            } else {
                if (issues.length > 0) {
                    console.log('âŒ å‘ç°ä¸¥é‡é—®é¢˜:');
                    issues.forEach(issue => console.log('  ' + issue));
                }

                if (warnings.length > 0) {
                    console.log('âš ï¸ å‘ç°æ½œåœ¨é—®é¢˜:');
                    warnings.forEach(warning => console.log('  ' + warning));
                }
            }

            // 5. è¾“å‡ºåˆ†ç»„ç»Ÿè®¡
            const stats = {
                totalElements: elements.length,
                totalGroups: countTotalGroups(hierarchy),
                maxDepth: getMaxDepth(hierarchy),
                avgGroupSize: calculateAverageGroupSize(hierarchy)
            };

            console.log('\nğŸ“ˆ åˆ†ç»„ç»Ÿè®¡:');
            console.log(`  æ€»å…ƒç´ æ•°: ${stats.totalElements}`);
            console.log(`  æ€»åˆ†ç»„æ•°: ${stats.totalGroups}`);
            console.log(`  æœ€å¤§æ·±åº¦: ${stats.maxDepth}`);
            console.log(`  å¹³å‡åˆ†ç»„å¤§å°: ${stats.avgGroupSize.toFixed(1)}`);

            return {
                isValid: issues.length === 0,
                issues,
                warnings,
                stats
            };
        }

        // ä»å±‚æ¬¡ç»“æ„ä¸­è·å–æ‰€æœ‰å…ƒç´ 
        function getAllElementsFromHierarchy(group) {
            let allElements = [...group.elements];
            for (const child of group.children) {
                allElements = allElements.concat(getAllElementsFromHierarchy(child));
            }
            return allElements;
        }

        // ğŸ¯ æ ¡éªŒå½“å‰ç”¨ä¾‹çš„åˆ†ç»„é€»è¾‘
        function testFunction() {
            console.log(`\nğŸ” ===== è¯¦ç»†æ ¡éªŒç”¨ä¾‹: ${currentCase} =====`);
            validateSingleCaseDetailed(currentCase);
        }

        // ğŸ¯ è¯¦ç»†æ ¡éªŒå•ä¸ªç”¨ä¾‹
        function validateSingleCaseDetailed(caseId) {
            const elements = testCases[caseId];
            if (!elements || elements.length === 0) {
                console.error(`âŒ ${caseId}: æ²¡æœ‰æµ‹è¯•æ•°æ®`);
                return false;
            }

            console.log(`\nğŸ“‹ è¯¦ç»†åˆ†æç”¨ä¾‹: ${caseId}`);
            console.log(`å…ƒç´ åˆ—è¡¨: ${elements.map(e => `${e.name}(${e.x},${e.y},${e.width}Ã—${e.height})`).join(', ')}`);

            try {
                // æ‰§è¡Œåˆ†ç»„ç®—æ³•å¹¶è·å–è¯¦ç»†è¿‡ç¨‹
                const hierarchy = performCompleteHierarchicalGrouping(elements);
                const actualGroups = extractGroupsFromHierarchy(hierarchy);
                const expectedGroups = getExpectedGroups(caseId);

                console.log(`\nğŸ“Š åˆ†ç»„å¯¹æ¯”:`);
                console.log(`é¢„æœŸåˆ†ç»„ (${expectedGroups.length} ç»„):`);
                expectedGroups.forEach((group, index) => {
                    console.log(`  ${index + 1}. [${group.join(', ')}]`);
                });

                console.log(`å®é™…åˆ†ç»„ (${actualGroups.length} ç»„):`);
                actualGroups.forEach((group, index) => {
                    console.log(`  ${index + 1}. [${group.join(', ')}]`);
                });

                return compareGroupingResults(caseId, actualGroups, expectedGroups);

            } catch (error) {
                console.error(`âŒ ${caseId}: åˆ†ç»„ç®—æ³•æ‰§è¡Œé”™è¯¯:`, error);
                return false;
            }
        }

        // å…¨å±€é”™è¯¯ä¿¡æ¯æ”¶é›†
        let globalErrorMessages = [];

        // ğŸ¯ æ ¡éªŒæ‰€æœ‰ç”¨ä¾‹çš„åˆ†ç»„é€»è¾‘
        function validateAllCases() {
            console.log(`\nğŸ” ===== æ ¡éªŒæ‰€æœ‰åˆ†ç»„é€»è¾‘ =====`);

            // æ¸…ç©ºä¹‹å‰çš„é”™è¯¯ä¿¡æ¯
            globalErrorMessages = [];

            const cases = ['simple_card', 'basic_layout', 'form_example', 'navigation_bar', 'dashboard_simple'];
            let passedCount = 0;

            cases.forEach(caseId => {
                const passed = validateSingleCase(caseId);
                if (passed) passedCount++;
            });

            const summary = `ğŸ“Š æ€»ä½“æ ¡éªŒç»“æœ: ${passedCount}/${cases.length} é€šè¿‡`;
            console.log(`\n${summary}`);
            globalErrorMessages.push(summary);

            if (passedCount === cases.length) {
                const successMsg = 'ğŸ‰ æ‰€æœ‰ç”¨ä¾‹æ ¡éªŒé€šè¿‡ï¼';
                console.log(successMsg);
                globalErrorMessages.push(successMsg);
            } else {
                const warningMsg = 'âš ï¸ éƒ¨åˆ†ç”¨ä¾‹éœ€è¦æ”¹è¿›';
                console.log(warningMsg);
                globalErrorMessages.push(warningMsg);
            }

            // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯åˆ°é¡µé¢
            displayErrorMessages();
        }

        // ğŸ¯ æ ¡éªŒå•ä¸ªç”¨ä¾‹
        function validateSingleCase(caseId) {
            const elements = testCases[caseId];
            if (!elements || elements.length === 0) {
                const errorMsg = `âŒ ${caseId}: æ²¡æœ‰æµ‹è¯•æ•°æ®`;
                console.error(errorMsg);
                globalErrorMessages.push(errorMsg);
                return false;
            }

            const caseHeader = `\nğŸ“‹ æ ¡éªŒç”¨ä¾‹: ${caseId}`;
            console.log(caseHeader);
            globalErrorMessages.push(caseHeader);

            const elementList = `å…ƒç´ åˆ—è¡¨: ${elements.map(e => e.name).join(', ')}`;
            console.log(elementList);
            globalErrorMessages.push(elementList);

            try {
                const hierarchy = performCompleteHierarchicalGrouping(elements);
                const actualGroups = extractGroupsFromHierarchy(hierarchy);
                const expectedGroups = getExpectedGroups(caseId);

                return compareGroupingResults(caseId, actualGroups, expectedGroups);

            } catch (error) {
                const errorMsg = `âŒ ${caseId}: åˆ†ç»„ç®—æ³•æ‰§è¡Œé”™è¯¯: ${error.message}`;
                console.error(errorMsg);
                globalErrorMessages.push(errorMsg);
                return false;
            }
        }

        // ğŸ¯ è·å–é¢„æœŸçš„åˆ†ç»„ç»“æœ
        function getExpectedGroups(caseId) {
            const expected = {
                'simple_card': [
                    ['ç”¨æˆ·ä¿¡æ¯'],
                    ['å¤´åƒ', 'å¼ ä¸‰', 'zhang@email.com'],
                    ['ç¼–è¾‘æŒ‰é’®']
                ],
                'basic_layout': [
                    ['Logo', 'é¦–é¡µ', 'å…³äº'],
                    ['æ¬¢è¿ä½¿ç”¨', 'è¿™æ˜¯ä¸»è¦å†…å®¹åŒºåŸŸ...'],
                    ['ç›¸å…³é“¾æ¥', 'å¸®åŠ©æ–‡æ¡£', 'è”ç³»æˆ‘ä»¬'],
                    ['å¼€å§‹ä½¿ç”¨']
                ],
                'form_example': [
                    ['åŸºæœ¬ä¿¡æ¯'],
                    ['å§“å:', 'å§“åè¾“å…¥æ¡†', 'é‚®ç®±:', 'é‚®ç®±è¾“å…¥æ¡†'],
                    ['å¯†ç è®¾ç½®'],
                    ['å¯†ç :', 'å¯†ç è¾“å…¥æ¡†', 'ç¡®è®¤å¯†ç :', 'ç¡®è®¤å¯†ç è¾“å…¥æ¡†'],
                    ['æ³¨å†Œ', 'å–æ¶ˆ']
                ],
                'navigation_bar': [
                    ['Logo', 'æˆ‘çš„ç½‘ç«™'],
                    ['é¦–é¡µ', 'äº§å“', 'æœåŠ¡', 'å…³äº'],
                    ['æœç´¢æ¡†', 'ç™»å½•', 'æ³¨å†Œ']
                ],
                'dashboard_simple': [
                    ['æ•°æ®ä»ªè¡¨æ¿', 'åˆ·æ–°'],
                    ['æ€»ç”¨æˆ·', '1,234', '+12%'],
                    ['é”€å”®é¢', 'Â¥56,789', '+8%'],
                    ['è®¢å•æ•°', '456', '+15%'],
                    ['æœ€è¿‘æ´»åŠ¨', 'æ–°ç”¨æˆ·æ³¨å†Œ', 'è®¢å•å®Œæˆ', 'æ”¯ä»˜æˆåŠŸ'],
                    ['é”€å”®è¶‹åŠ¿', 'å›¾è¡¨å†…å®¹']
                ]
            };

            return expected[caseId] || [];
        }

        // ğŸ¯ ä»å±‚æ¬¡ç»“æ„ä¸­æå–åˆ†ç»„ï¼ˆä¿®å¤ç‰ˆæœ¬ï¼‰
        function extractGroupsFromHierarchy(hierarchy) {
            const groups = [];

            function extractGroups(node) {
                console.log(`ğŸ” æå–åˆ†ç»„ - èŠ‚ç‚¹: ${node.name}, å…ƒç´ æ•°: ${node.elements?.length || 0}, å­èŠ‚ç‚¹æ•°: ${node.children?.length || 0}`);

                // å¦‚æœæœ‰å­èŠ‚ç‚¹ï¼Œä¼˜å…ˆå¤„ç†å­èŠ‚ç‚¹
                if (node.children && node.children.length > 0) {
                    console.log(`  ğŸ“‚ å¤„ç† ${node.children.length} ä¸ªå­èŠ‚ç‚¹`);
                    node.children.forEach(child => extractGroups(child));
                } else if (node.elements && node.elements.length > 0) {
                    // åªæœ‰åœ¨æ²¡æœ‰å­èŠ‚ç‚¹æ—¶ï¼Œæ‰å°†å…ƒç´ ä½œä¸ºå¶å­åˆ†ç»„
                    const elementNames = node.elements.map(e => e.name);
                    console.log(`  ğŸ“¦ å¶å­åˆ†ç»„: [${elementNames.join(', ')}]`);
                    groups.push(elementNames);
                }
            }

            extractGroups(hierarchy);
            console.log(`ğŸ¯ æœ€ç»ˆæå–åˆ° ${groups.length} ä¸ªåˆ†ç»„: ${groups.map(g => `[${g.join(', ')}]`).join(', ')}`);
            return groups;
        }

        // ğŸ¯ æ¯”è¾ƒåˆ†ç»„ç»“æœ
        function compareGroupingResults(caseId, actualGroups, expectedGroups) {
            const comparisonHeader = `\nğŸ” ${caseId} - åˆ†ç»„å¯¹æ¯”:`;
            console.log(comparisonHeader);
            globalErrorMessages.push(comparisonHeader);

            const expectedInfo = `é¢„æœŸåˆ†ç»„ (${expectedGroups.length} ç»„): ${JSON.stringify(expectedGroups)}`;
            const actualInfo = `å®é™…åˆ†ç»„ (${actualGroups.length} ç»„): ${JSON.stringify(actualGroups)}`;
            console.log(expectedInfo);
            console.log(actualInfo);
            globalErrorMessages.push(expectedInfo);
            globalErrorMessages.push(actualInfo);

            let passed = true;
            const issues = [];

            // æ£€æŸ¥åˆ†ç»„æ•°é‡
            if (actualGroups.length !== expectedGroups.length) {
                issues.push(`åˆ†ç»„æ•°é‡ä¸åŒ¹é…: é¢„æœŸ ${expectedGroups.length}, å®é™… ${actualGroups.length}`);
                passed = false;
            }

            // æ£€æŸ¥æ¯ä¸ªåˆ†ç»„çš„å†…å®¹
            expectedGroups.forEach((expectedGroup, index) => {
                const actualGroup = actualGroups[index];

                if (!actualGroup) {
                    issues.push(`ç¼ºå°‘ç¬¬ ${index + 1} ä¸ªåˆ†ç»„: ${expectedGroup.join(', ')}`);
                    passed = false;
                    return;
                }

                // æ£€æŸ¥åˆ†ç»„å†…å®¹æ˜¯å¦åŒ¹é…ï¼ˆå¿½ç•¥é¡ºåºï¼‰
                const expectedSet = new Set(expectedGroup);
                const actualSet = new Set(actualGroup);

                if (expectedSet.size !== actualSet.size) {
                    issues.push(`ç¬¬ ${index + 1} ç»„å…ƒç´ æ•°é‡ä¸åŒ¹é…: é¢„æœŸ ${expectedGroup.join(', ')}, å®é™… ${actualGroup.join(', ')}`);
                    passed = false;
                } else {
                    for (const item of expectedSet) {
                        if (!actualSet.has(item)) {
                            issues.push(`ç¬¬ ${index + 1} ç»„ç¼ºå°‘å…ƒç´ : ${item}`);
                            passed = false;
                        }
                    }
                    for (const item of actualSet) {
                        if (!expectedSet.has(item)) {
                            issues.push(`ç¬¬ ${index + 1} ç»„å¤šä½™å…ƒç´ : ${item}`);
                            passed = false;
                        }
                    }
                }
            });

            // è¾“å‡ºç»“æœ
            if (passed) {
                const successMsg = `âœ… ${caseId}: åˆ†ç»„é€»è¾‘æ­£ç¡®`;
                console.log(successMsg);
                globalErrorMessages.push(successMsg);
            } else {
                const errorMsg = `âŒ ${caseId}: åˆ†ç»„é€»è¾‘æœ‰é—®é¢˜`;
                console.log(errorMsg);
                globalErrorMessages.push(errorMsg);
                issues.forEach(issue => {
                    const issueMsg = `   - ${issue}`;
                    console.log(issueMsg);
                    globalErrorMessages.push(issueMsg);
                });
            }

            return passed;
        }

        // ğŸ¯ æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯åˆ°é¡µé¢
        function displayErrorMessages() {
            const errorOutput = document.getElementById('error-output');
            if (globalErrorMessages.length > 0) {
                errorOutput.innerHTML = globalErrorMessages.join('\n');
                errorOutput.style.display = 'block';
            } else {
                errorOutput.style.display = 'none';
            }
        }

        // ğŸ¯ å¤åˆ¶é”™è¯¯ä¿¡æ¯åˆ°å‰ªè´´æ¿
        function copyErrorsToClipboard() {
            if (globalErrorMessages.length === 0) {
                alert('æ²¡æœ‰é”™è¯¯ä¿¡æ¯å¯å¤åˆ¶ï¼Œè¯·å…ˆè¿è¡Œæ ¡éªŒ');
                return;
            }

            const errorText = globalErrorMessages.join('\n');

            // ä½¿ç”¨ç°ä»£çš„ Clipboard API
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(errorText).then(() => {
                    alert('é”™è¯¯ä¿¡æ¯å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
                }).catch(err => {
                    console.error('å¤åˆ¶å¤±è´¥:', err);
                    fallbackCopyToClipboard(errorText);
                });
            } else {
                // é™çº§æ–¹æ¡ˆ
                fallbackCopyToClipboard(errorText);
            }
        }

        // ğŸ¯ é™çº§å¤åˆ¶æ–¹æ¡ˆ
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                document.execCommand('copy');
                alert('é”™è¯¯ä¿¡æ¯å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
            } catch (err) {
                console.error('å¤åˆ¶å¤±è´¥:', err);
                alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶é¡µé¢ä¸Šæ˜¾ç¤ºçš„é”™è¯¯ä¿¡æ¯');
            }

            document.body.removeChild(textArea);
        }

        // ğŸ¯ æ˜¾ç¤ºè‡ªåŠ¨æµ‹è¯•ç»“æœ
        function displayAutoTestResults() {
            const autoTestDiv = document.getElementById('auto-test-result');
            const testContent = document.getElementById('test-content');

            if (globalErrorMessages.length > 0) {
                // æå–å…³é”®ä¿¡æ¯
                const keyLines = globalErrorMessages.filter(line =>
                    line.includes('æ ¡éªŒç”¨ä¾‹:') ||
                    line.includes('é¢„æœŸåˆ†ç»„') ||
                    line.includes('å®é™…åˆ†ç»„') ||
                    line.includes('åˆ†ç»„é€»è¾‘æœ‰é—®é¢˜') ||
                    line.includes('åˆ†ç»„é€»è¾‘æ­£ç¡®')
                );

                // æ ¼å¼åŒ–æ˜¾ç¤º
                let htmlContent = '';
                let currentCase = '';

                keyLines.forEach(line => {
                    if (line.includes('æ ¡éªŒç”¨ä¾‹:')) {
                        currentCase = line.replace('ğŸ“‹ æ ¡éªŒç”¨ä¾‹: ', '');
                        htmlContent += `<div style="margin: 10px 0; font-weight: bold; color: #0066cc;">${line}</div>`;
                    } else if (line.includes('é¢„æœŸåˆ†ç»„')) {
                        htmlContent += `<div style="margin: 5px 0; color: #28a745;">${line}</div>`;
                    } else if (line.includes('å®é™…åˆ†ç»„')) {
                        htmlContent += `<div style="margin: 5px 0; color: #dc3545;">${line}</div>`;
                    } else if (line.includes('åˆ†ç»„é€»è¾‘')) {
                        const isCorrect = line.includes('æ­£ç¡®');
                        const color = isCorrect ? '#28a745' : '#dc3545';
                        const icon = isCorrect ? 'âœ…' : 'âŒ';
                        htmlContent += `<div style="margin: 5px 0; color: ${color}; font-weight: bold;">${icon} ${line}</div>`;
                    }
                });

                testContent.innerHTML = htmlContent;
                autoTestDiv.style.display = 'block';

                // æ»šåŠ¨åˆ°ç»“æœåŒºåŸŸ
                autoTestDiv.scrollIntoView({ behavior: 'smooth' });
            }
        }

        // ğŸ¯ è‡ªåŠ¨æµ‹è¯•å’Œåˆ†æå‡½æ•°
        function runAutoTestAndAnalyze() {
            console.log('\nğŸ¤– å¼€å§‹è‡ªåŠ¨æµ‹è¯•å’Œåˆ†æ...');

            // è¿è¡Œæ‰€æœ‰æµ‹è¯•
            validateAllCases();

            // åˆ†æç»“æœ
            const testResults = analyzeTestResults();

            // è¾“å‡ºåˆ†æç»“æœ
            console.log('\nğŸ“Š === æµ‹è¯•ç»“æœåˆ†æ ===');
            console.log(`æ€»é€šè¿‡ç‡: ${testResults.passRate}%`);
            console.log(`å¤±è´¥ç”¨ä¾‹: ${testResults.failedCases.join(', ')}`);

            // è¾“å‡ºè¯¦ç»†é”™è¯¯åˆ†æ
            testResults.failedCases.forEach(caseId => {
                const caseAnalysis = analyzeCaseErrors(caseId);
                console.log(`\nğŸ” ${caseId} é”™è¯¯åˆ†æ:`);
                console.log(`  é—®é¢˜ç±»å‹: ${caseAnalysis.problemType}`);
                console.log(`  å»ºè®®ä¿®å¤: ${caseAnalysis.suggestion}`);
            });

            return testResults;
        }

        // ğŸ¯ åˆ†ææµ‹è¯•ç»“æœ
        function analyzeTestResults() {
            const cases = ['simple_card', 'basic_layout', 'form_example', 'navigation_bar', 'dashboard_simple'];
            const failedCases = [];
            let passedCount = 0;

            // ä»é”™è¯¯ä¿¡æ¯ä¸­æå–å¤±è´¥çš„ç”¨ä¾‹
            globalErrorMessages.forEach(line => {
                if (line.includes('åˆ†ç»„é€»è¾‘æœ‰é—®é¢˜')) {
                    const caseId = line.match(/(\w+):/)?.[1];
                    if (caseId && !failedCases.includes(caseId)) {
                        failedCases.push(caseId);
                    }
                } else if (line.includes('åˆ†ç»„é€»è¾‘æ­£ç¡®')) {
                    passedCount++;
                }
            });

            return {
                totalCases: cases.length,
                passedCount: passedCount,
                failedCases: failedCases,
                passRate: Math.round((passedCount / cases.length) * 100)
            };
        }

        // ğŸ¯ åˆ†æå•ä¸ªç”¨ä¾‹çš„é”™è¯¯
        function analyzeCaseErrors(caseId) {
            const caseMessages = globalErrorMessages.filter(line =>
                line.includes(caseId) ||
                (globalErrorMessages.indexOf(line) > globalErrorMessages.findIndex(l => l.includes(`æ ¡éªŒç”¨ä¾‹: ${caseId}`)) &&
                 globalErrorMessages.indexOf(line) < globalErrorMessages.findIndex(l => l.includes('æ ¡éªŒç”¨ä¾‹:') && l.indexOf(caseId) === -1))
            );

            let problemType = 'æœªçŸ¥é—®é¢˜';
            let suggestion = 'éœ€è¦è¿›ä¸€æ­¥åˆ†æ';

            // åˆ†æé—®é¢˜ç±»å‹
            if (caseMessages.some(line => line.includes('åˆ†ç»„æ•°é‡ä¸åŒ¹é…'))) {
                const actualCount = caseMessages.find(line => line.includes('å®é™…åˆ†ç»„'))?.match(/(\d+) ç»„/)?.[1];
                const expectedCount = caseMessages.find(line => line.includes('é¢„æœŸåˆ†ç»„'))?.match(/(\d+) ç»„/)?.[1];

                if (actualCount && expectedCount) {
                    if (parseInt(actualCount) > parseInt(expectedCount)) {
                        problemType = 'åˆ†ç»„è¿‡ç»†';
                        suggestion = 'éœ€è¦æ”¾å®½åˆ†ç»„æ¡ä»¶ï¼Œè®©æ›´å¤šå…ƒç´ åˆå¹¶åˆ°ä¸€ç»„';
                    } else {
                        problemType = 'åˆ†ç»„è¿‡ç²—';
                        suggestion = 'éœ€è¦ä¸¥æ ¼åˆ†ç»„æ¡ä»¶ï¼Œé¿å…ä¸ç›¸å…³å…ƒç´ è¢«åˆ†åˆ°ä¸€ç»„';
                    }
                }
            }

            return { problemType, suggestion };
        }

        // ğŸ¯ å°è¯•è‡ªåŠ¨ä¿®å¤
        function attemptAutoFix(testResults) {
            console.log(`\nğŸ”§ åˆ†æ ${testResults.failedCases.length} ä¸ªå¤±è´¥ç”¨ä¾‹...`);

            // ç»Ÿè®¡é—®é¢˜ç±»å‹
            const problemStats = {
                tooFine: 0,    // åˆ†ç»„è¿‡ç»†
                tooCoarse: 0,  // åˆ†ç»„è¿‡ç²—
                mixed: 0       // æ··åˆé—®é¢˜
            };

            testResults.failedCases.forEach(caseId => {
                const analysis = analyzeCaseErrors(caseId);
                if (analysis.problemType === 'åˆ†ç»„è¿‡ç»†') {
                    problemStats.tooFine++;
                } else if (analysis.problemType === 'åˆ†ç»„è¿‡ç²—') {
                    problemStats.tooCoarse++;
                } else {
                    problemStats.mixed++;
                }
            });

            console.log('é—®é¢˜ç»Ÿè®¡:', problemStats);

            // æ ¹æ®ä¸»è¦é—®é¢˜ç±»å‹è°ƒæ•´ç®—æ³•
            if (problemStats.tooFine > problemStats.tooCoarse) {
                console.log('ğŸ”§ ä¸»è¦é—®é¢˜ï¼šåˆ†ç»„è¿‡ç»†ï¼Œéœ€è¦æ”¾å®½æ¡ä»¶');
                adjustGroupingForCoarser();
            } else if (problemStats.tooCoarse > problemStats.tooFine) {
                console.log('ğŸ”§ ä¸»è¦é—®é¢˜ï¼šåˆ†ç»„è¿‡ç²—ï¼Œéœ€è¦ä¸¥æ ¼æ¡ä»¶');
                adjustGroupingForFiner();
            } else {
                console.log('ğŸ”§ é—®é¢˜ç±»å‹æ··åˆï¼Œéœ€è¦æ›´ç²¾ç»†çš„è°ƒæ•´');
                adjustGroupingMixed();
            }

            // é‡æ–°æµ‹è¯•
            setTimeout(() => {
                console.log('\nğŸ”„ é‡æ–°æµ‹è¯•ä¿®å¤æ•ˆæœ...');
                runAutoTestAndAnalyze();
            }, 1000);
        }

        // ğŸ¯ è°ƒæ•´ç®—æ³•ä½¿åˆ†ç»„æ›´ç²—ç³™ï¼ˆåˆå¹¶æ›´å¤šå…ƒç´ ï¼‰
        function adjustGroupingForCoarser() {
            console.log('è°ƒæ•´ç­–ç•¥ï¼šæ”¾å®½æˆªæ–­æ£€æµ‹æ¡ä»¶');
            // è¿™é‡Œå¯ä»¥åŠ¨æ€è°ƒæ•´ç®—æ³•å‚æ•°
            window.GROUPING_MODE = 'COARSER';
        }

        // ğŸ¯ è°ƒæ•´ç®—æ³•ä½¿åˆ†ç»„æ›´ç²¾ç»†ï¼ˆåˆ†ç¦»æ›´å¤šå…ƒç´ ï¼‰
        function adjustGroupingForFiner() {
            console.log('è°ƒæ•´ç­–ç•¥ï¼šä¸¥æ ¼æˆªæ–­æ£€æµ‹æ¡ä»¶');
            // è¿™é‡Œå¯ä»¥åŠ¨æ€è°ƒæ•´ç®—æ³•å‚æ•°
            window.GROUPING_MODE = 'FINER';
        }

        // ğŸ¯ æ··åˆè°ƒæ•´ç­–ç•¥
        function adjustGroupingMixed() {
            console.log('è°ƒæ•´ç­–ç•¥ï¼šä½¿ç”¨æ··åˆæ¨¡å¼');
            window.GROUPING_MODE = 'MIXED';
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
